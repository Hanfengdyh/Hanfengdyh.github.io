<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux文件属性和目录</title>
      <link href="/2022/11/15/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/11/15/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>正所谓Linux下皆文件，系统下一共分为7种文件：</p><p><strong>①普通文件</strong></p><p>普通文件（regular file）在 Linux 系统下是最常见的，譬如文本文件、二进制文件，我们编写的源代码文件这些都是普通文件。</p><p>普通文件分为文本文件和二进制文件。</p><p>文本文件：文件中的内容是由文本构成的，所谓文本指的是 ASCII 码字符。文件中的内容其本质上都是数字。</p><p>二进制文件：二进制文件中存储的本质上也是数字，只不过对于二进制文件来说，这些数字并不是文本字符编码，而是真正的数字。譬如 Linux 系统下的可执行文件、C 代码编译之后得到的.o 文件、.bin 文件等都是二进制件。</p><p><strong>②目录文件</strong></p><p>目录（directory）就是文件夹，文件夹在 Linux 系统中也是一种文件，是一种特殊文件。</p><p><strong>③字符设备文件和块设备文件</strong></p><p>Linux 系统下，一切皆文件，也包括各种硬件设备。设备文件（字符设备文件、块设备文件）对应的是硬件设备，在 Linux 系统中，硬件设备会对应到一个设备文件，应用程序通过对设备文件的读写来操控、使用硬件设备。</p><p>Linux 系统中，可将硬件设备分为字符设备和块设备，所以就有了字符设备文件和块设备文件两种文件类型。虽然有设备文件，但是设备文件并不对应磁盘上的一个文件，也就是说设备文件并不存在于磁盘中，而是由文件系统虚拟出来的，一般是由内存来维护，当系统关机时，设备文件都会消失；字符设备文件一般存放在 Linux 系统&#x2F;dev&#x2F;目录下。</p><p><strong>④符号链接文件</strong></p><p>符号链接文件（link）类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不是对它本身进行操作。</p><p><strong>⑤管道文件</strong></p><p>管道文件（pipe）主要用于进程间通信。</p><p><strong>⑥套接字文件</strong></p><p>套接字文件（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进程间通信，实际上就是网络通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stat</span> test_file<span class="comment">##可以查看文件属性</span></span></span><br></pre></td></tr></table></figure><p>这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息，函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p>函数参数及返回值含义如下：<br>pathname：用于指定一个需要查看属性的文件路径。<br>buf：struct stat 类型指针，用于指向一个 struct stat 结构体变量。调用 stat 函数的时候需要传入一个 struct<br>stat 变量的指针，获取到的文件属性信息就记录在 struct stat 结构体中，稍后给大家介绍 struct stat 结构体中有记录了哪些信息。<br>返回值：成功返回 0；失败返回-1，并设置 error。</p><h4 id="struct-stat-结构体"><a href="#struct-stat-结构体" class="headerlink" title="struct stat 结构体"></a>struct stat 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="st-mode变量"><a href="#st-mode变量" class="headerlink" title="st_mode变量"></a>st_mode变量</h4><p>st_mode 是 structstat 结构体中的一个成员变量，是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息。</p><p><a href="https://postimg.cc/9RGnLGT1"><img src="https://i.postimg.cc/qRYHMw7f/2022-11-15-203707.png" alt="2022-11-15-203707.png"></a></p><p><a href="https://i.postimg.cc/qRYHMw7f/2022-11-15-203707.png">https://i.postimg.cc/qRYHMw7f/2022-11-15-203707.png</a></p><p>这些 bit 位表达内容与 open 函数的 mode 参数相对应，这里不再重述。同样，在 mode 参数中表示权限的宏定义，在这里也是可以使用的，这些宏定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S_IRWXU 00700 owner has read, write, and execute permission</span><br><span class="line">S_IRUSR 00400 owner has read permission</span><br><span class="line">S_IWUSR 00200 owner has write permission</span><br><span class="line">S_IXUSR 00100 owner has execute permission</span><br><span class="line">S_IRWXG 00070 group has read, write, and execute permission</span><br><span class="line">S_IRGRP 00040 group has read permission</span><br><span class="line">S_IWGRP 00020 group has write permission</span><br><span class="line">S_IXGRP 00010 group has execute permission</span><br><span class="line">S_IRWXO 00007 others (not in group) have read, write, and execute permission</span><br><span class="line">S_IROTH 00004 others have read permission</span><br><span class="line">S_IWOTH 00002 others have write permission</span><br><span class="line">S_IXOTH 00001 others have execute permission</span><br><span class="line"></span><br><span class="line">S_IFSOCK 0140000 socket（套接字文件）</span><br><span class="line">S_IFLNK 0120000 symbolic link（链接文件）</span><br><span class="line">S_IFREG 0100000 regular file（普通文件）</span><br><span class="line">S_IFBLK 0060000 block device（块设备文件）</span><br><span class="line">S_IFDIR 0040000 directory（目录）</span><br><span class="line">S_IFCHR 0020000 character device（字符设备文件）</span><br><span class="line">S_IFIFO 0010000 FIFO（管道文件）</span><br><span class="line"></span><br><span class="line">S_ISREG(m) #判断是不是普通文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISDIR(m) #判断是不是目录，如果是返回 true，否则返回 false</span><br><span class="line">S_ISCHR(m) #判断是不是字符设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISBLK(m) #判断是不是块设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISFIFO(m) #判断是不是管道文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISLNK(m) #判断是不是链接文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISSOCK(m) #判断是不是套接字文件，如果是返回 true，否则返回 false</span><br></pre></td></tr></table></figure><h4 id="struct-timespec结构体"><a href="#struct-timespec结构体" class="headerlink" title="struct timespec结构体"></a>struct timespec结构体</h4><p>该结构体定义在头文件中，是 Linux 系统中时间相关的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">syscall_slong_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="fstat和lstat函数"><a href="#fstat和lstat函数" class="headerlink" title="fstat和lstat函数"></a>fstat和lstat函数</h4><p><strong>fstat函数</strong></p><p>fstat 与 stat 区别在于，stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><strong>lstat 函数</strong></p><p>lstat()与 stat、fstat 的区别在于，对于符号链接文件，stat、fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><h3 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h3><p>Linux 是一个多用户操作系统，系统中一般存在着好几个不同的用户，而 Linux 系统中的每一个文件都有一个与之相关联的用户和用户组，通过这个信息可以判断文件的所有者和所属组。</p><p>文件所有者表示该文件属于“谁”，也就是属于哪个用户。一般来说文件在创建时，其所有者就是创建该文件的那个用户。文件所属组则表示该文件属于哪一个用户组。在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。ID 就是一个编号，Linux 系统会为每一个用户或用户组分配一个 ID，将用户名或用户组名与对应的 ID 关联起来，所以系统通过用户 ID（UID）或组 ID（GID）就可以识别出不同的用户和用组。</p><p><a href="https://postimg.cc/ph8Fr0RY"><img src="https://i.postimg.cc/0QXdt343/2022-11-16-112952.png" alt="2022-11-16-112952.png"></a></p><p><a href="https://postimg.cc/ph8Fr0RY">与进程相关联的用户ID和组ID</a></p><h4 id="有效用户-ID-和有效组-ID"><a href="#有效用户-ID-和有效组-ID" class="headerlink" title="有效用户 ID 和有效组 ID"></a>有效用户 ID 和有效组 ID</h4><p>这是进程所持有的概念，对于文件来说，并无此属性！有效用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限。</p><p>当进行权限检查时，并不是通过进程的实际用户和实际组来参与权限检查的，而是通过有效用户和有效组来参与文件权限检查。</p><p><strong>chown函数</strong></p><p>chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID）。其实在Linux 系统下也有一个 chown 命令，该命令的作用也是用于改变文件的所有者和所属组，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root:root testApp.c<span class="comment">##该命令的作用也是用于改变文件的所有者和所属组</span></span></span><br></pre></td></tr></table></figure><h4 id="chown函数原型"><a href="#chown函数原型" class="headerlink" title="chown函数原型"></a>chown函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值如下所示：<br>pathname：用于指定一个需要修改所有者和所属组的文件路径。<br>owner：将文件的所有者修改为该参数指定的用户（以用户 ID 的形式描述）；<br>group：将文件的所属组修改为该参数指定的用户组（以用户组 ID 的形式描述）；<br>返回值：成功返回 0；失败将返回-1，兵并且会设置 errno。</p><p>有以下两个限制条件：</p><p>⚫ 只有超级用户进程能更改文件的用户 ID；<br>⚫ 普通用户进程可以将文件的组 ID 修改为其所从属的任意附属组 ID，前提条件是该进程的有效用户 ID 等于文件的用户 ID；而超级用户进程可以将文件的组 ID 修改为任意值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Linux 系统下，可以使用 getuid 和 getgid 两个系统调用分别用于获取当前进程的用户 ID 和用户组ID，这里说的进程的用户 ID 和用户组 ID 指的就是进程的实际用户 ID 和实际组 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;uid: %d\n&quot;</span>, getuid());</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><p>struct stat 结构体中的 st_mode 字段记录了文件的访问权限位。当提及到文件时，并不仅仅指的是普通文件；所有文件类型（目录、设备文件）都有访问权限（access permission）。</p><p>文件的权限可以分为两个大类，分别是<u>普通权限和特殊权限</u>（也可称为附加权限）。</p><p><a href="https://postimg.cc/2bbvGVCG"><img src="https://i.postimg.cc/76XVx2cF/2022-11-16-184604.png" alt="2022-11-16-184604.png"></a></p><p><a href="https://postimg.cc/2bbvGVCG">普通权限</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls-l##查看访问权限</span><br></pre></td></tr></table></figure><p><strong><u>-rwxrwxr-x</u></strong></p><p>-表示文件类型，前三位rwx为所有者权限，中间三位为同组用户权限，后三位为其它用户权限。</p><p>r表示具有读权限；w表示具有写权限；x表示具有执行权限；-表示没有权限</p><p><em><strong>当进程每次对文件进行读、写、执行等操作时，内核就会对文件进行访问权限检查，以确定该进程对文件是否拥有相应的权限。</strong></em>而对于进程来说，参与文件权限检查的是进程的有效用户、有效用户组以及进程的附属组用户。</p><p>如何判断权限，首先要搞清楚该进程对于需要进行操作的文件来说是属于哪一类“角色”：<br>⚫ 如果进程的有效用户 ID 等于文件所有者 ID（st_uid），意味着该进程以文件所有者的角色存在；<br>⚫ 如果进程的有效用户 ID 并不等于文件所有者 ID，意味着该进程并不是文件所有者身份；但是进程<br>的有效用户组 ID 或进程的附属组 ID 之一等于文件的组 ID（st_gid），那么意味着该进程以文件所<br>属组成员的角色存在，也就是文件所属组的同组用户成员。<br>⚫ 如果进程的有效用户 ID 不等于文件所有者 ID、并且进程的有效用户组 ID 或进程的所有附属组 ID<br>均不等于文件的组 ID（st_gid），那么意味着该进程以其它用户的角色存在。<br>⚫ 如果进程的有效用户 ID 等于 0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。</p><p><a href="https://postimg.cc/5X21Yr55"><img src="https://i.postimg.cc/mgQrqftn/2022-11-16-190427.png" alt="2022-11-16-190427.png"></a></p><p><a href="https://postimg.cc/5X21Yr55">特殊权限</a></p><p>宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_ISUID 04000 set-user-ID bit</span><br><span class="line">S_ISGID 02000 set-group-ID bit (see below)</span><br><span class="line">S_ISVTX 01000 sticky bit (see below)</span><br></pre></td></tr></table></figure><p>譬如通过 st_mode 变量判断文件是否设置了 set-user-ID 位权限，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st.st_mode &amp; S_ISUID) &#123;</span><br><span class="line"><span class="comment">//设置了 set-user-ID 位权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有设置 set-user-ID 位权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种权限位的具体作用：</p><p>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将<br>进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有者<br>的权限、以文件所有者的身份操作该文件。<br>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会<br>将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了<br>文件所属组成员的权限、以文件所属组成员的身份操作该文件。</p><h4 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h4><p>⚫ 目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。<br>⚫ 目录的写权限：可以在目录下创建文件、删除文件。<br>⚫ 目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。</p><p>要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限。反之，若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。</p><h4 id="检查文件权限"><a href="#检查文件权限" class="headerlink" title="检查文件权限"></a>检查文件权限</h4><p>文件的权限检查不只关于文件本身的权限，还需要涉及到文件所在目录的权限，只有同时都满足了，才能通过操作系统的权限检查，进而才可以对文件进行相关操作。可以通过access来检查执行进程的用户是否对该文件拥有应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>⚫ F_OK：检查文件是否存在<br>⚫ R_OK：检查是否拥有读权限<br>⚫ W_OK：检查是否拥有写权限<br>⚫ X_OK：检查是否拥有执行权限</p><p>返回值：检查项通过则返回 0，表示拥有相应的权限并且文件存在；否则返回-1，如果多个检查项组合在一起，只要其中任何一项不通过都会返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%: file does not exist.\n&quot;</span>, MY_FILE);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 检查权限 */</span></span><br><span class="line"> ret = access(MY_FILE, R_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, W_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, X_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: NO\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>在 Linux 系统下，可以使用 chmod 命令修改文件权限，该命令内部实现方法其实是调用了 chmod 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限修改的文件路径，若该参数所指为符号链接，实际改变权限的文件是符号链接所指向的文件，而不是符号链接文件本身。<br>mode：该参数用于描述文件权限，与 open 函数的第三个参数一样，这里不再重述，可以直接使用八进制数据来描述，也可以使用相应的权限宏（单个或通过位或运算符” | “组合）。<br>返回值：成功返回 0；失败返回-1，并设置 errno。</p><p>fchmod()与 chmod()的区别在于使用了文件描述符来代替文件路径，就像是 fstat 与 stat 的区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux标准IO库</title>
      <link href="/2022/11/12/Linux%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
      <url>/2022/11/12/Linux%E6%A0%87%E5%87%86IO%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓标准 I&#x2F;O 库则是标准 C 库中用于文件 I&#x2F;O 操作（譬如读文件、写文件等）相关的一系列库函数的集合，通常标准 I&#x2F;O 库函数相关的函数定义都在头文件中。</p><p><u>设计库函数是为了提供比底层系统调用更为方便、好用的调用接口，虽然标准 I&#x2F;O 构建于文件 I&#x2F;O 之上，但标准 I&#x2F;O 却有它自己的优势。</u></p><p>标准 I&#x2F;O 和文件 I&#x2F;O 的区别如下：</p><p>⚫ 虽然标准 I&#x2F;O 和文件 I&#x2F;O 都是 C 语言函数，但是标准 I&#x2F;O 是标准 C 库函数，而文件 I&#x2F;O 则是 Linux<br>系统调用；<br>⚫ 标准 I&#x2F;O 是由文件 I&#x2F;O 封装而来，标准 I&#x2F;O 内部实际上是调用文件 I&#x2F;O 来完成实际操作的；<br>⚫ 可移植性：标准 I&#x2F;O 相比于文件 I&#x2F;O 具有更好的可移植性。</p><p>⚫ 性能、效率：标准 I&#x2F;O 库在用户空间维护了自己的 stdio 缓冲区，所以标准 I&#x2F;O 是带有缓存的，而<br>文件 I&#x2F;O 在用户空间是不带有缓存的，所以在<em>性能、效率上，标准 I&#x2F;O 要优于文件 I&#x2F;O</em>。</p><h3 id="FILE-指针"><a href="#FILE-指针" class="headerlink" title="FILE 指针"></a>FILE 指针</h3><p>而对于标准 I&#x2F;O 库函数来说，它们的操作是围绕 FILE 指针进行的，当使用标准 I&#x2F;O 库函数打开或创建一个<br>文件时，会返回一个指向 FILE 类型对象的指针（FILE *），使用该 FILE 指针与被打开或创建的文件相关<br>联，然后该 FILE 指针就用于后续的标准 I&#x2F;O 操作（使用标准 I&#x2F;O 库函数进行 I&#x2F;O 操作），所以由此可知，<br>FILE 指针的作用相当于文件描述符，只不过 FILE 指针用于标准 I&#x2F;O 库函数中、而文件描述符则用于文件<br>I&#x2F;O 系统调用中。</p><p>FILE 是一个结构体数据类型，它包含了标准 I&#x2F;O 库函数为管理文件所需要的所有信息，包括用于实际<br>I&#x2F;O 的文件描述符、指向文件缓冲区的指针、缓冲区的长度、当前缓冲区中的字节数以及出错标志等。FILE<br>数据结构定义在标准 I&#x2F;O 库函数头文件 stdio.h 中。</p><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>所谓标准输入设备指的就是计算机系统的标准的输入设备，通常指的是计算机所连接的键盘；而标准输出设备指的是计算机系统中用于输出标准信息的设备，通常指的是计算机所连接的显示器；标准错误设备则指的是计算机系统中用于显示错误信息的设备，通常也指的是显示器设备。</p><p>用户通过标准输入设备与系统进行交互，进程将从标准输入（stdin）文件中得到输入数据，将正常输出<br>数据（譬如程序中 printf 打印输出的字符串）输出到标准输出（stdout）文件，而将错误信息（譬如函数调用报错打印的信息）输出到标准错误（stderr）文件。</p><h3 id="打开文件fopen"><a href="#打开文件fopen" class="headerlink" title="打开文件fopen()"></a>打开文件fopen()</h3><p>在标准 I&#x2F;O 中，我们将使用库函数fopen()打开或创建文件.函数原型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>path：参数 path 指向文件路径，可以是绝对路径、也可以是相对路径。<br>mode：参数 mode 指定了对该文件的读写权限，是一个字符串。<br>返回值：调用成功返回一个指向 FILE 类型对象的指针（FILE *），该指针与打开或创建的文件相关联，<br>后续的标准 I&#x2F;O 操作将围绕 FILE 指针进行。如果失败则返回 NULL，并设置 errno 以指示错误原因。</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件</td></tr><tr><td>r+</td><td>以可读、可写方式打开文件</td></tr><tr><td>w</td><td>以只写方式打开文件，如果参数path指定的文件存在，将文件长度截断为0，不存在则创建该文件</td></tr><tr><td>w+</td><td>以可读、可写方式打开文件，如果参数 path 指定的文件存在，将文件长度截断为 0；如果指定文件不存在则创建该文件。</td></tr><tr><td>a</td><td>以只写方式打开文件，打开以进行追加内容（在文件末尾写入），如果文件不存在则创建该文件。</td></tr><tr><td>a+</td><td>以可读、可写方式打开文件，以追加方式写入（在文件末尾写入），如果文件不存在则创建该文件。</td></tr></tbody></table><p>虽然调用 fopen()函数新建文件时无法手动指定文件的权限，但却有一个默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH (0666)</span><br></pre></td></tr></table></figure><h3 id="fclose-关闭文件"><a href="#fclose-关闭文件" class="headerlink" title="fclose()关闭文件"></a>fclose()关闭文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 为 FILE 类型指针，调用成功返回 0；失败将返回 EOF（也就是-1），并且会设置 errno 来<br>指示错误原因。</p><h3 id="读文件和写文件"><a href="#读文件和写文件" class="headerlink" title="读文件和写文件"></a>读文件和写文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>库函数 fread()用于读取文件数据，其参数和返回值含义如下：</p><p>ptr：fread()将读取到的数据存放在参数 ptr 指向的缓冲区中；<br>size：fread()从文件读取 nmemb 个数据项，每一个数据项的大小为 size 个字节，所以总共读取的数据大<br>小为 nmemb * size 个字节。<br>nmemb：参数 nmemb 指定了读取数据项的个数。<br>stream：FILE 指针。<br>返回值：调用成功时返回读取到的数据项的数目（数据项数目并不等于实际读取的字节数，除非参数<br>size 等于 1）；如果发生错误或到达文件末尾，则 fread()返回的值将小于参数 nmemb，那么到底发生了错误还是到达了文件末尾，fread()不能区分文件结尾和错误，究竟是哪一种情况，此时可以使用 ferror()或 feof()函数来判断。</p><p>库函数 fwrite()用于将数据写入到文件中，其参数和返回值含义如下：<br>ptr：将参数 ptr 指向的缓冲区中的数据写入到文件中。<br>size：参数 size 指定了每个数据项的字节大小，与 fread()函数的 size 参数意义相同。<br>nmemb：参数 nmemb 指定了写入的数据项个数，与 fread()函数的 nmemb 参数意义相同。<br>stream：FILE 指针。<br>返回值：调用成功时返回写入的数据项的数目（数据项数目并不等于实际写入的字节数，除非参数 size<br>等于 1）；如果发生错误，则 fwrite()返回的值将小于参数 nmemb（或者等于 0）。<br>由此可知，库函数 fread()、fwrite()中指定读取或写入数据大小的方式与系统调用 read()、write()不同，<br>前者通过 nmemb（数据项个数）*size（每个数据项的大小）的方式来指定数据大小，而后者则直接通过一个 size 参数指定数据大小。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[] = <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 写入数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(buf) &gt; fwrite(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf), fp)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fwrite error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">NULL</span> == (fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;r&quot;</span>))) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">12</span> &gt; (size = fread(buf, <span class="number">1</span>, <span class="number">12</span>, fp))) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ferror(fp)) &#123; <span class="comment">//使用 ferror 判断是否是发生错误</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fread error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 如果未发生错误则意味着已经到达了文件末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成功读取%d 个字节数据: %s\n&quot;</span>, size, buf);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fseek定位"><a href="#fseek定位" class="headerlink" title="fseek定位"></a>fseek定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针。<br>offset：与 lseek()函数的 offset 参数意义相同。<br>whence：与 lseek()函数的 whence 参数意义相同。<br>返回值：成功返回 0；发生错误将返回-1，并且会设置 errno 以指示错误原因；与 lseek()函数的返回值<br>意义不同，这里要注意！<br>调用库函数 fread()、fwrite()读写文件时，文件的读写位置偏移量会自动递增，使用 fseek()可手动设置<br>文件当前的读写位置偏移量。</p><p><u>将一个文件的打开写入文件数据，并进行读取要使用fseek来将读写位置移动到头部才能读取，否则fead</u></p><p><u>读取后面的空白信息，没有内容。</u></p><h3 id="ftell-函数"><a href="#ftell-函数" class="headerlink" title="ftell()函数"></a>ftell()函数</h3><p>用于获取文件当前的读写位置偏移量，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 指向对应的文件，函数调用成功将返回当前读写位置偏移量；调用失败将返回-1，并会设置<br>errno 以指示错误原因。</p><h3 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h3><p>库函数 feof()用于测试参数 stream 所指文件的 end-of-file 标志，如果 end-of-file 标志被设置了，则调用<br>feof()函数将返回一个非零值，如果 end-of-file 标志没有被设置，则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="ferror-函数"><a href="#ferror-函数" class="headerlink" title="ferror()函数"></a>ferror()函数</h3><p>库函数 ferror()用于测试参数 stream 所指文件的错误标志，如果错误标志被设置了，则调用 ferror()函数<br>将返回一个非零值，如果错误标志没有被设置，则返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h3><p>库函数 clearerr()用于清除 end-of-file 标志和错误标志，当调用 feof()或 ferror()校验这些标志后，通常需<br>要清除这些标志，避免下次校验时使用到的是上一次设置的值，此时可以手动调用 clearerr()函数清除标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h3><p>调用 write()后仅仅只是将这 5 个字节数据拷贝到了内核空间的缓冲区中，拷贝完成之后函数就返回了，在后面的某个时刻，内核会将其缓冲区中的数据写入（刷新）到磁盘设备中，所以由此可知，系统调用 write()与磁盘操作并不是同步的，write()函数并不会等待数据真正写入到磁盘之后再返回。如果在此期间，其它进程调用 read()函数读取该文件的这几个字节数据，那么内核将自动从缓冲区中读取这几个字节数据返回给应用程序。</p><p>这个内核缓冲区就称为文件 I&#x2F;O 的内核缓冲。这样的设计，目的是为了提高文件 I&#x2F;O 的速度和效率，使得系统调用 read()、write()的操作更为快速，不需要等待磁盘操作（将数据写入到磁盘或从磁盘读取出数据），磁盘操作通常是比较缓慢的。同时这一设计也更为高效，减少了内核操作磁盘的次数，譬如线程1 调用 write()向文件写入数据”abcd”，线程 2 也调用 write()向文件写入数据”1234”，这样的话，数据”abcd”和”1234”都被缓存在了内核的缓冲区中，在稍后内核会将它们一起写入到磁盘中，只发起一次磁盘操作请求；加入没有内核缓冲区，那么每一次调用 write()，内核就会执行一次磁盘操作。</p><h4 id="刷新文件-I-x2F-O-的内核缓冲区"><a href="#刷新文件-I-x2F-O-的内核缓冲区" class="headerlink" title="刷新文件 I&#x2F;O 的内核缓冲区"></a>刷新文件 I&#x2F;O 的内核缓冲区</h4><p>当我们在 Ubuntu 系统下拷贝文件到 U 盘时，文件拷贝完成之后，通常在拔掉 U 盘之前，需要执行 sync 命令进行同步操作，这个同步操作其实就是将文件 I&#x2F;O 内核缓冲区中的数据更新到 U 盘硬件设备，所以如果在没有执行 sync 命令时拔掉 U 盘，很可能就会导致拷贝到 U 盘中的文件遭到破坏！</p><h4 id="fsync-函数"><a href="#fsync-函数" class="headerlink" title="fsync()函数"></a>fsync()函数</h4><p>系统调用 fsync()将参数 fd 所指文件的内容数据和元数据写入磁盘，只有在对磁盘设备的写入操作完成之后，fsync()函数才会返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h4 id="fdatasync-函数"><a href="#fdatasync-函数" class="headerlink" title="fdatasync()函数"></a>fdatasync()函数</h4><p>系统调用 fdatasync()与 fsync()类似，不同之处在于 fdatasync()仅将参数 fd 所指文件的内容数据写入磁<br>盘。</p><h4 id="sync-函数"><a href="#sync-函数" class="headerlink" title="sync()函数"></a>sync()函数</h4><p>系统调用 sync()会将所有文件 I&#x2F;O 内核缓冲区中的文件内容数据和元数据全部更新到磁盘设备中。</p><h4 id="O-DSYNC-标志"><a href="#O-DSYNC-标志" class="headerlink" title="O_DSYNC 标志"></a>O_DSYNC 标志</h4><p>在调用 open()函数时，指定 O_DSYNC 标志，其效果类似于在每个 write()调用之后调用 fdatasync()函数<br>进行数据同步。</p><h4 id="O-SYNC-标志"><a href="#O-SYNC-标志" class="headerlink" title="O_SYNC 标志"></a>O_SYNC 标志</h4><p>在调用 open()函数时，指定 O_SYNC 标志，使得每个 write()调用都会自动将文件内容数据和元数据刷<br>新到磁盘设备中，其效果类似于在每个 write()调用之后调用 fsync()函数进行数据同步</p><h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>Linux 允许应用程序在执行文件 I&#x2F;O 操作时绕过内核缓冲区，从用户空间直接将数据传递到文件或磁盘设备，把这种操作也称为直接 I&#x2F;O（direct I&#x2F;O）或裸 I&#x2F;O（raw I&#x2F;O）。</p><p>因为直接 I&#x2F;O 涉及到对磁盘设备的直接访问，所以在执行直接 I&#x2F;O 时，必须要遵守以下三个对齐限制要<br>求：<br>⚫ 应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；<br>⚫ 写文件时，文件的位置偏移量必须是块大小的整数倍；<br>⚫ 写入到文件的数据大小必须是块大小的整数倍。</p><h4 id="stdio缓冲"><a href="#stdio缓冲" class="headerlink" title="stdio缓冲"></a>stdio缓冲</h4><p>标准 I&#x2F;O（fopen、fread、fwrite、fclose、fseek 等）是 C 语言标准库函数，而文件 I&#x2F;O（open、read、write、<br>close、lseek 等）是系统调用，虽然标准 I&#x2F;O 是在文件 I&#x2F;O 基础上进行封装而实现（譬如 fopen 内部实际上调<br>用了 open、fread 内部调用了 read 等），但在效率、性能上标准 I&#x2F;O 要优于文件 I&#x2F;O，其原因在于标准 I&#x2F;O 实<br>现维护了自己的缓冲区，把这个缓冲区称为 stdio 缓冲区。为了减少调用系统调用的次数，标准 I&#x2F;O 函数会将<br>用户写入或读取文件的数据缓存在 stdio 缓冲区，然后再一次性将 stdio 缓冲区中缓存的数据通过调用系统<br>调用 I&#x2F;O（文件 I&#x2F;O）写入到文件 I&#x2F;O 内核缓冲区或者拷贝到应用程序的 buf 中。</p><h5 id="stdio缓冲区的函数"><a href="#stdio缓冲区的函数" class="headerlink" title="stdio缓冲区的函数"></a>stdio缓冲区的函数</h5><h5 id="setvbuf-函数"><a href="#setvbuf-函数" class="headerlink" title="setvbuf()函数"></a>setvbuf()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针，用于指定对应的文件，每一个文件都可以设置它对应的 stdio 缓冲区。<br>buf：如果参数 buf 不为 NULL，那么 buf 指向 size 大小的内存区域将作为该文件的 stdio 缓冲区，因为stdio 库会使用 buf 指向的缓冲区，所以应该以动态（分配在堆内存）或静态的方式在堆中为该缓冲区分配一块空间，而不是分配在栈上的函数内的自动变量（局部变量）。如果 buf 等于 NULL，那么 stdio 库会自动分配一块空间作为该文件的 stdio 缓冲区（除非参数 mode 配置为非缓冲模式）。<br>mode：参数 mode 用于指定缓冲区的缓冲类型，可取值如下：<br>⚫ _IONBF：不对 I&#x2F;O 进行缓冲（无缓冲）。意味着每个标准 I&#x2F;O 函数将立即调用 write()或者 read()，并且忽略 buf 和 size 参数，可以分别指定两个参数为 NULL 和 0。标准错误 stderr 默认属于这一种类型，从而保证错误信息能够立即输出。<br>⚫ _IOLBF：采用行缓冲 I&#x2F;O。在这种情况下，当在输入或输出中遇到换行符”\n”时，标准 I&#x2F;O 才会执行文件 I&#x2F;O 操作。对于输出流，在输出一个换行符前将数据缓存（除非缓冲区已经被填满），当输出换行符时，再将这一行数据通过文件 I&#x2F;O write()函数刷入到内核缓冲区中；对于输入流，每次读取一行数据。对于终端设备默认采用的就是行缓冲模式，譬如标准输入和标准输出。<br>⚫ _IOFBF：采用全缓冲 I&#x2F;O。在这种情况下，在填满 stdio 缓冲区后才进行文件 I&#x2F;O 操作（read、write）。对于输出流，当 fwrite 写入文件的数据填满缓冲区时，才调用 write()将 stdio 缓冲区中的数据刷入内核缓冲区；对于输入流，每次读取 stdio 缓冲区大小个字节数据。默认普通磁盘上的常规文件默认常用这种缓冲模式。<br>size：指定缓冲区的大小。<br>返回值：成功返回 0，失败将返回一个非 0 值，并且会设置 errno 来指示错误原因。</p><h5 id="setbuffer-函数"><a href="#setbuffer-函数" class="headerlink" title="setbuffer()函数"></a>setbuffer()函数</h5><p>setbuffer函数类似setbuf（）但是允许调用者指定buf缓冲区的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><h5 id="刷新-stdio-缓冲区"><a href="#刷新-stdio-缓冲区" class="headerlink" title="刷新 stdio 缓冲区"></a>刷新 stdio 缓冲区</h5><p>无论我们采取何种缓冲模式，在任何时候都可以使用库函数 fflush()来强制刷新（将输出到 stdio 缓冲区中的数据写入到内核缓冲区，通过 write()函数）stdio 缓冲区，该函数会刷新指定文件的 stdio 输出缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> fflush(<span class="built_in">stdout</span>); <span class="comment">//刷新标准输出 stdio 缓冲区</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些其它的情况下，也会自动刷新 stdio 缓冲区，譬如当文件关闭时、程序退出时。</p><p><a href="https://postimg.cc/XZf8Kkwm"><img src="https://i.postimg.cc/zfMcrd3z/capture-20221114192535565.png" alt="capture-20221114192535565.png"></a></p><p><a href="https://postimg.cc/XZf8Kkwm">capture-20221114192535565.png</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux深入文件IO</title>
      <link href="/2022/11/10/Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/"/>
      <url>/2022/11/10/Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux管理文件"><a href="#Linux管理文件" class="headerlink" title="Linux管理文件"></a>Linux管理文件</h3><h4 id="静态文件与inode"><a href="#静态文件与inode" class="headerlink" title="静态文件与inode"></a>静态文件与inode</h4><p>文件存放在磁盘文件系统中，并且以一种固定的形式进行存放，称为静态文件。调用 open 函数的时候，会将文件数据（文件内容）从磁盘等块设备读取到内存中，将文件数据在内存中进行维护，内存中的这份文件数据我们就把它称为动态文件。</p><p>硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB），操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的4KB，即连续八个 sector 组成一个 block。</p><p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；<br>另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode。</p><p><a href="https://postimg.cc/JD4mjgVd"><img src="https://i.postimg.cc/DZ1Z3kCF/2022-11-10-142428.png" alt="2022-11-10-142428.png"></a></p><p>打开一个文件，系统内部会将这个过程分为三步：</p><ol><li>系统找到这个文件名所对应的 inode 编号；</li><li>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</li><li>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</li></ol><p>调用 open 函数去打开文件的时候，内核会申请一段内存（一段缓冲区），并且将静态文件的数据内容从磁盘这些存储设备中读取到内存中进行管理、缓存（也把内存中的这份文件数据叫做动态文件、内核缓冲区）。打开文件后，以后对这个文件的读写操作，都是针对内存中这一份动态文件进行相关的操作，而并不是针对磁盘中存放的静态文件。</p><p>因为磁盘、硬盘、U 盘等存储设备基本都是 Flash 块设备，因为块设备硬件本身有读写限制等特征，块设备是以一块一块为单位进行读写的（一个块包含多个扇区，而一个扇区包含多个字节），一个字节的改动也需要将该字节所在的 block 全部读取出来进行修改，修改完成之后再写入块设备中，所以导致对块设备的读写操作非常不灵活；而内存可以按字节为单位来操作，而且可以随机操作任意地址数据，非常地很灵活。</p><p>内核会为每个进程设置一个专门的数据结构用于管理该进程，譬如用于记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写PCB）。<br>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个元素索引到对应的文件表（File table），文件表也是一个数据结构体。</p><h4 id="返回错误处理与errno"><a href="#返回错误处理与errno" class="headerlink" title="返回错误处理与errno"></a>返回错误处理与errno</h4><p>在 Linux 系统下对常见的错误做了一个编号，每一个编号都代表着每一种不同的错误类型，当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程（程序）都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储就近发生的函数执行错误编号，也就意味着下一次的错误码会覆盖上一次的错误码。</p><p>errno 本质上是一个 int 类型的变量，用于存储错误编号，但是需要注意的是，并不是执行所有的系统调用或 C 库函数出错时，操作系统都会设置 errno。</p><h5 id="常用的函数perror函数"><a href="#常用的函数perror函数" class="headerlink" title="常用的函数perror函数"></a>常用的函数perror函数</h5><p>一般用的最多的还是这个函数，调用此函数不需要传入 errno，函数内部会自己去获取 errno 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>s：在错误提示字符串信息之前，可加入自己的打印信息，也可不加，不加则传入空字符串即可。<br>返回值：void 无返回值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exit、-exit、-Exit"><a href="#exit、-exit、-Exit" class="headerlink" title="exit、__exit、_Exit"></a>exit、__exit、_Exit</h4><p>在 Linux 系统下，进程（程序）退出可以分为正常退出和异常退出，注意这里说的异常并不是执行函数出现了错误这种情况，异常往往更多的是一种不可预料的系统异常，可能是执行了某个函数时发生的、也有可能是收到了某种信号等.</p><p>main 函数中使用 return 后返回，return 执行后把控制权交给调用函数，结束该进程。调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统。exit()是一个标准 C 库函数，而_exit()和_Exit()是系统调用。</p><p>__exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>_Exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>exit()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><h4 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h4><p>使用 write()函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个空洞，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为空洞文件。<br>文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它<br>分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的</p><p><u>空洞文件对多线程共同操作文件是及其有用的</u>，有时候我们创建一个很大的文件，如果单个线程从头开始依次构建该文件需要很长的时间，有一种思路就是将文件分为多段，然后使用多线程来操作，每个线程负责其中一段数据的写入。</p><p>eg：新建一个空洞文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./hole_file&quot;</span>, O_WRONLY | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将文件读写位置移动到偏移文件头 4096 个字节(4K)处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">4096</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 为 0xFF */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 循环写入 4 次，每次写入 1K */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例代码中，使用 open 函数新建了一个文件 hole_file，在 Linux 系统中，新建文件大小是 0，也就<br>是没有任何数据写入，此时使用lseek函数将读写偏移量移动到4K字节处，再使用write函数写入数据0xFF，每次写入 1K，一共写入 4 次，也就是写入了 4K 数据，也就意味着该文件前 4K 是文件空洞部分，而后 4K数据才是真正写入的数据。</p><h4 id="O-APPEND-和-O-TRUNC-标志"><a href="#O-APPEND-和-O-TRUNC-标志" class="headerlink" title="O_APPEND 和 O_TRUNC 标志"></a>O_APPEND 和 O_TRUNC 标志</h4><p>O_TRUNC 这个标志的作用是调用 open 函数打开文件的时候会将文件原本的内容全部丢弃，文件大小变为 0。</p><p><u><strong>O_APPEND</strong></u>标志作用open函数携带了O_APPEND，调用 open 函数打开文件，当每次使用 write()函数对文件进行写操作时，都会自动把文件当前位置偏移量移动到文件末尾，从文件末尾开始写入数据，也就是意味着每次写入数据都是从文件末尾开始。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 中的数据 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x55</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 写入数据: 写入 4 个字节数据 */</span></span><br><span class="line"> ret = write(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将 buffer 缓冲区中的数据全部清 0 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 将位置偏移量移动到距离文件末尾 4 个字节处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">-4</span>, SEEK_END);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line">    ret = read(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x 0x%x 0x%x\n&quot;</span>, buffer[<span class="number">0</span>], buffer[<span class="number">1</span>],</span><br><span class="line"> buffer[<span class="number">2</span>], buffer[<span class="number">3</span>]);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用O_APPEND多次打开同一个文件测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL | O_APPEND,</span><br><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd1) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 再次打开 test_file 文件 */</span></span><br><span class="line"> fd2 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h4><p>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具有读写权限。</p><p>dup函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>返回值：成功时将返回一个新的文件描述符，由操作系统分配，分配置原则遵循文件描述符分配原则；<br>如果复制失败将返回-1，并且会设置 errno 值</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup(fd1);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件<br>描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，可以手动指定文件描述符，而不需要遵循文件描述符分配原则。dup2函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>newfd：指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>返回值：成功时将返回一个新的文件描述符，也就是手动指定的文件描述符 newfd；如果复制失败将返回-1，并且会设置 errno 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup2(fd1, <span class="number">100</span>);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被多个独立的读写体同时进行 IO 操作。同时进行 IO 操作指的是一个读写体操作文件尚未调用 close 关闭的情况下，另一个读写体去操作文件。</p><p>文件共享的意义有很多，多用于多进程或多线程编程环境中，譬如我们可以通过文件共享的方式来实现<br>多个线程同时操作同一个大文件，以减少文件读写时间、提升效率。<br><strong><u>文件共享的核心</strong></u>是：如何制造出多个不同的文件描述符来指向同一个文件。其实方法在上面的内容中都已经给大家介绍过了，譬如多次调用 open 函数重复打开同一个文件得到多个不同的文件描述符、使用 dup()或 dup2()函数对文件描述符进行复制以得到多个不同的文件描述符。</p><p><strong>常见三种文件共享实现方式</strong></p><p>(1)同一个进程中多次调用 open 函数打开同一个文件</p><p>(2)不同进程中分别使用 open 函数打开同一个文件</p><p>(3)同一个进程中通过 dup（dup2）函数对文件描述符进行复制</p><h4 id="原子操作和竞争冒险"><a href="#原子操作和竞争冒险" class="headerlink" title="原子操作和竞争冒险"></a>原子操作和竞争冒险</h4><p>[原子操作和竞争冒险]: <a href="https://copyfuture.com/blogs-details/202208241006207606">https://copyfuture.com/blogs-details/202208241006207606</a>“竞争冒险”</p><h4 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h4><p>truncate()或ftruncate()可将普通文件截断为指定字节长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数都可以对文件进行截断操作，将文件截断为参数 length 指定的字节长度，什么是截断？如<br>果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉<br>了；如果文件目前的大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字节”\0”。</p><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必<br>须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 打开 file1 文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; (fd = open(<span class="string">&quot;./file1&quot;</span>, O_RDWR))) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 ftruncate 将 file1 文件截断为长度 0 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ftruncate(fd, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;ftruncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 truncate 将 file2 文件截断为长度 1024 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; truncate(<span class="string">&quot;./file2&quot;</span>, <span class="number">1024</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;truncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 关闭 file1 退出程序 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——文件IO操作</title>
      <link href="/2022/11/08/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/08/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="文件IO基础"><a href="#文件IO基础" class="headerlink" title="文件IO基础"></a>文件IO基础</h3><p>文件IO是指对文件的输入输出操作。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>调用函数会有返回值，该返回值为一个文件描述符，对于Linux内核而言，所有打开文件都会通过文件描述符进行索引。</p><p>当调用open函数打开或者创建一个新文件，内核会向进程返回一个文件描述符，用于指带被打开的文件，所有执行 IO 操作的系统调用都是通过文件描述符来索引到对应的文件。一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，并不是可以无限制打开很多的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -n<span class="comment">##查看进程打开文件的最大数量</span></span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure><p>每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被释放，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来。</p><p>每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（0~1023）开始，当之前打开的文件被关闭之后，那么它对应的文件描述符会被释放，释放之后也就成为了一个没有被使用的文件描述符了。</p><p>但是 0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标准输入（0）、标准输出（1）以及标准错误（2）。</p><h4 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open 函数用于打开文件，当然除了打开已经存在的文件之外，还可以创建一个新的文件。</p><p>在应用程序中调用 open 函数即可传入 2 个参数（pathname、flags）、也可传入 3 个参数（pathname、flags、mode），但是第三个参数 mode 需要在第二个参数 flags 满足条件时才会有效，稍后将对此进行说明；从图 2.3.1 可知，在应用程序中使用 open 函数时，需要包含 3 个头文件“#include<br>”、“#include ”、“#include ”。</p><p>函数参数和返回值定义</p><p>pathname：字符串类型，用于标识需要打开或创建的文件，可以包含路径（绝对路径或者相对路径）信息。</p><p>flags：调用open函数时需要提供的标志，包括文件访问模式标志以及其它文件相关标志，这些标志使用宏定义进行描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./app.c&quot;</span>, O_RDWR)<span class="comment">//打开一个已经存在的文件，使用可读可写的方式打开</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line"><span class="keyword">return</span> fd;</span><br></pre></td></tr></table></figure><h4 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数返回值含义如下：</p><p>fd：文件描述符。将进行写操作的文件所对应的文件描述符传递给 write 函数。<br>buf：指定写入数据对应的缓冲区。<br>count：指定写入的字节数。<br>返回值：如果成功将返回写入的字节数（0 表示未写入任何字节），如果此数字小于 count 参数，这不是错误，譬如磁盘空间已满，可能会发生这种情况；如果写入出错，则返回-1。</p><h4 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>fd：文件描述符。与 write 函数的 fd 参数意义相同。</p><p>buf：指定用于存储读取数据的缓冲区。</p><p>count：指定需要读取的字节数。</p><p>返回值：如果读取成功将返回读取到的字节数，实际读取到的字节数可能会小于 count 参数指定的字节<br>数，也有可能会为 0，譬如进行读操作时，当前文件位置偏移量已经到了文件末尾。实际读取到的字节数少<br>于要求读取的字节数，譬如在到达文件末尾之前有 30 个字节数据，而要求读取 100 个字节，则 read 读取成<br>功只能返回 30；而下一次再调用 read 读，它将返回 0（文件末尾）。</p><h4 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符，需要关闭的文件所对应的文件描述符。<br>返回值：如果成功返回 0，如果失败则返回-1。</p><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>对于每个打开的文件，系统都会记录它的读写位置偏移量，我们也把这个读写位置偏移量称为读写偏移<br>量，记录了文件当前的读写位置，当调用 read()或 write()函数对文件进行读写操作时，就会从当前读写位置<br>偏移量开始进行数据读写。</p><p>读写偏移量用于指示 read()或 write()函数操作时文件的起始位置，会以相对于文件头部的位置偏移量来<br>表示，文件第一个字节数据的位置偏移量为 0。</p><p>函数参数和返回值含义如下：<br>fd：文件描述符。<br>offset：偏移量，以字节为单位。<br>whence：用于定义参数 offset 偏移量对应的参考值，该参数为下列其中一种（宏定义）：</p><p>SEEK_SET：读写偏移量将指向 offset 字节位置处（从文件头部开始算）</p><p>SEEK_CUR：读写偏移量将指向当前位置偏移量 + offset 字节位置处，offset 可以为正、也可以为负，如果是正数表示往后偏移，如果是负数则表示往前偏移；</p><p>SEEK_END：读写偏移量将指向文件末尾 + offset 字节位置处，同样 offset 可以为正、也可以为负，如果是正数表示往后偏移、如果是负数则表示往前偏移。</p><p>eg：<br>(1)将读写位置移动到文件开头处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(2)将读写位置移动到文件末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(3)将读写位置移动到偏移文件开头 100 个字节处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">100</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(4)获取当前读写位置偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>函数执行成功将返回文件当前读写位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——Shell脚本学习</title>
      <link href="/2022/10/23/Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/23/Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><p>Shell通常指的是命令行界面的解析器,也用于泛指所有为用户提供操作界面的程序，也就是程序和用户<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&action=edit&redlink=1">交互</a>的层面。</p><p>Shell 执行shell程序，这些程序叫脚本。</p><p>创建脚本使用文本编辑器来创建包含指令的文件，这里使用vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim bash.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash<span class="comment">##创建脚本文件时候必须在文件第一行指明要用到的shell</span></span></span><br><span class="line">for file in *#以#开头的行不会被shell处理</span><br><span class="line">do </span><br><span class="line">  if grep -q POSIX $file</span><br><span class="line">  then</span><br><span class="line">    echo $file</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>把脚本设置为可执行，</p><p>1、</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/bash bash.sh</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x bash.sh<span class="comment">##改变文件权限，使这个文件可以被所有用户执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bash.sh</span></span><br></pre></td></tr></table></figure><h3 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>所有变量都被看作字符串并以字符串来存储.</p><p> 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：（变量名称使用小写英文命名，因为系统中的全局变量是大写命名的，为防止重复定义就用小写）</p><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线 _。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p><p>在shell中，可以通过在变量名前加上$符号来访问它的内容， 一种检查变量内容的简单方式就是变量前加上$再用echo命令将它的内容输出到终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> salutation=Hello</span><br><span class="line"> echo $salutation</span><br><span class="line"> echo salutation</span><br><span class="line">Hello</span><br><span class="line">salutation</span><br></pre></td></tr></table></figure><p>read可以给变量复制相当于C语言的input</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> read salutation</span><br><span class="line"> echo $ salutation</span><br><span class="line">sa</span><br><span class="line">sa</span><br></pre></td></tr></table></figure><p>要想输出空格需要用双引号给引用出来，要想显示双引号可，以用单引号来显示出来，在显示信息中想要有美元符号，必须在前面加上\</p><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。</p><p>可以通过&#96;反引号来将命令输出赋值给变量或者$()</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = `<span class="built_in">date</span>`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = $(<span class="built_in">date</span>)</span></span><br></pre></td></tr></table></figure><p>使用 unset 命令可以删除变量。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h4 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h4><p>bash支持一维数组，并且没有限制大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)#例如这样array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;数组名[下标]&#125;<span class="comment">#例如echo $&#123;array_name[@]&#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><p>bash shell脚本不支持浮点型运算，只支持整数运算，如果想要计算可用bash的计算器bc</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if -else"></a>if -else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif (( $a &gt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif (( $a &lt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p><p>顺序输出当前列表中的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h4><p>until 循环执行一系列命令直至条件为 true 时停止。condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="case…-esac"><a href="#case…-esac" class="headerlink" title="case… esac"></a>case… esac</h4><p>case … esac 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><u><strong>和C语言一样break用来跳出所有循环，continue是用来跳出当前循环。</strong></u></p><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于等于则为真</td></tr><tr><td>-ge</td><td>小于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e文件名</td><td>如果文件存在则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &#x27;文件已存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;文件不存在!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure><p>传参</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数处理</th><th>说明</th></tr></thead><tbody><tr><td align="left">$#</td><td>传递到脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td align="left">$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr><tr><td align="left">@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td align="left">$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习过程中的问题</title>
      <link href="/2022/10/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-scanf输入问题-输入缓冲区"><a href="#1-scanf输入问题-输入缓冲区" class="headerlink" title="1.scanf输入问题-输入缓冲区"></a>1.scanf输入问题-输入缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(b == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会得到</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line">a<span class="comment">//输入a</span></span><br><span class="line"><span class="number">0</span>?a1?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是因为scanf()函数会把回车、空格、Tab或一些不合理输入的字符当作此次输入的结束标志，它不会把这些字符输入到想要保存此次输入数据的变量中，而是把这些字符遗留在了输入缓冲区，那么，当下一次想要从标准输入中读取一个字符时，这个遗留的字符就正好充当了此次的输入字符。</p><p>程序在输入a后输入了回车来结束此次输入，那么回车就遗留在了输入缓冲区，当需要给c输入字符时，它自动的充当了输入的字符，因此，程序没有给我们输入c的字符的机会。</p><p>C语言为了解决这种问题，为我们提供了一种很方便的清空输入缓冲区的方式—-&gt;&gt;fflush()函数，fflush(stdin)它会把残留在输入缓冲区里的所有数据清空。头文件为stdio.h</p><p>或者使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过该行剩下的内容。</span></span><br></pre></td></tr></table></figure><h3 id="错题：位运算"><a href="#错题：位运算" class="headerlink" title="错题：位运算"></a>错题：位运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fun(<span class="number">2017</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">i = i&amp;(i<span class="number">-1</span>);<span class="comment">//i = i &amp; (i-1)，统计i二进制中有多少个1</span></span><br><span class="line">&#125;               <span class="comment">//i = i | (i+1)，统计i二进制中有多少个0</span></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str[<span class="number">3</span>] =&#123;<span class="string">&quot;stra&quot;</span>, <span class="string">&quot;strb&quot;</span>, <span class="string">&quot;strc&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p =str[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,p++);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">指针数组</a>可以指向多个字符，直到遇到空为止。p本来指向第一个字符，但是因为是指针，所以要遇到空为止才算读完第一个‘字符’，后面p+1指向第二个字符，同样也是遇到空为止，同理p+2 所以输出为stra，tra，ra。注意循环里面是p++所以从p0开始打印啦。</p><h3 id="指针和自增自减的优先级"><a href="#指针和自增自减的优先级" class="headerlink" title="指针和自增自减的优先级"></a>指针和自增自减的优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3668</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ );<span class="comment">//拿到arr[0]的值1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ ); <span class="comment">//上条语句结束后指针往后移动了一下，</span></span><br><span class="line"><span class="comment">//指到到arr[1]，然后又++，因为是后++，</span></span><br><span class="line"><span class="comment">//所以解得是arr[1]的值3668</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//拿到上个++指向了arr[2],</span></span><br><span class="line"><span class="comment">//因为加了括号，所以先解值为5，然后++，</span></span><br><span class="line"><span class="comment">//把结果丢给了下语句。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//括号优先级高，先解值，指针未移动，</span></span><br><span class="line"><span class="comment">//还指向着arr[2],拿到上个printf丢下来的值5+1=6，</span></span><br><span class="line"><span class="comment">//故解值为6，然6++,语句执行结束把6++结果丢给下一条语句。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。</p><h3 id="extern”C”-作用"><a href="#extern”C”-作用" class="headerlink" title="extern”C” 作用"></a>extern”C” 作用</h3><p>C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//把所有函数声明放在这。</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言算法项</title>
      <link href="/2022/10/20/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/"/>
      <url>/2022/10/20/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正三角-反三角"><a href="#正三角-反三角" class="headerlink" title="正三角(反三角)"></a>正三角(反三角)</h3><p>使用为两个for循环进行嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">6</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;a;b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><p>使用为四个for进行循环思想核心为中间数量为行数n的两倍减去1，外层循环控制换行，内层三个控制空格以及他的打印数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rows,i,j,space,star;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; rows);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         star = <span class="number">2</span>*i <span class="number">-1</span> ;     <span class="comment">//星号个数</span></span><br><span class="line">         space = rows - i;   <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//左边空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;star;++j)       <span class="comment">//中间 *</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//右边空格有没有都可以</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, space, rows, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter number of rows: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rows);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=rows; ++i, k=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(space=<span class="number">1</span>; space&lt;=rows-i; ++space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断一个数字是否素数</p><p>判断一个数字是否能被比他小的数整除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;x;i++)</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//一旦判断不是，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==x) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);<span class="comment">//如果是的话，for循环一定执行到了i=x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C语言二分查找"><a href="#C语言二分查找" class="headerlink" title="C语言二分查找"></a>C语言二分查找</h3><p>找到最左边元素（low）和最右边元素（high），确定中间元素（mid），比较中间元素（mid）和目标元素（k）的大小，调整low和high，再确定新的mid….我们要不断确定mid直到找到k，自然需要用到循环，我们有明确的目标：找到k。因此选择while循环，找到k后循环不再进行，而当low和high之间还有元素，即low在high的左边或与之重合，k就依然可能存在，所以循环条件为low&lt;&#x3D;high，接下来的问题在于怎样调整low和high的值，mid和k比较无非就三种情况：mid&lt;k，mid&gt;k,mid&#x3D;k。第一种情况，k在mid的右边，我们将low调整为mid+1，high不用调整；第二种情况，k在mid的左边，我们将high调整为mid-1，low不用调整。最后一种情况最简单，我们已经找到了k，直接将mid打印出来就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bin_Search</span><span class="params">(<span class="type">int</span> *num,<span class="type">int</span> cnt,<span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first = <span class="number">0</span>,last = cnt<span class="number">-1</span>,mid;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first &lt;= last)</span><br><span class="line">&#123;</span><br><span class="line">counter ++;</span><br><span class="line">mid = (first + last) / <span class="number">2</span>;<span class="comment">//确定中间元素</span></span><br><span class="line"><span class="keyword">if</span>(num[mid] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">last = mid<span class="number">-1</span>; <span class="comment">//mid已经交换过了,last往前移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">first = mid+<span class="number">1</span>;<span class="comment">//mid已经交换过了,first往后移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//判断是否相等</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>,target;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您要查找的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;target);</span><br><span class="line">flag = Bin_Search(num,<span class="number">10</span>,target);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;已经找到该数字!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无该数字!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找数组最大值"><a href="#查找数组最大值" class="headerlink" title="查找数组最大值"></a>查找数组最大值</h3><h4 id="循环对比"><a href="#循环对比" class="headerlink" title="循环对比"></a>循环对比</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findMaxValue(arr) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123; <span class="comment">// 当前值大于最大值，赋值为最大值</span></span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串排列顺序"><a href="#字符串排列顺序" class="headerlink" title="字符串排列顺序"></a>字符串排列顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALT <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> *strings [], <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> input[LIM][SIZE];</span><br><span class="line"><span class="type">char</span> *ptstr[LIM];</span><br><span class="line"><span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input up to %d lines, and I will sort them.\n&quot;</span>, LIM);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To stop ,press the Enter key at a line&#x27;s start.\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(ct &lt; LIM &amp;&amp; s_gets(input[ct], SIZE) != <span class="literal">NULL</span> &amp;&amp; input[ct][<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptstr[ct] = input[ct];</span><br><span class="line">ct ++;</span><br><span class="line">&#125;</span><br><span class="line">stsrt(ptstr, ct);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nHere&#x27;s the sorted list:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; ct; k++)</span><br><span class="line"><span class="built_in">puts</span>(ptstr[k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> * strings[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * temp;</span><br><span class="line"><span class="type">int</span> top, seek;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(top = <span class="number">0</span>; top &lt; num - <span class="number">1</span>; top++)</span><br><span class="line"><span class="keyword">for</span>(seek = top + <span class="number">1</span>; seek &lt; num; seek++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(strings[top], strings[seek]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = strings[top];</span><br><span class="line">strings[top] = strings[seek];</span><br><span class="line">strings[seek] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st , n , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工具vim</title>
      <link href="/2022/10/20/Linux%E5%B7%A5%E5%85%B7vim/"/>
      <url>/2022/10/20/Linux%E5%B7%A5%E5%85%B7vim/</url>
      
        <content type="html"><![CDATA[<p>vi编辑器是所有Unix及<a href="http://www.2cto.com/os/linux/">Linux</a>系统下标准的编辑器，他就相当于<a href="http://www.2cto.com/os/windows/">windows</a>系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。<a href="https://so.csdn.net/so/search?q=vim&spm=1001.2101.3001.7020">vim</a> 具有程序编辑的能力，可以以字体颜色辨别语法的正确性。</p><p>vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式</p><p>一般模式：<br>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。</p><p>编辑模式：<br>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】即可退出编辑模式。</p><p>命令行模式：<br>输入【 : &#x2F; ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！</p><p>针对程序员配置</p><p>打开高亮功能，vim会通过文件的扩展名自动决定哪些是关键字。</p><p>：syntax on</p><p>自动缩进</p><p>：set autoindent</p><p>设置tab键的空格数</p><p>：set shiftwidth&#x3D;4</p><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350e68d43867.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350e68d43867.png" alt="屏幕截图 2022-10-20 140924.png"></a></p><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350e69008761.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350e69008761.png" alt="屏幕截图 2022-10-20 141012.png"></a></p><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350e6922e931.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350e6922e931.png" alt="屏幕截图 2022-10-20 141028.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——进程管理</title>
      <link href="/2022/10/20/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/20/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>进程</p><p><u>进程是用来表示正在进行的程序。</u></p><p>内核中一些重要的进程信息如下：</p><p>进程的内存地址；</p><p>进程当前的状态；</p><p>进程正在使用的资源；</p><p>进程的优先级；</p><p>进程的属组；</p><p><strong>PID</strong>：进程的ID号</p><p><strong>PPID</strong>：父进程的PID</p><p>所有的进程都必须由另一个进程创建——除了系统在系统引导时，由内核自主创建并安装的进程。当一个进程被创建时，创建他的那个进程称为父进程。这个进程叫做子进程；PPID就是父进程的PID。</p><p>只有进程的创建者和root用户才有权对该进程进行操作，记录进程的创建者（属组）就必要了，进程的<strong>UID</strong>就是创建者的ID。</p><p>Linux为进程保存了有效用户ID号叫<strong>EUID</strong>，用来确定进程对某些资源和文件的访问权限。绝大部分情况，UID和EUID一样，除了seruid程序。</p><p>进程的<strong>GID</strong>是创建者所属组的ID号，进程同样有一个<strong>EGID</strong>号，当进程需要创建一个新文件时候，这个文件将采用该进程的GID。</p><h4 id="监视进程：PS命令"><a href="#监视进程：PS命令" class="headerlink" title="监视进程：PS命令"></a>监视进程：PS命令</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png" alt="屏幕截图 2022-10-20 123723.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">$ ps lax##可以提供父进程ID（PPID）和谦让度（IN）</span><br></pre></td></tr></table></figure><h4 id="即时跟踪进程信息"><a href="#即时跟踪进程信息" class="headerlink" title="即时跟踪进程信息"></a>即时跟踪进程信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top##实时检测10更新一回q退出</span><br></pre></td></tr></table></figure><h4 id="查看占用文件的进程"><a href="#查看占用文件的进程" class="headerlink" title="查看占用文件的进程"></a>查看占用文件的进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof database.doc##查找文件的进程</span><br></pre></td></tr></table></figure><h4 id="向进程发送信号：kill"><a href="#向进程发送信号：kill" class="headerlink" title="向进程发送信号：kill"></a>向进程发送信号：kill</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png" alt="屏幕截图 2022-10-20 125610.png"></a></p><h4 id="调整进程的谦让度（优先级的反义）nice和renice"><a href="#调整进程的谦让度（优先级的反义）nice和renice" class="headerlink" title="调整进程的谦让度（优先级的反义）nice和renice"></a>调整进程的谦让度（优先级的反义）nice和renice</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png" alt="屏幕截图 2022-10-20 131600.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——用户管理</title>
      <link href="/2022/10/19/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/19/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="添加新用户并建立主目录"><a href="#添加新用户并建立主目录" class="headerlink" title="添加新用户并建立主目录"></a>添加新用户并建立主目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesradd -m john##添加用户叫john并建立主目录</span><br><span class="line">$ sudo passwd john##更改john的密码</span><br></pre></td></tr></table></figure><h4 id="添加用户命令行工具"><a href="#添加用户命令行工具" class="headerlink" title="添加用户命令行工具"></a>添加用户命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd john##添加用户john</span><br><span class="line">$ passwd john##john设置密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -g users john##创立john并指定属于users组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /bin/bash mike##建立mike用户并指定登陆后使用bash作为Shell</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd newgroup##在系统中太内疚newgroup的组</span><br></pre></td></tr></table></figure><h4 id="记录用户操作"><a href="#记录用户操作" class="headerlink" title="记录用户操作"></a>记录用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br><span class="line">$ history 10##记录了最近用的10条指令</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesrdel mike##删除用户mike</span><br><span class="line">$ sudo userdel -r john##删除john删除其主目录</span><br></pre></td></tr></table></figure><h4 id="管理用户账号"><a href="#管理用户账号" class="headerlink" title="管理用户账号"></a>管理用户账号</h4><p><a href="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png"><img src="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png" alt="屏幕截图 2022-10-19 211029.png"></a></p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id hanfeng##查看用户的UID、GID及所属组的信息</span><br></pre></td></tr></table></figure><h4 id="用户转换"><a href="#用户转换" class="headerlink" title="用户转换"></a>用户转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su john##进入john用户</span><br><span class="line">$ exit##回到之前的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-压缩与解压缩</title>
      <link href="/2022/10/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/10/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="gzip压缩工具"><a href="#gzip压缩工具" class="headerlink" title="gzip压缩工具"></a>gzip压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gzip gztest##压缩gztest</span><br><span class="line">$ gzip -d gztest##解压缩gztest</span><br><span class="line">$ gzip -r gztest##对文件夹压缩</span><br><span class="line">$ gzip -rd gztest.gz##对文件夹解压缩</span><br></pre></td></tr></table></figure><p>gzip 虽然对文件夹进行压缩，但是不能提供打包服务，只对文件夹<strong>内部的文件进行单独压缩。</strong></p><h4 id="bzip2压缩工具"><a href="#bzip2压缩工具" class="headerlink" title="bzip2压缩工具"></a>bzip2压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -z a.c##压缩</span><br><span class="line">$ bzip2 -d a.c.bz2##解压缩</span><br></pre></td></tr></table></figure><h4 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h4><p>tar工具提供打包服务，就是将多个文件打包。常用参数-f归档 ,-c创建新归档创建压缩文件，-x：从文档中解压缩</p><p>-j：使用bzip2压缩格式，-z 使用gzip压缩格式 -v 打印命令执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -vxjf xxx.tar.bz2##解压缩</span><br><span class="line">$ tar -vcjf xxx.tar.bz2 xxx ##压缩</span><br><span class="line">$ tar -vxzfxxx.tar.gz##解压缩</span><br><span class="line">$ tar -vczf xxx.tar.gz xxx ##压缩</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-软件包管理</title>
      <link href="/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="管理-deb软件包"><a href="#管理-deb软件包" class="headerlink" title="管理.deb软件包"></a>管理.deb软件包</h4><h6 id="查看已安装的软件包"><a href="#查看已安装的软件包" class="headerlink" title="查看已安装的软件包"></a>查看已安装的软件包</h6><p> OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -l | grep openssh##查找openssh的版本信息</span><br><span class="line">$ dekg -s openssh##查看哪些文件是openssh带来的</span><br></pre></td></tr></table></figure><h6 id="安装卸载软件包"><a href="#安装卸载软件包" class="headerlink" title="安装卸载软件包"></a>安装卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo dpkg -i xxx.deb##安装xxx</span><br><span class="line"></span><br><span class="line">$sudo dpkg --remove opera##删除opera浏览器</span><br></pre></td></tr></table></figure><h4 id="管理RPM软件包"><a href="#管理RPM软件包" class="headerlink" title="管理RPM软件包"></a>管理RPM软件包</h4><h6 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -i -v -h dump-0.4b41-1.src.rpm##-i是安装命令-v显示正在执行工作-h打印提醒进度</span><br></pre></td></tr></table></figure><p>升级安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh dump-0.4b41-1.src.rpm</span><br></pre></td></tr></table></figure><p>查看已经安装的软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -q check##rpm -q命令可以查询已经安装的软件包是安装包文件的名字，不是文件的名字</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png" alt="屏幕截图 2022-10-16 144841.png"></a></p><h6 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -e tcpdump##卸载tcpdump软件包</span><br></pre></td></tr></table></figure><h4 id="高级软件包工具APT"><a href="#高级软件包工具APT" class="headerlink" title="高级软件包工具APT"></a>高级软件包工具APT</h4><h6 id="下载和安装软件包"><a href="#下载和安装软件包" class="headerlink" title="下载和安装软件包"></a>下载和安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update##更新软件包</span><br><span class="line">$ sduo apt-get install wesnoth##下载安装wesnoth</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png" alt="屏幕截图 2022-10-16 151437.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -h##可以列出apt-get的完整用法</span><br></pre></td></tr></table></figure><h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search flight##搜索带有flight的软件包</span><br><span class="line">$ apt-cache depends flightgear##查询flightgear的依赖关系</span><br></pre></td></tr></table></figure><p>apt-get是安装源放在&#x2F;etc&#x2F;apt&#x2F;source.list中，这是一个文本文件。</p><h6 id="源码文件安装"><a href="#源码文件安装" class="headerlink" title="源码文件安装"></a>源码文件安装</h6><p>make先编译</p><p>之后使用make install具体方法看软件安装要求</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——磁盘管理</title>
      <link href="/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>磁盘管理三个常用的命令fdisk、du、df</p><p>df：检查文件系统的整体磁盘使用量</p><p>du：检查磁盘空间使用量</p><p>fdisk：用于磁盘的分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [-ahikHTm][目录或文件名]##具体参数可以查看 df --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du [-ahskm] 文件或目录名称    ##具体参数可以查看 du --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk [-l] 装置名称##fdisk是Linux的磁盘分区表操作工具</span><br></pre></td></tr></table></figure><p>若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><p>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><p>磁盘挂载使用mount卸载使用umount命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>关于具体操作事例可以看<a href="https://zhuanlan.zhihu.com/p/296777898">一篇看懂！Linux磁盘的管理（分区、格式化、挂载），LVM逻辑卷，RAID磁盘阵列 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——文件目录管理指令</title>
      <link href="/2022/10/13/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/10/13/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>linux系统不存在盘这个概念，用户通过操作目录来实现磁盘读写，Linux需要首先建立一个根‘“&#x2F;”文件系统，并在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的 文件系统挂载到这些目录中。</p><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png" alt="屏幕截图 2022-10-13 140836.png"></a></p><h6 id="用户间共享文件"><a href="#用户间共享文件" class="headerlink" title="用户间共享文件"></a>用户间共享文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##新建一个名为workgroup的用户组</span><br><span class="line">$ sudo groupadd workgroup</span><br><span class="line">##新建用户，并归入workgroup组</span><br><span class="line">$sudo useradd -G workgroup lucy</span><br><span class="line">$sudo passwd lucy##为用户lewis设置登录密码</span><br><span class="line">$sudo useradd -G workgroup lewis</span><br><span class="line">$sudo passwd lewis##为用户peter设置登录密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="建立文件和目录"><a href="#建立文件和目录" class="headerlink" title="建立文件和目录"></a>建立文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~##进入用户主目录</span><br><span class="line">$ mkdir document picture##新建两个目录</span><br><span class="line">$ mkdir ~/picture/temp##在主目录下新建名为temp的目录</span><br><span class="line">##如果没有中间的目录也就无法在下面创建一个新的文件或目录为此，使用-p选项</span><br><span class="line">$ mkdir -p ~/tempx/job##创建一个tempx文件夹在下面创建一个job文件夹</span><br></pre></td></tr></table></figure><h6 id="建立一个空文件"><a href="#建立一个空文件" class="headerlink" title="建立一个空文件"></a>建立一个空文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello##新建一个hello的文件</span><br><span class="line">$ touch hello##已经有hello的文件，所以可以更新hello文件的创建日期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv hello bin/##移动hello到bin/中</span><br><span class="line">$ mv photos/桌面/   ##移动photos目录到桌面</span><br><span class="line">$ mv -i hello test/##使用防止替换同名文件并加以提示.</span><br><span class="line">$ mv -b hello test/##在目标目录的同名文件后面加上~，相当于重命名</span><br></pre></td></tr></table></figure><h6 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp test.php test/##将test.php 放入到test下</span><br><span class="line">$ cp -i test.php test/##提示是否覆盖同名文件</span><br><span class="line">$ cp -r test/ 桌面/   ##连子目录带文件一起复制到下面</span><br></pre></td></tr></table></figure><h6 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redir remove##删除目录</span><br><span class="line">$ redir text/*.php##删除test目录下的所有php文件</span><br><span class="line">$ redir -r test##删除前有提示</span><br><span class="line">$ redir -f##避免交互直接回答y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改变文件所有权"><a href="#改变文件所有权" class="headerlink" title="改变文件所有权"></a>改变文件所有权</h6><p>chown语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [OPTION]... [OWNEr][:[GROUP]] FILE..</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png" alt="屏幕截图 2022-10-13 191232.png"></a></p><p>sudo 提供-R选项用于改变一个目录及其下所有文件的所有权设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R lewis iso/##将iso/和下面所有文件交给lewis</span><br></pre></td></tr></table></figure><h6 id="改变目标文件权限"><a href="#改变目标文件权限" class="headerlink" title="改变目标文件权限"></a>改变目标文件权限</h6><p>chmod用于改变一个文件的权限。使用用户组+&#x2F;-权限的表达方式，来增加&#x2F;删除权限。用户组包括文件属主（u）、文件数组（g）、其他人（o）和所有人（a），权限包括读取（r）、写入（w）和执行（x）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x days##增加属主对文件的执行权限</span><br><span class="line">$ chmod a-x days##删除所有人对days的执行权限</span><br><span class="line">$ chmod o=u days##将其他人的权限和属主一致</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png" alt="屏幕截图 2022-10-13 194308.png"></a></p><p>Linux有两类设备文件：字符设备和块设备文件。字符设备指的是能够从他那里读取成字符序列的设备，如磁带和串行线路，块设备指的是用来存储数据并对其各部分内容提供同等访问权的设备。如磁盘。</p><h6 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h6><p>符号链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s days my_days##建立一个my_days的符号链接指向文本文件days</span><br></pre></td></tr></table></figure><p>访问my_days就相当于访问days了。可以看作快捷方式删除并不会对源文件有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /usr/local/share/ local_share##建立一个指向/usr/local/share的符号链接local_share</span><br></pre></td></tr></table></figure><p>硬链接：将两个独立的文件联系在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln days hard_days##建立一个链接到days的新文件hard_days</span><br></pre></td></tr></table></figure><p>两个文件的改动会相互影响。</p><h6 id="输入输出重定向和管道"><a href="#输入输出重定向和管道" class="headerlink" title="输入输出重定向和管道"></a>输入输出重定向和管道</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &gt; ~/ls_out##将ls的输出重定向到lsout文件中，ls的输出不显示在屏幕上</span><br></pre></td></tr></table></figure><p>如果ls_out不存在那么会尝试建立这个文件，如果已经存在会替换原来的文件内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; days##让程序从一个文件中获取输入</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png"><img src="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png" alt="屏幕截图 2022-10-13 204659.png"></a></p><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png" alt="屏幕截图 2022-10-13 204909.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——基本指令</title>
      <link href="/2022/10/12/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/12/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="vim文本编译器"><a href="#vim文本编译器" class="headerlink" title="vim文本编译器"></a>vim文本编译器</h2><p>vim编译器编写文档、配置主机名称、网卡参数以及仓库。</p><p>三种模式——命令模式、末行模式、编辑模式。</p><p>命令模式：控制光标，可对文本删除、复制、粘贴</p><p>输入模式：正常的文本录入</p><p>末行模式：保存、退出与设置编译环境。</p><p><a href="https://cdn2.pandaimg.com/2022/10/12/63464afc99ff1.png"><img src="https://cdn2.pandaimg.com/2022/10/12/63464afc99ff1.png" alt="vim.png"></a></p><p><strong>vim命令模式常用快捷键</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>5dd</td><td>删除光标开始的5行</td></tr><tr><td>yy</td><td>复制所在行</td></tr><tr><td>5yy</td><td>复制光标开始的5行</td></tr><tr><td>p</td><td>将之前删除或者复制的粘贴到光标后</td></tr><tr><td>&#x2F;字符串</td><td>文本中从上至下搜索该字符串</td></tr><tr><td>？字符串</td><td>文本中从下至上搜索该字符串</td></tr><tr><td>n</td><td>显示搜索命令定位到下一个字符串</td></tr><tr><td>N</td><td>显示搜索命令定位到上一个字符串</td></tr><tr><td>u</td><td>撤销上一步操作</td></tr></tbody></table><p><strong>vim末行模式常用命令</strong></p><table><thead><tr><th>命令</th><th align="center">作用</th></tr></thead><tbody><tr><td>:w</td><td align="center">保存</td></tr><tr><td>:q</td><td align="center">退出</td></tr><tr><td>:q!</td><td align="center">强制退出</td></tr><tr><td>:wq!</td><td align="center">强制保存退出</td></tr><tr><td>:set nu</td><td align="center">显示行数</td></tr><tr><td>:set nonu</td><td align="center">不显示行数</td></tr><tr><td>:整数</td><td align="center">跳到该行</td></tr><tr><td>:命令</td><td align="center">执行该命令</td></tr></tbody></table><p>计算机硬件由<strong>预算器、控制器、存储器、输入&#x2F;输出设备</strong>等设备组成。系统内核能让机箱各种设备各司其职。内核负责驱动硬件、管理活动和分配&#x2F;管理硬件资源，<strong>不让用户直接操作</strong>。</p><p>shell称为壳，充当人与内核（硬件）的翻译官。<strong>shell脚本是将各种命令通过逻辑语句组合而成的程序。</strong></p><p>shell工作形式分为两种：</p><p>交互式：输入一条命令，shell解释并执行一条。</p><p>批处理：用户事先编写一个shell脚本，包含诸多命令，shell会一次执行完所有命令。</p><p>shell脚本编写用到vim文本编译器。<strong>一个完整shell脚本应该包含脚本声明、注释信息、可执行语句</strong></p><p>根据实际情况来组合各种命令选择和命令参数：<strong>命令名称[命令参数]【命令对象】</strong></p><p>命令对象一般是指要处理的目标（普通文件&#x2F;目标文件&#x2F;用户等）</p><p>命令的参数可选用长格式也可用短格式分别以—与-做前缀</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h6 id="浏览文件硬盘"><a href="#浏览文件硬盘" class="headerlink" title="浏览文件硬盘"></a>浏览文件硬盘</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /         ##进入根目录</span><br><span class="line">$ ls           ##列出文件和目录</span><br><span class="line">$ cat animal.c ##查看animal.c</span><br></pre></td></tr></table></figure><p>在输入文件名时候，只用输入前面几个字符按下TAB，Shell会自动补全。如果不止一个，shell会以列表形式全部打印出来。</p><h6 id="查看目录和文件"><a href="#查看目录和文件" class="headerlink" title="查看目录和文件"></a>查看目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd                     ##显示当前目录</span><br></pre></td></tr></table></figure><h6 id="改变目录"><a href="#改变目录" class="headerlink" title="改变目录"></a>改变目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..##进入/usr子目录</span><br><span class="line">$ cd ../..##进入根目录即/目录</span><br><span class="line">$ cd ##回到用户主目录</span><br></pre></td></tr></table></figure><h6 id="列出目录"><a href="#列出目录" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a##查看目录下的所有文件包含隐藏文件</span><br><span class="line">$ ls -1##查看文件的各种属性</span><br><span class="line">$ ls -F##区分目录下文件类型</span><br></pre></td></tr></table></figure><h6 id="列出目录-1"><a href="#列出目录-1" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dir##和ls一样</span><br><span class="line">$ vdir##相当于ls-1</span><br></pre></td></tr></table></figure><h6 id="查看文本文件"><a href="#查看文本文件" class="headerlink" title="查看文本文件"></a>查看文本文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat bool。c##查看bool.c文件的内容</span><br><span class="line">$ cat bool.c data.c##查看bool.c data.c 文件内容，可以查看不只一个文件内容</span><br><span class="line">$ cat -n bool.c##可以问内容前显示行数</span><br></pre></td></tr></table></figure><h6 id="阅读的文件开头和结尾"><a href="#阅读的文件开头和结尾" class="headerlink" title="阅读的文件开头和结尾"></a>阅读的文件开头和结尾</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head data.c##显示data。c的开头</span><br><span class="line">$ head -n 2 data.c##显示data.c文件的前两行</span><br></pre></td></tr></table></figure><h6 id="文本阅读less"><a href="#文本阅读less" class="headerlink" title="文本阅读less"></a>文本阅读less</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ less /c/data.c##打开C下的data.c文件</span><br><span class="line">之后向下翻页按空格向上翻页按B使用/内容，可以查询高亮显示查询下一个再输入/</span><br><span class="line">按下q可退出</span><br></pre></td></tr></table></figure><h6 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep main data.c##查找data.c中包含main的行</span><br><span class="line">$ grep main data.c animal.c     ##可以在多个文件中查找，查关键词时候要加上‘’单引号</span><br></pre></td></tr></table></figure><h6 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [OPTION] [path..] [expression]</span><br><span class="line">$ find c/d/2.c##c/d/2.c</span><br><span class="line">$ find c/d -name 2.c##c/d2.c</span><br><span class="line">$ find c/d -name 2.c -printf ok ##ok</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/12/63469dc80cff2.png"><img src="https://cdn2.pandaimg.com/2022/10/12/63469dc80cff2.png" alt="屏幕截图 2022-10-12 185720.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find c/d -type f -mtime -7 ##7天内修改过的文件</span><br></pre></td></tr></table></figure><h6 id="快速定位文件"><a href="#快速定位文件" class="headerlink" title="快速定位文件"></a>快速定位文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate *.c</span><br></pre></td></tr></table></figure><h6 id="查找特定程序"><a href="#查找特定程序" class="headerlink" title="查找特定程序"></a>查找特定程序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis find##查找find</span><br><span class="line">$ whereis -b find##查找这个程序的二进制可执行文件</span><br></pre></td></tr></table></figure><h6 id="用户版本信息查看"><a href="#用户版本信息查看" class="headerlink" title="用户版本信息查看"></a>用户版本信息查看</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who##看有哪些人登录</span><br><span class="line">$ whoami##我是谁</span><br></pre></td></tr></table></figure><h6 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a##显示系统版本信息</span><br><span class="line">$ uname -r##显示内核版本信息</span><br></pre></td></tr></table></figure><h6 id="寻求帮助指令"><a href="#寻求帮助指令" class="headerlink" title="寻求帮助指令"></a>寻求帮助指令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man find##获取find指令的信息</span><br></pre></td></tr></table></figure><h6 id="获取命令简介"><a href="#获取命令简介" class="headerlink" title="获取命令简介"></a>获取命令简介</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis uame##-printf system information</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/12/6346a69a1707e.png"><img src="https://cdn2.pandaimg.com/2022/10/12/6346a69a1707e.png" alt="屏幕截图 2022-10-12 193508.png"></a></p><h6 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h6><p>ldd可以列出一个程序所需要的共享库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd animal##查询animal文件需要的animal文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32实战篇</title>
      <link href="/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实战第一篇跑马灯"><a href="#实战第一篇跑马灯" class="headerlink" title="实战第一篇跑马灯"></a>实战第一篇跑马灯</h2><p>第一篇没什么好说的，没什么新鲜的东西，就是使用cubemx进行建立工程，新建led.c和led.h文件，对引脚进行赋予高低电平，此次不一样的是在led.h文件中对相应的IO口用英文做了宏定义，防止以后进行重复混乱调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_PIN         GPIO_PIN_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT   GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_PIN         GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT   GPIOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="实战第二篇按键检测"><a href="#实战第二篇按键检测" class="headerlink" title="实战第二篇按键检测"></a>实战第二篇按键检测</h2><h4 id="硬件消抖"><a href="#硬件消抖" class="headerlink" title="硬件消抖"></a>硬件消抖</h4><p>首先是硬件的设计，按下按键不会立即响应，有波纹信号，不方便检测需要进行滤波消抖。可以利用电容的放电延迟达到消除抖动的目的，这样只需要检测引脚的电平。</p><p><a href="https://postimg.cc/62dPcFkc"><img src="https://i.postimg.cc/hjwqDBMk/2022-09-27-181925.png" alt="2022-09-27-181925.png"></a></p><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><p>当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才的状态相同，就是稳定了，但是有局限性。</p><p>查询相关IO口在cubemx中进行设置为输入状态。由于引脚的默认电平受按键电路影响，所以设置成“浮空&#x2F;上拉&#x2F;下拉”模式均没有区别。</p><p>arm汇编指令集</p><p><a href="https://postimg.cc/v413R6K1"><img src="https://i.postimg.cc/zG7MgCSk/2022-09-27-202146.png" alt="2022-09-27-202146.png"></a></p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大<br>小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你<br>写的程序出现了莫名奇怪的错误，并进入了硬 fault 的时候，这时你就要考虑下是不是栈不够大，<br>溢出了。堆主要用来动态内存的分配</p><h2 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h2><p>设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决<br>定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 等于多少）、设置各个外设的分频因子；<br>控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。</p><p>一般是：PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M，<br>               PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M</p><p>HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当<br>使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从<br>OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。</p><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 APB 总线时钟，即 HCLK。</p><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到，HCLK2 属于高速的总线时钟，片上<br>高速的外设就挂载到这条总线上。APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，PCLK1 属于低速的总线时钟，最高为 36M，片上低速的外设就挂载到这条总线上，比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。</p><p>USB 时钟是由 PLLCLK 经过 USB 预分频器得到，USB 对时钟要求比较高，所以 PLLCLK 只能是由 HSE 倍频得到，不能使用 HSI 倍频。</p><p>ADC 时钟由 PCLK2 经过 ADC 预分频器得到。</p><p>RTC 时钟可由 HSE&#x2F;128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ，也可由<br>低速内部时钟信号LSI提供。独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供，LSI 是低速的内部时钟信号，频率为 30~60KHZ 直接不等，一般取 40KHZ。</p><h2 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h2><p>在 NVIC 有一个专门的寄存器：中断优先级寄存器 NVIC_IPRx，用来配置外部中断的优先级，IPR宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p><p>IRQn：用来设置中断源</p><p>PreemptionPriority：抢占优先级</p><p>SubPriority：子优先级</p><h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。</p><p>产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p><p>cubemx进行引脚配置，对相应的IO引脚选择GPIO_EXITx,xi表示挂载在中断线几，如GPIO_EXTI0就是挂在中断线0上。</p><p>开启下降沿触发中断：即在 <strong>按下按键时</strong> 电平由高变为低时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Falling edge trigger detection</code> </p><p>开启上升沿触发中断：即在 <strong>按下按键后松开时</strong> 电平由低变为高时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising edge trigger detection</code> </p><p>开启下降沿上升沿都触发中断：即在 <strong>按下时触发，松开时再次触发</strong>，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising/Falling edge trigger detection</code></p><p>如果硬件上已外部上拉或下拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>No pull-up and no pull-down</code> 既不上拉也不下拉。</p><p>如果硬件外部没有上拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>Pull-up</code> 内部上拉电阻。</p><p>如果不希望电平跳变事件触发中断，就配置为事件模式，反之，配置为中断模式。</p><p>中断执行流程为先中断初始化，使用中断可以避免使用论询来检测，发生电平变化触发外部中断，进入中断服务函数，中断服务函数中会调用中断处理公用函数（使用cubemx会在stm32f1xx_it.c中自动生成），中断处理公用函数中会检测标志位，并清零执行回调函数，终端中要执行的事情就放入中断回调函数中。</p><p>可以在stm32f1xx_it.c中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 0 */</span></span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go to Defnition of HAL_GPIO_EXTI_IRQHandler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断并清除中断标志位，然后调用HAL_GPIO_EXTI_Callback(GPIO_Pin);处理中断，同样的方式找到HAL_GPIO_EXTI_Callback的定义，你可以看到这个函数的声明前面有一个__weak声明，这个声明表示这个函数一旦被重新声明，这里的函数就自动失效，其他函数调用的时候就会找到你新定义的同名函数。</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。串口通讯有很多标准，以下是RS-232标准</p><p><a href="https://postimg.cc/zHmFByDH"><img src="https://i.postimg.cc/d33H5Cz6/2022-09-30-200343.png" alt="2022-09-30-200343.png"></a></p><p>由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平标准不同分为TTL标准和RS232电平标准</p><p><a href="https://postimg.cc/LhHzyFYp"><img src="https://i.postimg.cc/2jW2SzCV/2022-09-30-201456.png" alt="2022-09-30-201456.png"></a></p><p><a href="https://postimg.cc/MXCz6q7k"><img src="https://i.postimg.cc/zXBvkf3f/2022-09-30-201723.png" alt="2022-09-30-201723.png"></a></p><p>通用同步异步收发器 (Universal Synchronous Asynchronous Receiver and Transmitter) 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个 UART(UniversalAsynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p><p>串口通信有三种方式，分别为论询方式、中断方式、DMA方式。串口的通讯协议由开始位，数据位，校验位，结束位构成。一般以一个低电平作为一帧数据的起始，接着跟随 8 位或者 9 位数据位，之后为校验位，分为奇校验，偶校验和无校验，最后以一个先高后低的脉冲表示结束位，长度可以设置为 0.5，1，1.5 或 2 位长度。</p><p>当使用校验位时，串口传输的长度将是 8 位的数据帧加上 1 位的校验位总共 9 位，此时 USART_CR1 寄存器的 M 位需要设置为 1，即 9 数据位。将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收<br>数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位 + 数据帧 + 校验位 + 停止位</p><p>​      什么是硬件流控呢？流控的概念源于 RS232 这个标准，在 RS232 标准里面包含了串口、流控的定义。大家一定了解，RS232 中的“RS”是Recommend Standard 的缩写，即”推荐标准“之意，它并不像 IEEE-1284、IEEE-1394 等标准，是由“委员会定制”。因而，不同的厂商在做 RS232 时，多少会有不同，流控也都会存在差异。</p><p>为什么需要流控?</p><p>　　数据在两个串口之间进行通讯的时候常常会出现丢失数据的现象，比如两台计算机或者是一台计算机和一个单片机之间进行通讯，当接收端的数据缓冲区已经满了，这个时候如果还有数据发送过来，因为接收端没有时间进行处理，那这样的数据就有可能会丢失。在工业现场或者其他领域，经常会遇到这种问题，本质原因是速度不匹配、处理能力不匹配。比如单片机的主频只有20M或30M，ARM的处理能力可能是200M，PC机的处理能力是几个G，这种处理能力的不匹配造成了传输的时候数据容易丢失。</p><p>　　硬件流控就是来解决这个速度匹配的问题。它的基本含义非常简单，当接收端接收到的数据处理不过来时，就向发送端发送不再接收的信号，发送端接收到这个信号之后就会停止发送，直到收到可以继续发送的信号再继续发送。因此流控本身是可以控制数据传输的进度，进而防止数据丢失。</p><p>　　一般常用的流控方式有两种：硬件流控和软件流控。</p><p>​硬件流控和软件流控的区别</p><p>　　软件流控是以特殊的字符来代表从机已经不能再接收新的数据了，基本的流程就是从机在接收数据很多的时候或主动给发送端发送一个特殊字符，当发送端接收到这个特殊字符后就不能再发送数据了。</p><p>　　软件流控很方便，不需要增加新的硬件，还是以前的TX、RX，但是使用了软件流控，它本身的字符也是数据，这个数据只不过是说在软件里把它设置了一个特殊的含义。如果它是一个全双工的通讯，在给另一个串口发送数据的时候如果也包含了这样一个特殊字符，对方就会误以为我让它不要再发送数据了，会有一定的概率出现错误，而硬件流控就不需要考虑这方面，只需要使用 CTS 和 RTS，所有的数据都是由硬件来操作的。具体可以看<a href="https://www.cnblogs.com/923327iu/p/12159551.html#:~:text=STM32%20%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%20DE%20%E7%AE%A1%E8%84%9A%E5%92%8C%20RS485%20%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E8%8A%AF%E7%89%87%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E5%8F%91%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%E5%9C%A8,STM32%20%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E4%B8%AD%E5%85%B6%E5%AE%9E%E5%8C%85%E5%90%AB%E4%B8%A4%E6%96%B9%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%20RS232%20%E7%9A%84%20CTS%E3%80%81RTS%3B%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%AE%83%E6%98%AF%E5%9F%BA%E4%BA%8E%20RS485%20%E7%9A%84%EF%BC%8C%E5%9C%A8%E8%BD%AF%E4%BB%B6">stm32串口USART 硬件流控 –学习笔记 - 国产零零柒 - 博客园 (cnblogs.com)</a></p><p><a href="https://postimg.cc/8F1VsbPM"><img src="https://i.postimg.cc/nLmVRdyR/2022-09-30-205236.png" alt="2022-09-30-205236.png"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">HAL_UART_Transmit();串口轮询模式发送，使用超时管理机制</span><br><span class="line">HAL_UART_Receive();串口轮询模式接收，使用超时管理机制</span><br><span class="line">HAL_UART_Transmit_IT();串口中断模式发送</span><br><span class="line">HAL_UART_Receive_IT();串口中断模式接收</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式发送</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式接收</span><br><span class="line"><span class="number">2</span>、阻塞传输是调用这个函数并在等待时间内一直等待操作完成。</span><br><span class="line">HAL_UART_Transmit</span><br><span class="line">HAL_UART_Receive</span><br><span class="line">查询的方式一般少用，这里不做过多介绍。</span><br><span class="line"><span class="number">3</span>、串口中断</span><br><span class="line">串口中断函数</span><br><span class="line">HAL_UART_TxHalfCpltCallback();一半数据发送完成时调用</span><br><span class="line">HAL_UART_TxCpltCallback();数据完全发送完成后调用</span><br><span class="line">HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用</span><br><span class="line">HAL_UART_RxCpltCallback();数据完全接受完成后调用</span><br><span class="line">HAL_UART_ErrorCallback();传输出现错误时调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/119029425">(具体配置) 【STM32】HAL库——串口中断通信(二)_Q大帅的博客-CSDN博客_hal 串口中断</a></p><p>当printf打印不好使时是因为工程中没有选Micro USB</p><p><a href="https://postimg.cc/Z9kXMvXH"><img src="https://i.postimg.cc/XvX3Xw8R/2022-10-04-193120.png" alt="2022-10-04-193120.png"></a></p><p><a href="https://blog.csdn.net/zxt510001/article/details/125892562">() STM32 HAL库串口串口通信基础知识+HAL库代码理解</a></p><h2 id="DMA-直接存储访问"><a href="#DMA-直接存储访问" class="headerlink" title="DMA-直接存储访问"></a>DMA-直接存储访问</h2><p>DMA是单片机外设，不占用CPU，传输数据时候CPU可以做别的。如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求，DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。DMA有12个可独立编程通道，每个通道对应不同的外设DMA请求，可以接受多个请求，但同时只能接受一个。仲裁器，处理响应顺序的问题，分为软件阶段和硬件阶段，可以在 DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高。</p><p>MA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。具体的方向 DMA_CCR 位 4 DIR 配置：0 表示从外设到存储器，1 表示从存储器到外设。</p><p>更多原理可参看<a href="https://blog.csdn.net/as480133937/article/details/104927922"> DMA原理</a></p><p>在cubemx的配置只需要加上相应设备的DMA模式便可以生成代码进行使用。</p><p>I2C协议</p><p>首先分为物理层和协议层，两方面来看。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</p><p>一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p><p> 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p><p>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p><p>具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p><h4 id="协议层："><a href="#协议层：" class="headerlink" title="协议层："></a>协议层：</h4><p>I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p><p>S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。<br>起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7位或 10 位。在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收<br>到应答信号后，主机才能继续发送或接收数据。</p><p>若是传输为写数据方向，接收到应答信号后，主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位那么主机每发送完一个字节数据，都要等待从机的应答信号 (ACK)。</p><p>若配置的方向传输位为“读数据”方向，接收到应答信号后，从机开始向主机返回数据 (DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png"><img src="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png" alt="SDA.png"></a></p><h5 id="SCL处于1时-SDA由高变低↓—-gt-Start"><a href="#SCL处于1时-SDA由高变低↓—-gt-Start" class="headerlink" title="SCL处于1时, SDA由高变低↓—&gt;Start"></a>SCL处于1时, SDA由高变低↓—&gt;Start</h5><h5 id="图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高"><a href="#图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高" class="headerlink" title="图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高"></a>图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高</h5><h5 id="数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化"><a href="#数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化" class="headerlink" title="数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;"></a>数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;</h5><p><a href="%5B(88%E6%9D%A1%E6%B6%88%E6%81%AF"> IIchal相关函数分析</a> <a href="https://blog.csdn.net/kouxi1/article/details/123834448?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32hal%E5%BA%93iic&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-123834448.142%5Ev52%5Econtrol,201%5Ev3%5Econtrol&spm=1018.2226.3001.4187">015] [STM32] IIC协议详解与HAL库相关函数分析_柯西的彷徨的博客-CSDN博客</a>)</p><h2 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h2><p>SPI是一种高速全双工的通信总线</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>SPI 通讯使用 3 条总线及片选线，3 条总线分别为 SCK、MOSI、MISO，片选线</p><p>从设备选择信号线，常称为片选信号线，也称为 NSS、CS设备的其它信号线 SCK、MOSI 及 MIS O 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</p><p>SCK ：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样。<br> MOSI ：主设备输出&#x2F;从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。<br>MISO(Master Input,，Slave Output)：主设备输入&#x2F;从设备输出引脚。主机从这条信线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png"><img src="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png" alt="屏幕截图 2022-10-11 214647.png"></a></p><p>NSS 信号线由高变低，是 SPI 通讯的起始信号。NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。</p><p>观察图中的标号处，MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻，MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI 及 MISO 为下一次表示数据做准备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(三)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><u><strong>目录选项</strong></u></p><p>下列选项指定搜索路径，用于查头文件、库文件或编译器的某些成员。</p><p>(1)-Idir</p><p>在头文件的搜索路径列表中添加敌人目录。</p><p>(2)-I-</p><p>任何在“-I-” 前面用来指定的搜索路径只适用于“#include“file” ”这种情况，不适用于“#include&lt;stdio.h&gt;”</p><p>用-I-选项指定的搜索路径位于“-I-”选项后面，就可以搜索所有的#include指令</p><p>(3)-Ldir</p><p>在“-I”选项的搜索路径列表中添加dier目录。</p><p>(4)-Bprefix</p><p>这个选项指出在何处寻找可执行文件、库文件以及编译器自己的数据文件。编译器驱动程序需要使用某些工具，比如： cpp 、 ccl （或 C +＋的 cclplus )、 as 和 ld 。它把 prefix 当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。</p><p>对于要运行的工具，编译器驱动程序首先试着加上“- B ”前缀（如果存在），如果没有找到文件或没有指定“- B ”选项，编译器接着会试验两个标准前缀 usr &#x2F; lib &#x2F; gcc ／和&#x2F; usr &#x2F; local &#x2F; lib &#x2F; gcc - lib &#x2F;。如果仍然没能够找到所需文件，编译器就在“ PATH ”环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时（ run - time ）支持文件 libgcc . a 也在“- B ”前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找。如果上述方法没有找到这个文件，就不连接它了。多数情况的多数机器上， libgcc . a 并非必不可少。可以通过环境变量 GCCEXEC PREFIX 获得近似的效果：如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了“- B ”选项和 GCC EXEC _ PREFIX 变量，编译器首先使用“- B ”选项，然后才尝试环境变量值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(二)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>连接器选项</strong></p><p>（1）object-file-name</p><p>文件没有特别明确后缀，使用如下操作，obj文件可以变成连接器的输入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o  ,main.o和sub.o就是输入文件</span><br></pre></td></tr></table></figure><p>（2）-llibrary</p><p>连接名为library的库文件，这个方法找到的是库文件——即由OBJ文件组成的归档文件</p><p>（3）-nostartfiles</p><p>不连接系统标准启动文件，而标准库文件仍能正常启动</p><p>（4）-nostdlib</p><p>不连接系统标准启动文件和标准库文件，只把指定文件传递给连接器。仍以options程序作为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure><p>(5)-static</p><p>在支持动态连接的系统上阻止连接共享库</p><p>(6)-shared</p><p>生成一个共享OBJ文件，它可以和其他的OBJ文件连接产生可执行文件，只有部分系统支持，</p><p>不想用源代码发布程序时可以用它来生成库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line"></span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure><p>以后要使用sub.c 中的函数sub_fun时，连接程序时，将sub.a加入就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure><p>也可以多个文件作为一个库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub .o sub2.o sub3.o</span><br></pre></td></tr></table></figure><p>(7)-Xlinker opion</p><p>把选项option传递给连接器。可以用来传递系统特定的连接选项，gcc无法识别这些选项。必须使用两次-Xlinker，一次传递选项，另一次传递其他参数。</p><p>(8)-Wl,option</p><p>把选项option传递给连接器。如果option中有逗号，就在逗号处分割成多个选项。</p><p>(9)-u symbol</p><p>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义可以使用多个-u选项各自跟上不同的符号，使得连接器调入附加的库模块。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(一)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ cd 目标文件夹名称                 导向目标文件夹所在终端</span><br><span class="line"></span><br><span class="line">~$ touch hel                               创建一个叫hel的文件</span><br><span class="line"></span><br><span class="line">~$ gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span><br><span class="line"></span><br><span class="line">~$ gcc hel.c -o test                    编译hel.c为test可执行文件</span><br><span class="line"></span><br><span class="line">~$ ./test                                     执行test可执行文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>在C语言文件中调用math.h库报错只需要gcc将代码与链接库连接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc two.c -lm -o two</span><br></pre></td></tr></table></figure><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ gcc -Wll -c hello.c</span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><a href="https://postimg.cc/KK9hg8zb"><img src="https://i.postimg.cc/XJWjmZ6r/yi.png" alt="yi.png"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32系统学习</title>
      <link href="/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>stm32主系统由四个去驱动单元和四个被动单元构成。</strong></p><p>四个驱动是内核DCode总线；系统总线；通用DMA1；通用DMA2</p><p>四被动单元是AHB到APB的桥：连接所有APB的设备；内存FLASH；内部SRAM；FSMC</p><p>① ICode 总线：该总线将 M3 内核指令总线和闪存指令接口相连，指令的预取在该总线上<br>面完成。<br>② DCode 总线：该总线将 M3 内核的 DCode 总线与闪存存储器的数据接口相连接，常量<br>加载和调试访问在该总线上面完成。<br>③ 系统总线：该总线连接 M3 内核的系统总线到总线矩阵，总线矩阵协调内核和 DMA 间<br>访问。<br>④ DMA 总线：该总线将 DMA 的 AHB 主控接口与总线矩阵相连，总线矩阵协调 CPU 的<br>DCode 和 DMA 到 SRAM,闪存和外设的访问。<br>⑤ 总线矩阵：总线矩阵协调内核系统总线和 DMA 主控总线之间的访问仲裁，仲裁利用<br>轮换算法。<br>⑥ AHB&#x2F;APB 桥:这两个桥在 AHB 和 2 个 APB 总线间提供同步连接，APB1 操作速度限于<br>36MHz,APB2 操作速度全速。</p><p><strong>stm32的5个时钟源</strong></p><p>用来配置时钟树</p><p>①HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。<br>②HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz到16MHz。<br>③LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同<br>时 LSI 还可以作为 RTC 的时钟源。<br>④LSE 是低速外部时钟，使用频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>⑤PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2到16 倍，但是其输出频率最大不得超过 72MHz。</p><p>程序执行顺序</p><p><a href="https://postimg.cc/68vJqYZh"><img src="https://i.postimg.cc/2SHzHt8g/liucheng.png" alt="liucheng.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用ｆｌａｓｈ，使用串口下载，或者可以选择使用SWD</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm-linux -ld、-objcopy和obdump</title>
      <link href="/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/"/>
      <url>/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/</url>
      
        <content type="html"><![CDATA[<p><strong>arm-linux-ld用于将多个目标文件、库文件连接成可执行文件。</strong></p><p>-T 直接指定代码段、数据段、bss段的起始地址,只用于连接Bootloader、内核等没有底层软件支持的软件</p><p>连接操作系统应用程序时候，无需-T，默认连接。</p><p>1.直接指定代码段、数据段、bss段的起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure><p>startaddr分别代表代码段、数据段、bss段的起始地址</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttext 0x000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure><p>代表代码段运行地址为0x000000，没有定义数据段、bss段起始地址所以被放入代码段的后面</p><p>2.使用连接脚本设置地址</p><p><strong>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可用不同于源文件的格式来输出目的文件，即可以进行格式转换。</strong></p><p>1、input-file、outfile分别是输入目标文件和输出目标文件，如果没有明确指定outfile，将创建一个临时文件来存放结果，用input-file的名字来命名。</p><p>2、 -l bfname或–input-target&#x3D;bfdname</p><p>用来指明源文件的格式，bfdname是BFD库描述的标准格式名，如果不指明格式，会自己分析源文件格式，去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</p><p>3、-O bfdname或–output-target&#x3D;bfdname</p><p>使用指定格式来输出文件，bdfname是BFD库中的标准格式名。</p><p><strong>arm-linux-objdump用于显示二进制文件信息</strong></p><p>未完待续。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32hal库</title>
      <link href="/2022/07/01/stm32hal%E5%BA%93/"/>
      <url>/2022/07/01/stm32hal%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>为方便使用，用typedef来给变量起名将以下放入main.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int16_t</span> s16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int8_t</span>  s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int32_t</span> sc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int16_t</span> sc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int8_t</span> sc8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int32_t</span>  vs32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int16_t</span>  vs16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int8_t</span>   vs8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int32_t</span> vsc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int16_t</span> vsc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int8_t</span> vsc8;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>  u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span>  u8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint32_t</span> uc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint16_t</span> uc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint8_t</span> uc8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint32_t</span>  vu32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint16_t</span> vu16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint8_t</span>  vu8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint32_t</span> vuc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint16_t</span> vuc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint8_t</span> vuc8;  </span><br></pre></td></tr></table></figure><p>点亮led</p><p>GPIO用IO口的输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);<span class="comment">//控制电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);<span class="comment">//翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOA, GPIO_Pin_8);<span class="comment">//读取电平</span></span><br></pre></td></tr></table></figure><p>点亮led就需要按键了，按键首先要看按键的引脚设置IO口为输入模式，写一个案件处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line"> <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>; <span class="comment">//支持连按</span></span><br><span class="line"> <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>);</span><br><span class="line"> key_up=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="keyword">return</span> KEY1_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">ALIENTEK MiniSTM32 V3<span class="number">.0</span> 开发板教程</span><br><span class="line"><span class="number">137</span></span><br><span class="line">STM32 不完全手册(HAL 库版)</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中进行添加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5) <span class="comment">//KEY0 按键 PC5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15) <span class="comment">//KEY1 按键 PA15</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) <span class="comment">//WKUP 按键 PA0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES 3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>串口通信</p><p>usart和uart区别为 usart比uart多了同步时钟频率通信，都有异步时钟通信。</p><p>串口设置的一般步骤可以总结为如下几个步骤：</p><ol><li>串口时钟使能，GPIO 时钟使能。</li><li>设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</li><li>GPIO 初始化设置：要设置模式为复用功能。</li><li>串口参数初始化：设置波特率，字长，奇偶校验等参数。</li><li>开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</li><li>使能串口。</li><li>编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</li></ol><p>串口通信的结构体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> uint32_t BaudRate; //波特率</span><br><span class="line"> uint32_t WordLength; //字长</span><br><span class="line"> uint32_t StopBits; //停止位</span><br><span class="line"> uint32_t Parity; //奇偶校验</span><br><span class="line"> uint32_t Mode; //收/发模式设置</span><br><span class="line"> uint32_t HwFlowCtl; //硬件流设置</span><br><span class="line"> uint32_t OverSampling; //过采样设置</span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的学习</title>
      <link href="/2022/06/30/makefile/"/>
      <url>/2022/06/30/makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tieba.baidu.com/p/591519800">Makefile详解（超级好）【mingw吧】_百度贴吧 (baidu.com)</a></p><p>上面挂一个较好的makefile的教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/03/hello-world/"/>
      <url>/2022/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
