<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux系统管理篇——用户管理</title>
      <link href="/2022/10/19/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/19/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="添加新用户并建立主目录"><a href="#添加新用户并建立主目录" class="headerlink" title="添加新用户并建立主目录"></a>添加新用户并建立主目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesradd -m john##添加用户叫john并建立主目录</span><br><span class="line">$ sudo passwd john##更改john的密码</span><br></pre></td></tr></table></figure><h4 id="添加用户命令行工具"><a href="#添加用户命令行工具" class="headerlink" title="添加用户命令行工具"></a>添加用户命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd john##添加用户john</span><br><span class="line">$ passwd john##john设置密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -g users john##创立john并指定属于users组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /bin/bash mike##建立mike用户并指定登陆后使用bash作为Shell</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd newgroup##在系统中太内疚newgroup的组</span><br></pre></td></tr></table></figure><h4 id="记录用户操作"><a href="#记录用户操作" class="headerlink" title="记录用户操作"></a>记录用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br><span class="line">$ history 10##记录了最近用的10条指令</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesrdel mike##删除用户mike</span><br><span class="line">$ sudo userdel -r john##删除john删除其主目录</span><br></pre></td></tr></table></figure><h4 id="管理用户账号"><a href="#管理用户账号" class="headerlink" title="管理用户账号"></a>管理用户账号</h4><p><a href="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png"><img src="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png" alt="屏幕截图 2022-10-19 211029.png"></a></p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id hanfeng##查看用户的UID、GID及所属组的信息</span><br></pre></td></tr></table></figure><h4 id="用户转换"><a href="#用户转换" class="headerlink" title="用户转换"></a>用户转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su john##进入john用户</span><br><span class="line">$ exit##回到之前的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-压缩与解压缩</title>
      <link href="/2022/10/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/10/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="gzip压缩工具"><a href="#gzip压缩工具" class="headerlink" title="gzip压缩工具"></a>gzip压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gzip gztest##压缩gztest</span><br><span class="line">$ gzip -d gztest##解压缩gztest</span><br><span class="line">$ gzip -r gztest##对文件夹压缩</span><br><span class="line">$ gzip -rd gztest.gz##对文件夹解压缩</span><br></pre></td></tr></table></figure><p>gzip 虽然对文件夹进行压缩，但是不能提供打包服务，只对文件夹<strong>内部的文件进行单独压缩。</strong></p><h4 id="bzip2压缩工具"><a href="#bzip2压缩工具" class="headerlink" title="bzip2压缩工具"></a>bzip2压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -z a.c##压缩</span><br><span class="line">$ bzip2 -d a.c.bz2##解压缩</span><br></pre></td></tr></table></figure><h4 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h4><p>tar工具提供打包服务，就是将多个文件打包。常用参数-f归档 ,-c创建新归档创建压缩文件，-x：从文档中解压缩</p><p>-j：使用bzip2压缩格式，-z 使用gzip压缩格式 -v 打印命令执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -vxjf xxx.tar.bz2##解压缩</span><br><span class="line">$ tar -vcjf xxx.tar.bz2 xxx ##压缩</span><br><span class="line">$ tar -vxzfxxx.tar.gz##解压缩</span><br><span class="line">$ tar -vczf xxx.tar.gz xxx ##压缩</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-软件包管理</title>
      <link href="/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="管理-deb软件包"><a href="#管理-deb软件包" class="headerlink" title="管理.deb软件包"></a>管理.deb软件包</h4><h6 id="查看已安装的软件包"><a href="#查看已安装的软件包" class="headerlink" title="查看已安装的软件包"></a>查看已安装的软件包</h6><p> OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -l | grep openssh##查找openssh的版本信息</span><br><span class="line">$ dekg -s openssh##查看哪些文件是openssh带来的</span><br></pre></td></tr></table></figure><h6 id="安装卸载软件包"><a href="#安装卸载软件包" class="headerlink" title="安装卸载软件包"></a>安装卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo dpkg -i xxx.deb##安装xxx</span><br><span class="line"></span><br><span class="line">$sudo dpkg --remove opera##删除opera浏览器</span><br></pre></td></tr></table></figure><h4 id="管理RPM软件包"><a href="#管理RPM软件包" class="headerlink" title="管理RPM软件包"></a>管理RPM软件包</h4><h6 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -i -v -h dump-0.4b41-1.src.rpm##-i是安装命令-v显示正在执行工作-h打印提醒进度</span><br></pre></td></tr></table></figure><p>升级安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh dump-0.4b41-1.src.rpm</span><br></pre></td></tr></table></figure><p>查看已经安装的软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -q check##rpm -q命令可以查询已经安装的软件包是安装包文件的名字，不是文件的名字</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png" alt="屏幕截图 2022-10-16 144841.png"></a></p><h6 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -e tcpdump##卸载tcpdump软件包</span><br></pre></td></tr></table></figure><h4 id="高级软件包工具APT"><a href="#高级软件包工具APT" class="headerlink" title="高级软件包工具APT"></a>高级软件包工具APT</h4><h6 id="下载和安装软件包"><a href="#下载和安装软件包" class="headerlink" title="下载和安装软件包"></a>下载和安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update##更新软件包</span><br><span class="line">$ sduo apt-get install wesnoth##下载安装wesnoth</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png" alt="屏幕截图 2022-10-16 151437.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -h##可以列出apt-get的完整用法</span><br></pre></td></tr></table></figure><h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search flight##搜索带有flight的软件包</span><br><span class="line">$ apt-cache depends flightgear##查询flightgear的依赖关系</span><br></pre></td></tr></table></figure><p>apt-get是安装源放在&#x2F;etc&#x2F;apt&#x2F;source.list中，这是一个文本文件。</p><h6 id="源码文件安装"><a href="#源码文件安装" class="headerlink" title="源码文件安装"></a>源码文件安装</h6><p>make先编译</p><p>之后使用make install具体方法看软件安装要求</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——磁盘管理</title>
      <link href="/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>磁盘管理三个常用的命令fdisk、du、df</p><p>df：检查文件系统的整体磁盘使用量</p><p>du：检查磁盘空间使用量</p><p>fdisk：用于磁盘的分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [-ahikHTm][目录或文件名]##具体参数可以查看 df --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du [-ahskm] 文件或目录名称    ##具体参数可以查看 du --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk [-l] 装置名称##fdisk是Linux的磁盘分区表操作工具</span><br></pre></td></tr></table></figure><p>若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><p>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><p>磁盘挂载使用mount卸载使用umount命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>关于具体操作事例可以看<a href="https://zhuanlan.zhihu.com/p/296777898">一篇看懂！Linux磁盘的管理（分区、格式化、挂载），LVM逻辑卷，RAID磁盘阵列 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——文件目录管理指令</title>
      <link href="/2022/10/13/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/10/13/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>linux系统不存在盘这个概念，用户通过操作目录来实现磁盘读写，Linux需要首先建立一个根‘“&#x2F;”文件系统，并在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的 文件系统挂载到这些目录中。</p><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png" alt="屏幕截图 2022-10-13 140836.png"></a></p><h6 id="用户间共享文件"><a href="#用户间共享文件" class="headerlink" title="用户间共享文件"></a>用户间共享文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##新建一个名为workgroup的用户组</span><br><span class="line">$ sudo groupadd workgroup</span><br><span class="line">##新建用户，并归入workgroup组</span><br><span class="line">$sudo useradd -G workgroup lucy</span><br><span class="line">$sudo passwd lucy##为用户lewis设置登录密码</span><br><span class="line">$sudo useradd -G workgroup lewis</span><br><span class="line">$sudo passwd lewis##为用户peter设置登录密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="建立文件和目录"><a href="#建立文件和目录" class="headerlink" title="建立文件和目录"></a>建立文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~##进入用户主目录</span><br><span class="line">$ mkdir document picture##新建两个目录</span><br><span class="line">$ mkdir ~/picture/temp##在主目录下新建名为temp的目录</span><br><span class="line">##如果没有中间的目录也就无法在下面创建一个新的文件或目录为此，使用-p选项</span><br><span class="line">$ mkdir -p ~/tempx/job##创建一个tempx文件夹在下面创建一个job文件夹</span><br></pre></td></tr></table></figure><h6 id="建立一个空文件"><a href="#建立一个空文件" class="headerlink" title="建立一个空文件"></a>建立一个空文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello##新建一个hello的文件</span><br><span class="line">$ touch hello##已经有hello的文件，所以可以更新hello文件的创建日期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv hello bin/##移动hello到bin/中</span><br><span class="line">$ mv photos/桌面/   ##移动photos目录到桌面</span><br><span class="line">$ mv -i hello test/##使用防止替换同名文件并加以提示.</span><br><span class="line">$ mv -b hello test/##在目标目录的同名文件后面加上~，相当于重命名</span><br></pre></td></tr></table></figure><h6 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp test.php test/##将test.php 放入到test下</span><br><span class="line">$ cp -i test.php test/##提示是否覆盖同名文件</span><br><span class="line">$ cp -r test/ 桌面/   ##连子目录带文件一起复制到下面</span><br></pre></td></tr></table></figure><h6 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redir remove##删除目录</span><br><span class="line">$ redir text/*.php##删除test目录下的所有php文件</span><br><span class="line">$ redir -r test##删除前有提示</span><br><span class="line">$ redir -f##避免交互直接回答y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改变文件所有权"><a href="#改变文件所有权" class="headerlink" title="改变文件所有权"></a>改变文件所有权</h6><p>chown语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [OPTION]... [OWNEr][:[GROUP]] FILE..</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png" alt="屏幕截图 2022-10-13 191232.png"></a></p><p>sudo 提供-R选项用于改变一个目录及其下所有文件的所有权设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R lewis iso/##将iso/和下面所有文件交给lewis</span><br></pre></td></tr></table></figure><h6 id="改变目标文件权限"><a href="#改变目标文件权限" class="headerlink" title="改变目标文件权限"></a>改变目标文件权限</h6><p>chmod用于改变一个文件的权限。使用用户组+&#x2F;-权限的表达方式，来增加&#x2F;删除权限。用户组包括文件属主（u）、文件数组（g）、其他人（o）和所有人（a），权限包括读取（r）、写入（w）和执行（x）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x days##增加属主对文件的执行权限</span><br><span class="line">$ chmod a-x days##删除所有人对days的执行权限</span><br><span class="line">$ chmod o=u days##将其他人的权限和属主一致</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png" alt="屏幕截图 2022-10-13 194308.png"></a></p><p>Linux有两类设备文件：字符设备和块设备文件。字符设备指的是能够从他那里读取成字符序列的设备，如磁带和串行线路，块设备指的是用来存储数据并对其各部分内容提供同等访问权的设备。如磁盘。</p><h6 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h6><p>符号链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s days my_days##建立一个my_days的符号链接指向文本文件days</span><br></pre></td></tr></table></figure><p>访问my_days就相当于访问days了。可以看作快捷方式删除并不会对源文件有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /usr/local/share/ local_share##建立一个指向/usr/local/share的符号链接local_share</span><br></pre></td></tr></table></figure><p>硬链接：将两个独立的文件联系在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln days hard_days##建立一个链接到days的新文件hard_days</span><br></pre></td></tr></table></figure><p>两个文件的改动会相互影响。</p><h6 id="输入输出重定向和管道"><a href="#输入输出重定向和管道" class="headerlink" title="输入输出重定向和管道"></a>输入输出重定向和管道</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &gt; ~/ls_out##将ls的输出重定向到lsout文件中，ls的输出不显示在屏幕上</span><br></pre></td></tr></table></figure><p>如果ls_out不存在那么会尝试建立这个文件，如果已经存在会替换原来的文件内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; days##让程序从一个文件中获取输入</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png"><img src="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png" alt="屏幕截图 2022-10-13 204659.png"></a></p><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png" alt="屏幕截图 2022-10-13 204909.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——基本指令</title>
      <link href="/2022/10/12/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/12/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="vim文本编译器"><a href="#vim文本编译器" class="headerlink" title="vim文本编译器"></a>vim文本编译器</h2><p>vim编译器编写文档、配置主机名称、网卡参数以及仓库。</p><p>三种模式——命令模式、末行模式、编辑模式。</p><p>命令模式：控制光标，可对文本删除、复制、粘贴</p><p>输入模式：正常的文本录入</p><p>末行模式：保存、退出与设置编译环境。</p><p><a href="https://cdn2.pandaimg.com/2022/10/12/63464afc99ff1.png"><img src="https://cdn2.pandaimg.com/2022/10/12/63464afc99ff1.png" alt="vim.png"></a></p><p><strong>vim命令模式常用快捷键</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>5dd</td><td>删除光标开始的5行</td></tr><tr><td>yy</td><td>复制所在行</td></tr><tr><td>5yy</td><td>复制光标开始的5行</td></tr><tr><td>p</td><td>将之前删除或者复制的粘贴到光标后</td></tr><tr><td>&#x2F;字符串</td><td>文本中从上至下搜索该字符串</td></tr><tr><td>？字符串</td><td>文本中从下至上搜索该字符串</td></tr><tr><td>n</td><td>显示搜索命令定位到下一个字符串</td></tr><tr><td>N</td><td>显示搜索命令定位到上一个字符串</td></tr><tr><td>u</td><td>撤销上一步操作</td></tr></tbody></table><p><strong>vim末行模式常用命令</strong></p><table><thead><tr><th>命令</th><th align="center">作用</th></tr></thead><tbody><tr><td>:w</td><td align="center">保存</td></tr><tr><td>:q</td><td align="center">退出</td></tr><tr><td>:q!</td><td align="center">强制退出</td></tr><tr><td>:wq!</td><td align="center">强制保存退出</td></tr><tr><td>:set nu</td><td align="center">显示行数</td></tr><tr><td>:set nonu</td><td align="center">不显示行数</td></tr><tr><td>:整数</td><td align="center">跳到该行</td></tr><tr><td>:命令</td><td align="center">执行该命令</td></tr></tbody></table><p>计算机硬件由<strong>预算器、控制器、存储器、输入&#x2F;输出设备</strong>等设备组成。系统内核能让机箱各种设备各司其职。内核负责驱动硬件、管理活动和分配&#x2F;管理硬件资源，<strong>不让用户直接操作</strong>。</p><p>shell称为壳，充当人与内核（硬件）的翻译官。<strong>shell脚本是将各种命令通过逻辑语句组合而成的程序。</strong></p><p>shell工作形式分为两种：</p><p>交互式：输入一条命令，shell解释并执行一条。</p><p>批处理：用户事先编写一个shell脚本，包含诸多命令，shell会一次执行完所有命令。</p><p>shell脚本编写用到vim文本编译器。<strong>一个完整shell脚本应该包含脚本声明、注释信息、可执行语句</strong></p><p>根据实际情况来组合各种命令选择和命令参数：<strong>命令名称[命令参数]【命令对象】</strong></p><p>命令对象一般是指要处理的目标（普通文件&#x2F;目标文件&#x2F;用户等）</p><p>命令的参数可选用长格式也可用短格式分别以—与-做前缀</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h6 id="浏览文件硬盘"><a href="#浏览文件硬盘" class="headerlink" title="浏览文件硬盘"></a>浏览文件硬盘</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /         ##进入根目录</span><br><span class="line">$ ls           ##列出文件和目录</span><br><span class="line">$ cat animal.c ##查看animal.c</span><br></pre></td></tr></table></figure><p>在输入文件名时候，只用输入前面几个字符按下TAB，Shell会自动补全。如果不止一个，shell会以列表形式全部打印出来。</p><h6 id="查看目录和文件"><a href="#查看目录和文件" class="headerlink" title="查看目录和文件"></a>查看目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd                     ##显示当前目录</span><br></pre></td></tr></table></figure><h6 id="改变目录"><a href="#改变目录" class="headerlink" title="改变目录"></a>改变目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..##进入/usr子目录</span><br><span class="line">$ cd ../..##进入根目录即/目录</span><br><span class="line">$ cd ##回到用户主目录</span><br></pre></td></tr></table></figure><h6 id="列出目录"><a href="#列出目录" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a##查看目录下的所有文件包含隐藏文件</span><br><span class="line">$ ls -1##查看文件的各种属性</span><br><span class="line">$ ls -F##区分目录下文件类型</span><br></pre></td></tr></table></figure><h6 id="列出目录-1"><a href="#列出目录-1" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dir##和ls一样</span><br><span class="line">$ vdir##相当于ls-1</span><br></pre></td></tr></table></figure><h6 id="查看文本文件"><a href="#查看文本文件" class="headerlink" title="查看文本文件"></a>查看文本文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat bool。c##查看bool.c文件的内容</span><br><span class="line">$ cat bool.c data.c##查看bool.c data.c 文件内容，可以查看不只一个文件内容</span><br><span class="line">$ cat -n bool.c##可以问内容前显示行数</span><br></pre></td></tr></table></figure><h6 id="阅读的文件开头和结尾"><a href="#阅读的文件开头和结尾" class="headerlink" title="阅读的文件开头和结尾"></a>阅读的文件开头和结尾</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head data.c##显示data。c的开头</span><br><span class="line">$ head -n 2 data.c##显示data.c文件的前两行</span><br></pre></td></tr></table></figure><h6 id="文本阅读less"><a href="#文本阅读less" class="headerlink" title="文本阅读less"></a>文本阅读less</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ less /c/data.c##打开C下的data.c文件</span><br><span class="line">之后向下翻页按空格向上翻页按B使用/内容，可以查询高亮显示查询下一个再输入/</span><br><span class="line">按下q可退出</span><br></pre></td></tr></table></figure><h6 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep main data.c##查找data.c中包含main的行</span><br><span class="line">$ grep main data.c animal.c     ##可以在多个文件中查找，查关键词时候要加上‘’单引号</span><br></pre></td></tr></table></figure><h6 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [OPTION] [path..] [expression]</span><br><span class="line">$ find c/d/2.c##c/d/2.c</span><br><span class="line">$ find c/d -name 2.c##c/d2.c</span><br><span class="line">$ find c/d -name 2.c -printf ok ##ok</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/12/63469dc80cff2.png"><img src="https://cdn2.pandaimg.com/2022/10/12/63469dc80cff2.png" alt="屏幕截图 2022-10-12 185720.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find c/d -type f -mtime -7 ##7天内修改过的文件</span><br></pre></td></tr></table></figure><h6 id="快速定位文件"><a href="#快速定位文件" class="headerlink" title="快速定位文件"></a>快速定位文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate *.c</span><br></pre></td></tr></table></figure><h6 id="查找特定程序"><a href="#查找特定程序" class="headerlink" title="查找特定程序"></a>查找特定程序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis find##查找find</span><br><span class="line">$ whereis -b find##查找这个程序的二进制可执行文件</span><br></pre></td></tr></table></figure><h6 id="用户版本信息查看"><a href="#用户版本信息查看" class="headerlink" title="用户版本信息查看"></a>用户版本信息查看</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who##看有哪些人登录</span><br><span class="line">$ whoami##我是谁</span><br></pre></td></tr></table></figure><h6 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a##显示系统版本信息</span><br><span class="line">$ uname -r##显示内核版本信息</span><br></pre></td></tr></table></figure><h6 id="寻求帮助指令"><a href="#寻求帮助指令" class="headerlink" title="寻求帮助指令"></a>寻求帮助指令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man find##获取find指令的信息</span><br></pre></td></tr></table></figure><h6 id="获取命令简介"><a href="#获取命令简介" class="headerlink" title="获取命令简介"></a>获取命令简介</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis uame##-printf system information</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/12/6346a69a1707e.png"><img src="https://cdn2.pandaimg.com/2022/10/12/6346a69a1707e.png" alt="屏幕截图 2022-10-12 193508.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习过程中的问题</title>
      <link href="/2022/10/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="1-scanf输入问题-输入缓冲区"><a href="#1-scanf输入问题-输入缓冲区" class="headerlink" title="1.scanf输入问题-输入缓冲区"></a>1.scanf输入问题-输入缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"><span class="keyword">while</span>(b == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a<span class="comment">//输入a</span></span><br><span class="line"><span class="number">0</span>?a1?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是因为scanf()函数会把回车、空格、Tab或一些不合理输入的字符当作此次输入的结束标志，它不会把这些字符输入到想要保存此次输入数据的变量中，而是把这些字符遗留在了输入缓冲区，那么，当下一次想要从标准输入中读取一个字符时，这个遗留的字符就正好充当了此次的输入字符。</p><p>程序在输入a后输入了回车来结束此次输入，那么回车就遗留在了输入缓冲区，当需要给c输入字符时，它自动的充当了输入的字符，因此，程序没有给我们输入c的字符的机会。</p><p>C语言为了解决这种问题，为我们提供了一种很方便的清空输入缓冲区的方式—-&gt;&gt;fflush()函数，fflush(stdin)它会把残留在输入缓冲区里的所有数据清空。头文件为stdio.h</p><p>或者使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过该行剩下的内容。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32实战篇</title>
      <link href="/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实战第一篇跑马灯"><a href="#实战第一篇跑马灯" class="headerlink" title="实战第一篇跑马灯"></a>实战第一篇跑马灯</h2><p>第一篇没什么好说的，没什么新鲜的东西，就是使用cubemx进行建立工程，新建led.c和led.h文件，对引脚进行赋予高低电平，此次不一样的是在led.h文件中对相应的IO口用英文做了宏定义，防止以后进行重复混乱调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_PIN         GPIO_PIN_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT   GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_PIN         GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT   GPIOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="实战第二篇按键检测"><a href="#实战第二篇按键检测" class="headerlink" title="实战第二篇按键检测"></a>实战第二篇按键检测</h2><h4 id="硬件消抖"><a href="#硬件消抖" class="headerlink" title="硬件消抖"></a>硬件消抖</h4><p>首先是硬件的设计，按下按键不会立即响应，有波纹信号，不方便检测需要进行滤波消抖。可以利用电容的放电延迟达到消除抖动的目的，这样只需要检测引脚的电平。</p><p><a href="https://postimg.cc/62dPcFkc"><img src="https://i.postimg.cc/hjwqDBMk/2022-09-27-181925.png" alt="2022-09-27-181925.png"></a></p><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><p>当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才的状态相同，就是稳定了，但是有局限性。</p><p>查询相关IO口在cubemx中进行设置为输入状态。由于引脚的默认电平受按键电路影响，所以设置成“浮空&#x2F;上拉&#x2F;下拉”模式均没有区别。</p><p>arm汇编指令集</p><p><a href="https://postimg.cc/v413R6K1"><img src="https://i.postimg.cc/zG7MgCSk/2022-09-27-202146.png" alt="2022-09-27-202146.png"></a></p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大<br>小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你<br>写的程序出现了莫名奇怪的错误，并进入了硬 fault 的时候，这时你就要考虑下是不是栈不够大，<br>溢出了。堆主要用来动态内存的分配</p><h2 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h2><p>设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决<br>定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 等于多少）、设置各个外设的分频因子；<br>控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。</p><p>一般是：PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M，<br>               PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M</p><p>HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当<br>使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从<br>OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。</p><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 APB 总线时钟，即 HCLK。</p><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到，HCLK2 属于高速的总线时钟，片上<br>高速的外设就挂载到这条总线上。APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，PCLK1 属于低速的总线时钟，最高为 36M，片上低速的外设就挂载到这条总线上，比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。</p><p>USB 时钟是由 PLLCLK 经过 USB 预分频器得到，USB 对时钟要求比较高，所以 PLLCLK 只能是由 HSE 倍频得到，不能使用 HSI 倍频。</p><p>ADC 时钟由 PCLK2 经过 ADC 预分频器得到。</p><p>RTC 时钟可由 HSE&#x2F;128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ，也可由<br>低速内部时钟信号LSI提供。独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供，LSI 是低速的内部时钟信号，频率为 30~60KHZ 直接不等，一般取 40KHZ。</p><h2 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h2><p>在 NVIC 有一个专门的寄存器：中断优先级寄存器 NVIC_IPRx，用来配置外部中断的优先级，IPR宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p><p>IRQn：用来设置中断源</p><p>PreemptionPriority：抢占优先级</p><p>SubPriority：子优先级</p><h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。</p><p>产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p><p>cubemx进行引脚配置，对相应的IO引脚选择GPIO_EXITx,xi表示挂载在中断线几，如GPIO_EXTI0就是挂在中断线0上。</p><p>开启下降沿触发中断：即在 <strong>按下按键时</strong> 电平由高变为低时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Falling edge trigger detection</code> </p><p>开启上升沿触发中断：即在 <strong>按下按键后松开时</strong> 电平由低变为高时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising edge trigger detection</code> </p><p>开启下降沿上升沿都触发中断：即在 <strong>按下时触发，松开时再次触发</strong>，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising/Falling edge trigger detection</code></p><p>如果硬件上已外部上拉或下拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>No pull-up and no pull-down</code> 既不上拉也不下拉。</p><p>如果硬件外部没有上拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>Pull-up</code> 内部上拉电阻。</p><p>如果不希望电平跳变事件触发中断，就配置为事件模式，反之，配置为中断模式。</p><p>中断执行流程为先中断初始化，使用中断可以避免使用论询来检测，发生电平变化触发外部中断，进入中断服务函数，中断服务函数中会调用中断处理公用函数（使用cubemx会在stm32f1xx_it.c中自动生成），中断处理公用函数中会检测标志位，并清零执行回调函数，终端中要执行的事情就放入中断回调函数中。</p><p>可以在stm32f1xx_it.c中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 0 */</span></span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go to Defnition of HAL_GPIO_EXTI_IRQHandler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断并清除中断标志位，然后调用HAL_GPIO_EXTI_Callback(GPIO_Pin);处理中断，同样的方式找到HAL_GPIO_EXTI_Callback的定义，你可以看到这个函数的声明前面有一个__weak声明，这个声明表示这个函数一旦被重新声明，这里的函数就自动失效，其他函数调用的时候就会找到你新定义的同名函数。</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。串口通讯有很多标准，以下是RS-232标准</p><p><a href="https://postimg.cc/zHmFByDH"><img src="https://i.postimg.cc/d33H5Cz6/2022-09-30-200343.png" alt="2022-09-30-200343.png"></a></p><p>由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平标准不同分为TTL标准和RS232电平标准</p><p><a href="https://postimg.cc/LhHzyFYp"><img src="https://i.postimg.cc/2jW2SzCV/2022-09-30-201456.png" alt="2022-09-30-201456.png"></a></p><p><a href="https://postimg.cc/MXCz6q7k"><img src="https://i.postimg.cc/zXBvkf3f/2022-09-30-201723.png" alt="2022-09-30-201723.png"></a></p><p>通用同步异步收发器 (Universal Synchronous Asynchronous Receiver and Transmitter) 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个 UART(UniversalAsynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p><p>串口通信有三种方式，分别为论询方式、中断方式、DMA方式。串口的通讯协议由开始位，数据位，校验位，结束位构成。一般以一个低电平作为一帧数据的起始，接着跟随 8 位或者 9 位数据位，之后为校验位，分为奇校验，偶校验和无校验，最后以一个先高后低的脉冲表示结束位，长度可以设置为 0.5，1，1.5 或 2 位长度。</p><p>当使用校验位时，串口传输的长度将是 8 位的数据帧加上 1 位的校验位总共 9 位，此时 USART_CR1 寄存器的 M 位需要设置为 1，即 9 数据位。将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收<br>数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位 + 数据帧 + 校验位 + 停止位</p><p>​      什么是硬件流控呢？流控的概念源于 RS232 这个标准，在 RS232 标准里面包含了串口、流控的定义。大家一定了解，RS232 中的“RS”是Recommend Standard 的缩写，即”推荐标准“之意，它并不像 IEEE-1284、IEEE-1394 等标准，是由“委员会定制”。因而，不同的厂商在做 RS232 时，多少会有不同，流控也都会存在差异。</p><p>为什么需要流控?</p><p>　　数据在两个串口之间进行通讯的时候常常会出现丢失数据的现象，比如两台计算机或者是一台计算机和一个单片机之间进行通讯，当接收端的数据缓冲区已经满了，这个时候如果还有数据发送过来，因为接收端没有时间进行处理，那这样的数据就有可能会丢失。在工业现场或者其他领域，经常会遇到这种问题，本质原因是速度不匹配、处理能力不匹配。比如单片机的主频只有20M或30M，ARM的处理能力可能是200M，PC机的处理能力是几个G，这种处理能力的不匹配造成了传输的时候数据容易丢失。</p><p>　　硬件流控就是来解决这个速度匹配的问题。它的基本含义非常简单，当接收端接收到的数据处理不过来时，就向发送端发送不再接收的信号，发送端接收到这个信号之后就会停止发送，直到收到可以继续发送的信号再继续发送。因此流控本身是可以控制数据传输的进度，进而防止数据丢失。</p><p>　　一般常用的流控方式有两种：硬件流控和软件流控。</p><p>​硬件流控和软件流控的区别</p><p>　　软件流控是以特殊的字符来代表从机已经不能再接收新的数据了，基本的流程就是从机在接收数据很多的时候或主动给发送端发送一个特殊字符，当发送端接收到这个特殊字符后就不能再发送数据了。</p><p>　　软件流控很方便，不需要增加新的硬件，还是以前的TX、RX，但是使用了软件流控，它本身的字符也是数据，这个数据只不过是说在软件里把它设置了一个特殊的含义。如果它是一个全双工的通讯，在给另一个串口发送数据的时候如果也包含了这样一个特殊字符，对方就会误以为我让它不要再发送数据了，会有一定的概率出现错误，而硬件流控就不需要考虑这方面，只需要使用 CTS 和 RTS，所有的数据都是由硬件来操作的。具体可以看<a href="https://www.cnblogs.com/923327iu/p/12159551.html#:~:text=STM32%20%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%20DE%20%E7%AE%A1%E8%84%9A%E5%92%8C%20RS485%20%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E8%8A%AF%E7%89%87%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E5%8F%91%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%E5%9C%A8,STM32%20%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E4%B8%AD%E5%85%B6%E5%AE%9E%E5%8C%85%E5%90%AB%E4%B8%A4%E6%96%B9%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%20RS232%20%E7%9A%84%20CTS%E3%80%81RTS%3B%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%AE%83%E6%98%AF%E5%9F%BA%E4%BA%8E%20RS485%20%E7%9A%84%EF%BC%8C%E5%9C%A8%E8%BD%AF%E4%BB%B6">stm32串口USART 硬件流控 –学习笔记 - 国产零零柒 - 博客园 (cnblogs.com)</a></p><p><a href="https://postimg.cc/8F1VsbPM"><img src="https://i.postimg.cc/nLmVRdyR/2022-09-30-205236.png" alt="2022-09-30-205236.png"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">HAL_UART_Transmit();串口轮询模式发送，使用超时管理机制</span><br><span class="line">HAL_UART_Receive();串口轮询模式接收，使用超时管理机制</span><br><span class="line">HAL_UART_Transmit_IT();串口中断模式发送</span><br><span class="line">HAL_UART_Receive_IT();串口中断模式接收</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式发送</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式接收</span><br><span class="line"><span class="number">2</span>、阻塞传输是调用这个函数并在等待时间内一直等待操作完成。</span><br><span class="line">HAL_UART_Transmit</span><br><span class="line">HAL_UART_Receive</span><br><span class="line">查询的方式一般少用，这里不做过多介绍。</span><br><span class="line"><span class="number">3</span>、串口中断</span><br><span class="line">串口中断函数</span><br><span class="line">HAL_UART_TxHalfCpltCallback();一半数据发送完成时调用</span><br><span class="line">HAL_UART_TxCpltCallback();数据完全发送完成后调用</span><br><span class="line">HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用</span><br><span class="line">HAL_UART_RxCpltCallback();数据完全接受完成后调用</span><br><span class="line">HAL_UART_ErrorCallback();传输出现错误时调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/119029425">(具体配置) 【STM32】HAL库——串口中断通信(二)_Q大帅的博客-CSDN博客_hal 串口中断</a></p><p>当printf打印不好使时是因为工程中没有选Micro USB</p><p><a href="https://postimg.cc/Z9kXMvXH"><img src="https://i.postimg.cc/XvX3Xw8R/2022-10-04-193120.png" alt="2022-10-04-193120.png"></a></p><p><a href="https://blog.csdn.net/zxt510001/article/details/125892562">() STM32 HAL库串口串口通信基础知识+HAL库代码理解</a></p><h2 id="DMA-直接存储访问"><a href="#DMA-直接存储访问" class="headerlink" title="DMA-直接存储访问"></a>DMA-直接存储访问</h2><p>DMA是单片机外设，不占用CPU，传输数据时候CPU可以做别的。如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求，DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。DMA有12个可独立编程通道，每个通道对应不同的外设DMA请求，可以接受多个请求，但同时只能接受一个。仲裁器，处理响应顺序的问题，分为软件阶段和硬件阶段，可以在 DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高。</p><p>MA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。具体的方向 DMA_CCR 位 4 DIR 配置：0 表示从外设到存储器，1 表示从存储器到外设。</p><p>更多原理可参看<a href="https://blog.csdn.net/as480133937/article/details/104927922"> DMA原理</a></p><p>在cubemx的配置只需要加上相应设备的DMA模式便可以生成代码进行使用。</p><p>I2C协议</p><p>首先分为物理层和协议层，两方面来看。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</p><p>一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p><p> 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p><p>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p><p>具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p><h4 id="协议层："><a href="#协议层：" class="headerlink" title="协议层："></a>协议层：</h4><p>I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p><p>S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。<br>起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7位或 10 位。在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收<br>到应答信号后，主机才能继续发送或接收数据。</p><p>若是传输为写数据方向，接收到应答信号后，主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位那么主机每发送完一个字节数据，都要等待从机的应答信号 (ACK)。</p><p>若配置的方向传输位为“读数据”方向，接收到应答信号后，从机开始向主机返回数据 (DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png"><img src="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png" alt="SDA.png"></a></p><h5 id="SCL处于1时-SDA由高变低↓—-gt-Start"><a href="#SCL处于1时-SDA由高变低↓—-gt-Start" class="headerlink" title="SCL处于1时, SDA由高变低↓—&gt;Start"></a>SCL处于1时, SDA由高变低↓—&gt;Start</h5><h5 id="图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高"><a href="#图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高" class="headerlink" title="图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高"></a>图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高</h5><h5 id="数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化"><a href="#数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化" class="headerlink" title="数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;"></a>数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;</h5><p><a href="%5B(88%E6%9D%A1%E6%B6%88%E6%81%AF"> IIchal相关函数分析</a> <a href="https://blog.csdn.net/kouxi1/article/details/123834448?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32hal%E5%BA%93iic&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-123834448.142%5Ev52%5Econtrol,201%5Ev3%5Econtrol&spm=1018.2226.3001.4187">015] [STM32] IIC协议详解与HAL库相关函数分析_柯西的彷徨的博客-CSDN博客</a>)</p><h2 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h2><p>SPI是一种高速全双工的通信总线</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>SPI 通讯使用 3 条总线及片选线，3 条总线分别为 SCK、MOSI、MISO，片选线</p><p>从设备选择信号线，常称为片选信号线，也称为 NSS、CS设备的其它信号线 SCK、MOSI 及 MIS O 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</p><p>SCK ：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样。<br> MOSI ：主设备输出&#x2F;从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。<br>MISO(Master Input,，Slave Output)：主设备输入&#x2F;从设备输出引脚。主机从这条信线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png"><img src="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png" alt="屏幕截图 2022-10-11 214647.png"></a></p><p>NSS 信号线由高变低，是 SPI 通讯的起始信号。NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。</p><p>观察图中的标号处，MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻，MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI 及 MISO 为下一次表示数据做准备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言算法项</title>
      <link href="/2022/10/07/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/"/>
      <url>/2022/10/07/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正三角-反三角"><a href="#正三角-反三角" class="headerlink" title="正三角(反三角)"></a>正三角(反三角)</h3><p>使用为两个for循环进行嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">6</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;a;b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><p>使用为四个for进行循环思想核心为中间数量为行数n的两倍减去1，外层循环控制换行，内层三个控制空格以及他的打印数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rows,i,j,space,star;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; rows);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         star = <span class="number">2</span>*i <span class="number">-1</span> ;     <span class="comment">//星号个数</span></span><br><span class="line">         space = rows - i;   <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//左边空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;star;++j)       <span class="comment">//中间 *</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//右边空格有没有都可以</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, space, rows, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter number of rows: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rows);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=rows; ++i, k=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(space=<span class="number">1</span>; space&lt;=rows-i; ++space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断一个数字是否素数</p><p>判断一个数字是否能被比他小的数整除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;x;i++)</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//一旦判断不是，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==x) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);<span class="comment">//如果是的话，for循环一定执行到了i=x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C语言二分查找"><a href="#C语言二分查找" class="headerlink" title="C语言二分查找"></a>C语言二分查找</h3><p>找到最左边元素（low）和最右边元素（high），确定中间元素（mid），比较中间元素（mid）和目标元素（k）的大小，调整low和high，再确定新的mid….我们要不断确定mid直到找到k，自然需要用到循环，我们有明确的目标：找到k。因此选择while循环，找到k后循环不再进行，而当low和high之间还有元素，即low在high的左边或与之重合，k就依然可能存在，所以循环条件为low&lt;&#x3D;high，接下来的问题在于怎样调整low和high的值，mid和k比较无非就三种情况：mid&lt;k，mid&gt;k,mid&#x3D;k。第一种情况，k在mid的右边，我们将low调整为mid+1，high不用调整；第二种情况，k在mid的左边，我们将high调整为mid-1，low不用调整。最后一种情况最简单，我们已经找到了k，直接将mid打印出来就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bin_Search</span><span class="params">(<span class="type">int</span> *num,<span class="type">int</span> cnt,<span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first = <span class="number">0</span>,last = cnt<span class="number">-1</span>,mid;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first &lt;= last)</span><br><span class="line">&#123;</span><br><span class="line">counter ++;</span><br><span class="line">mid = (first + last) / <span class="number">2</span>;<span class="comment">//确定中间元素</span></span><br><span class="line"><span class="keyword">if</span>(num[mid] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">last = mid<span class="number">-1</span>; <span class="comment">//mid已经交换过了,last往前移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">first = mid+<span class="number">1</span>;<span class="comment">//mid已经交换过了,first往后移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//判断是否相等</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>,target;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您要查找的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;target);</span><br><span class="line">flag = Bin_Search(num,<span class="number">10</span>,target);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;已经找到该数字!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无该数字!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(三)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><u><strong>目录选项</strong></u></p><p>下列选项指定搜索路径，用于查头文件、库文件或编译器的某些成员。</p><p>(1)-Idir</p><p>在头文件的搜索路径列表中添加敌人目录。</p><p>(2)-I-</p><p>任何在“-I-” 前面用来指定的搜索路径只适用于“#include“file” ”这种情况，不适用于“#include&lt;stdio.h&gt;”</p><p>用-I-选项指定的搜索路径位于“-I-”选项后面，就可以搜索所有的#include指令</p><p>(3)-Ldir</p><p>在“-I”选项的搜索路径列表中添加dier目录。</p><p>(4)-Bprefix</p><p>这个选项指出在何处寻找可执行文件、库文件以及编译器自己的数据文件。编译器驱动程序需要使用某些工具，比如： cpp 、 ccl （或 C +＋的 cclplus )、 as 和 ld 。它把 prefix 当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。</p><p>对于要运行的工具，编译器驱动程序首先试着加上“- B ”前缀（如果存在），如果没有找到文件或没有指定“- B ”选项，编译器接着会试验两个标准前缀 usr &#x2F; lib &#x2F; gcc ／和&#x2F; usr &#x2F; local &#x2F; lib &#x2F; gcc - lib &#x2F;。如果仍然没能够找到所需文件，编译器就在“ PATH ”环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时（ run - time ）支持文件 libgcc . a 也在“- B ”前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找。如果上述方法没有找到这个文件，就不连接它了。多数情况的多数机器上， libgcc . a 并非必不可少。可以通过环境变量 GCCEXEC PREFIX 获得近似的效果：如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了“- B ”选项和 GCC EXEC _ PREFIX 变量，编译器首先使用“- B ”选项，然后才尝试环境变量值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(二)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>连接器选项</strong></p><p>（1）object-file-name</p><p>文件没有特别明确后缀，使用如下操作，obj文件可以变成连接器的输入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o  ,main.o和sub.o就是输入文件</span><br></pre></td></tr></table></figure><p>（2）-llibrary</p><p>连接名为library的库文件，这个方法找到的是库文件——即由OBJ文件组成的归档文件</p><p>（3）-nostartfiles</p><p>不连接系统标准启动文件，而标准库文件仍能正常启动</p><p>（4）-nostdlib</p><p>不连接系统标准启动文件和标准库文件，只把指定文件传递给连接器。仍以options程序作为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure><p>(5)-static</p><p>在支持动态连接的系统上阻止连接共享库</p><p>(6)-shared</p><p>生成一个共享OBJ文件，它可以和其他的OBJ文件连接产生可执行文件，只有部分系统支持，</p><p>不想用源代码发布程序时可以用它来生成库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line"></span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure><p>以后要使用sub.c 中的函数sub_fun时，连接程序时，将sub.a加入就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure><p>也可以多个文件作为一个库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub .o sub2.o sub3.o</span><br></pre></td></tr></table></figure><p>(7)-Xlinker opion</p><p>把选项option传递给连接器。可以用来传递系统特定的连接选项，gcc无法识别这些选项。必须使用两次-Xlinker，一次传递选项，另一次传递其他参数。</p><p>(8)-Wl,option</p><p>把选项option传递给连接器。如果option中有逗号，就在逗号处分割成多个选项。</p><p>(9)-u symbol</p><p>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义可以使用多个-u选项各自跟上不同的符号，使得连接器调入附加的库模块。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(一)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ cd 目标文件夹名称                 导向目标文件夹所在终端</span><br><span class="line"></span><br><span class="line">~$ touch hel                               创建一个叫hel的文件</span><br><span class="line"></span><br><span class="line">~$ gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span><br><span class="line"></span><br><span class="line">~$ gcc hel.c -o test                    编译hel.c为test可执行文件</span><br><span class="line"></span><br><span class="line">~$ ./test                                     执行test可执行文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ gcc -Wll -c hello.c</span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><a href="https://postimg.cc/KK9hg8zb"><img src="https://i.postimg.cc/XJWjmZ6r/yi.png" alt="yi.png"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32系统学习</title>
      <link href="/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>stm32主系统由四个去驱动单元和四个被动单元构成。</strong></p><p>四个驱动是内核DCode总线；系统总线；通用DMA1；通用DMA2</p><p>四被动单元是AHB到APB的桥：连接所有APB的设备；内存FLASH；内部SRAM；FSMC</p><p>① ICode 总线：该总线将 M3 内核指令总线和闪存指令接口相连，指令的预取在该总线上<br>面完成。<br>② DCode 总线：该总线将 M3 内核的 DCode 总线与闪存存储器的数据接口相连接，常量<br>加载和调试访问在该总线上面完成。<br>③ 系统总线：该总线连接 M3 内核的系统总线到总线矩阵，总线矩阵协调内核和 DMA 间<br>访问。<br>④ DMA 总线：该总线将 DMA 的 AHB 主控接口与总线矩阵相连，总线矩阵协调 CPU 的<br>DCode 和 DMA 到 SRAM,闪存和外设的访问。<br>⑤ 总线矩阵：总线矩阵协调内核系统总线和 DMA 主控总线之间的访问仲裁，仲裁利用<br>轮换算法。<br>⑥ AHB&#x2F;APB 桥:这两个桥在 AHB 和 2 个 APB 总线间提供同步连接，APB1 操作速度限于<br>36MHz,APB2 操作速度全速。</p><p><strong>stm32的5个时钟源</strong></p><p>用来配置时钟树</p><p>①HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。<br>②HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz到16MHz。<br>③LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同<br>时 LSI 还可以作为 RTC 的时钟源。<br>④LSE 是低速外部时钟，使用频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>⑤PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2到16 倍，但是其输出频率最大不得超过 72MHz。</p><p>程序执行顺序</p><p><a href="https://postimg.cc/68vJqYZh"><img src="https://i.postimg.cc/2SHzHt8g/liucheng.png" alt="liucheng.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用ｆｌａｓｈ，使用串口下载，或者可以选择使用SWD</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm-linux -ld、-objcopy和obdump</title>
      <link href="/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/"/>
      <url>/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/</url>
      
        <content type="html"><![CDATA[<p><strong>arm-linux-ld用于将多个目标文件、库文件连接成可执行文件。</strong></p><p>-T 直接指定代码段、数据段、bss段的起始地址,只用于连接Bootloader、内核等没有底层软件支持的软件</p><p>连接操作系统应用程序时候，无需-T，默认连接。</p><p>1.直接指定代码段、数据段、bss段的起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure><p>startaddr分别代表代码段、数据段、bss段的起始地址</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttext 0x000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure><p>代表代码段运行地址为0x000000，没有定义数据段、bss段起始地址所以被放入代码段的后面</p><p>2.使用连接脚本设置地址</p><p><strong>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可用不同于源文件的格式来输出目的文件，即可以进行格式转换。</strong></p><p>1、input-file、outfile分别是输入目标文件和输出目标文件，如果没有明确指定outfile，将创建一个临时文件来存放结果，用input-file的名字来命名。</p><p>2、 -l bfname或–input-target&#x3D;bfdname</p><p>用来指明源文件的格式，bfdname是BFD库描述的标准格式名，如果不指明格式，会自己分析源文件格式，去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</p><p>3、-O bfdname或–output-target&#x3D;bfdname</p><p>使用指定格式来输出文件，bdfname是BFD库中的标准格式名。</p><p><strong>arm-linux-objdump用于显示二进制文件信息</strong></p><p>未完待续。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32hal库</title>
      <link href="/2022/07/01/stm32hal%E5%BA%93/"/>
      <url>/2022/07/01/stm32hal%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>为方便使用，用typedef来给变量起名将以下放入main.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int16_t</span> s16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int8_t</span>  s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int32_t</span> sc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int16_t</span> sc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int8_t</span> sc8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int32_t</span>  vs32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int16_t</span>  vs16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int8_t</span>   vs8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int32_t</span> vsc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int16_t</span> vsc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int8_t</span> vsc8;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>  u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span>  u8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint32_t</span> uc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint16_t</span> uc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint8_t</span> uc8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint32_t</span>  vu32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint16_t</span> vu16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint8_t</span>  vu8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint32_t</span> vuc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint16_t</span> vuc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint8_t</span> vuc8;  </span><br></pre></td></tr></table></figure><p>点亮led</p><p>GPIO用IO口的输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);<span class="comment">//控制电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);<span class="comment">//翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOA, GPIO_Pin_8);<span class="comment">//读取电平</span></span><br></pre></td></tr></table></figure><p>点亮led就需要按键了，按键首先要看按键的引脚设置IO口为输入模式，写一个案件处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line"> <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>; <span class="comment">//支持连按</span></span><br><span class="line"> <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>);</span><br><span class="line"> key_up=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="keyword">return</span> KEY1_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">ALIENTEK MiniSTM32 V3<span class="number">.0</span> 开发板教程</span><br><span class="line"><span class="number">137</span></span><br><span class="line">STM32 不完全手册(HAL 库版)</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中进行添加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5) <span class="comment">//KEY0 按键 PC5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15) <span class="comment">//KEY1 按键 PA15</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) <span class="comment">//WKUP 按键 PA0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES 3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>串口通信</p><p>usart和uart区别为 usart比uart多了同步时钟频率通信，都有异步时钟通信。</p><p>串口设置的一般步骤可以总结为如下几个步骤：</p><ol><li>串口时钟使能，GPIO 时钟使能。</li><li>设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</li><li>GPIO 初始化设置：要设置模式为复用功能。</li><li>串口参数初始化：设置波特率，字长，奇偶校验等参数。</li><li>开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</li><li>使能串口。</li><li>编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</li></ol><p>串口通信的结构体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> uint32_t BaudRate; //波特率</span><br><span class="line"> uint32_t WordLength; //字长</span><br><span class="line"> uint32_t StopBits; //停止位</span><br><span class="line"> uint32_t Parity; //奇偶校验</span><br><span class="line"> uint32_t Mode; //收/发模式设置</span><br><span class="line"> uint32_t HwFlowCtl; //硬件流设置</span><br><span class="line"> uint32_t OverSampling; //过采样设置</span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的学习</title>
      <link href="/2022/06/30/makefile/"/>
      <url>/2022/06/30/makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tieba.baidu.com/p/591519800">Makefile详解（超级好）【mingw吧】_百度贴吧 (baidu.com)</a></p><p>上面挂一个较好的makefile的教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/03/hello-world/"/>
      <url>/2022/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
