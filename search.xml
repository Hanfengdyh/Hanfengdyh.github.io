<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言学习过程中的问题</title>
      <link href="/2022/10/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/10/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="1-scanf输入问题-输入缓冲区"><a href="#1-scanf输入问题-输入缓冲区" class="headerlink" title="1.scanf输入问题-输入缓冲区"></a>1.scanf输入问题-输入缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"><span class="keyword">while</span>(b == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会得到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a<span class="comment">//输入a</span></span><br><span class="line"><span class="number">0</span>?a1?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是因为scanf()函数会把回车、空格、Tab或一些不合理输入的字符当作此次输入的结束标志，它不会把这些字符输入到想要保存此次输入数据的变量中，而是把这些字符遗留在了输入缓冲区，那么，当下一次想要从标准输入中读取一个字符时，这个遗留的字符就正好充当了此次的输入字符。</p><p>程序在输入a后输入了回车来结束此次输入，那么回车就遗留在了输入缓冲区，当需要给c输入字符时，它自动的充当了输入的字符，因此，程序没有给我们输入c的字符的机会。</p><p>C语言为了解决这种问题，为我们提供了一种很方便的清空输入缓冲区的方式—-&gt;&gt;fflush()函数，它会把残留在输入缓冲区里的所有数据清空。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32实战篇</title>
      <link href="/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实战第一篇跑马灯"><a href="#实战第一篇跑马灯" class="headerlink" title="实战第一篇跑马灯"></a>实战第一篇跑马灯</h2><p>第一篇没什么好说的，没什么新鲜的东西，就是使用cubemx进行建立工程，新建led.c和led.h文件，对引脚进行赋予高低电平，此次不一样的是在led.h文件中对相应的IO口用英文做了宏定义，防止以后进行重复混乱调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_PIN         GPIO_PIN_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT   GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_PIN         GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT   GPIOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="实战第二篇按键检测"><a href="#实战第二篇按键检测" class="headerlink" title="实战第二篇按键检测"></a>实战第二篇按键检测</h2><h4 id="硬件消抖"><a href="#硬件消抖" class="headerlink" title="硬件消抖"></a>硬件消抖</h4><p>首先是硬件的设计，按下按键不会立即响应，有波纹信号，不方便检测需要进行滤波消抖。可以利用电容的放电延迟达到消除抖动的目的，这样只需要检测引脚的电平。</p><p><a href="https://postimg.cc/62dPcFkc"><img src="https://i.postimg.cc/hjwqDBMk/2022-09-27-181925.png" alt="2022-09-27-181925.png"></a></p><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><p>当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才的状态相同，就是稳定了，但是有局限性。</p><p>查询相关IO口在cubemx中进行设置为输入状态。由于引脚的默认电平受按键电路影响，所以设置成“浮空&#x2F;上拉&#x2F;下拉”模式均没有区别。</p><p>arm汇编指令集</p><p><a href="https://postimg.cc/v413R6K1"><img src="https://i.postimg.cc/zG7MgCSk/2022-09-27-202146.png" alt="2022-09-27-202146.png"></a></p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大<br>小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你<br>写的程序出现了莫名奇怪的错误，并进入了硬 fault 的时候，这时你就要考虑下是不是栈不够大，<br>溢出了。堆主要用来动态内存的分配</p><h2 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h2><p>设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决<br>定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 等于多少）、设置各个外设的分频因子；<br>控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。</p><p>一般是：PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M，<br>               PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M</p><p>HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当<br>使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从<br>OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。</p><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 APB 总线时钟，即 HCLK。</p><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到，HCLK2 属于高速的总线时钟，片上<br>高速的外设就挂载到这条总线上。APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，PCLK1 属于低速的总线时钟，最高为 36M，片上低速的外设就挂载到这条总线上，比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。</p><p>USB 时钟是由 PLLCLK 经过 USB 预分频器得到，USB 对时钟要求比较高，所以 PLLCLK 只能是由 HSE 倍频得到，不能使用 HSI 倍频。</p><p>ADC 时钟由 PCLK2 经过 ADC 预分频器得到。</p><p>RTC 时钟可由 HSE&#x2F;128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ，也可由<br>低速内部时钟信号LSI提供。独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供，LSI 是低速的内部时钟信号，频率为 30~60KHZ 直接不等，一般取 40KHZ。</p><h2 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h2><p>在 NVIC 有一个专门的寄存器：中断优先级寄存器 NVIC_IPRx，用来配置外部中断的优先级，IPR宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p><p>IRQn：用来设置中断源</p><p>PreemptionPriority：抢占优先级</p><p>SubPriority：子优先级</p><h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。</p><p>产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p><p>cubemx进行引脚配置，对相应的IO引脚选择GPIO_EXITx,xi表示挂载在中断线几，如GPIO_EXTI0就是挂在中断线0上。</p><p>开启下降沿触发中断：即在 <strong>按下按键时</strong> 电平由高变为低时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Falling edge trigger detection</code> </p><p>开启上升沿触发中断：即在 <strong>按下按键后松开时</strong> 电平由低变为高时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising edge trigger detection</code> </p><p>开启下降沿上升沿都触发中断：即在 <strong>按下时触发，松开时再次触发</strong>，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising/Falling edge trigger detection</code></p><p>如果硬件上已外部上拉或下拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>No pull-up and no pull-down</code> 既不上拉也不下拉。</p><p>如果硬件外部没有上拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>Pull-up</code> 内部上拉电阻。</p><p>如果不希望电平跳变事件触发中断，就配置为事件模式，反之，配置为中断模式。</p><p>中断执行流程为先中断初始化，使用中断可以避免使用论询来检测，发生电平变化触发外部中断，进入中断服务函数，中断服务函数中会调用中断处理公用函数（使用cubemx会在stm32f1xx_it.c中自动生成），中断处理公用函数中会检测标志位，并清零执行回调函数，终端中要执行的事情就放入中断回调函数中。</p><p>可以在stm32f1xx_it.c中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 0 */</span></span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go to Defnition of HAL_GPIO_EXTI_IRQHandler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断并清除中断标志位，然后调用HAL_GPIO_EXTI_Callback(GPIO_Pin);处理中断，同样的方式找到HAL_GPIO_EXTI_Callback的定义，你可以看到这个函数的声明前面有一个__weak声明，这个声明表示这个函数一旦被重新声明，这里的函数就自动失效，其他函数调用的时候就会找到你新定义的同名函数。</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。串口通讯有很多标准，以下是RS-232标准</p><p><a href="https://postimg.cc/zHmFByDH"><img src="https://i.postimg.cc/d33H5Cz6/2022-09-30-200343.png" alt="2022-09-30-200343.png"></a></p><p>由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平标准不同分为TTL标准和RS232电平标准</p><p><a href="https://postimg.cc/LhHzyFYp"><img src="https://i.postimg.cc/2jW2SzCV/2022-09-30-201456.png" alt="2022-09-30-201456.png"></a></p><p><a href="https://postimg.cc/MXCz6q7k"><img src="https://i.postimg.cc/zXBvkf3f/2022-09-30-201723.png" alt="2022-09-30-201723.png"></a></p><p>通用同步异步收发器 (Universal Synchronous Asynchronous Receiver and Transmitter) 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个 UART(UniversalAsynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p><p>串口通信有三种方式，分别为论询方式、中断方式、DMA方式。串口的通讯协议由开始位，数据位，校验位，结束位构成。一般以一个低电平作为一帧数据的起始，接着跟随 8 位或者 9 位数据位，之后为校验位，分为奇校验，偶校验和无校验，最后以一个先高后低的脉冲表示结束位，长度可以设置为 0.5，1，1.5 或 2 位长度。</p><p>当使用校验位时，串口传输的长度将是 8 位的数据帧加上 1 位的校验位总共 9 位，此时 USART_CR1 寄存器的 M 位需要设置为 1，即 9 数据位。将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收<br>数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位 + 数据帧 + 校验位 + 停止位</p><p>​      什么是硬件流控呢？流控的概念源于 RS232 这个标准，在 RS232 标准里面包含了串口、流控的定义。大家一定了解，RS232 中的“RS”是Recommend Standard 的缩写，即”推荐标准“之意，它并不像 IEEE-1284、IEEE-1394 等标准，是由“委员会定制”。因而，不同的厂商在做 RS232 时，多少会有不同，流控也都会存在差异。</p><p>为什么需要流控?</p><p>　　数据在两个串口之间进行通讯的时候常常会出现丢失数据的现象，比如两台计算机或者是一台计算机和一个单片机之间进行通讯，当接收端的数据缓冲区已经满了，这个时候如果还有数据发送过来，因为接收端没有时间进行处理，那这样的数据就有可能会丢失。在工业现场或者其他领域，经常会遇到这种问题，本质原因是速度不匹配、处理能力不匹配。比如单片机的主频只有20M或30M，ARM的处理能力可能是200M，PC机的处理能力是几个G，这种处理能力的不匹配造成了传输的时候数据容易丢失。</p><p>　　硬件流控就是来解决这个速度匹配的问题。它的基本含义非常简单，当接收端接收到的数据处理不过来时，就向发送端发送不再接收的信号，发送端接收到这个信号之后就会停止发送，直到收到可以继续发送的信号再继续发送。因此流控本身是可以控制数据传输的进度，进而防止数据丢失。</p><p>　　一般常用的流控方式有两种：硬件流控和软件流控。</p><p>​硬件流控和软件流控的区别</p><p>　　软件流控是以特殊的字符来代表从机已经不能再接收新的数据了，基本的流程就是从机在接收数据很多的时候或主动给发送端发送一个特殊字符，当发送端接收到这个特殊字符后就不能再发送数据了。</p><p>　　软件流控很方便，不需要增加新的硬件，还是以前的TX、RX，但是使用了软件流控，它本身的字符也是数据，这个数据只不过是说在软件里把它设置了一个特殊的含义。如果它是一个全双工的通讯，在给另一个串口发送数据的时候如果也包含了这样一个特殊字符，对方就会误以为我让它不要再发送数据了，会有一定的概率出现错误，而硬件流控就不需要考虑这方面，只需要使用 CTS 和 RTS，所有的数据都是由硬件来操作的。具体可以看<a href="https://www.cnblogs.com/923327iu/p/12159551.html#:~:text=STM32%20%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%20DE%20%E7%AE%A1%E8%84%9A%E5%92%8C%20RS485%20%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E8%8A%AF%E7%89%87%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E5%8F%91%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%E5%9C%A8,STM32%20%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E4%B8%AD%E5%85%B6%E5%AE%9E%E5%8C%85%E5%90%AB%E4%B8%A4%E6%96%B9%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%20RS232%20%E7%9A%84%20CTS%E3%80%81RTS%3B%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%AE%83%E6%98%AF%E5%9F%BA%E4%BA%8E%20RS485%20%E7%9A%84%EF%BC%8C%E5%9C%A8%E8%BD%AF%E4%BB%B6">stm32串口USART 硬件流控 –学习笔记 - 国产零零柒 - 博客园 (cnblogs.com)</a></p><p><a href="https://postimg.cc/8F1VsbPM"><img src="https://i.postimg.cc/nLmVRdyR/2022-09-30-205236.png" alt="2022-09-30-205236.png"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">HAL_UART_Transmit();串口轮询模式发送，使用超时管理机制</span><br><span class="line">HAL_UART_Receive();串口轮询模式接收，使用超时管理机制</span><br><span class="line">HAL_UART_Transmit_IT();串口中断模式发送</span><br><span class="line">HAL_UART_Receive_IT();串口中断模式接收</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式发送</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式接收</span><br><span class="line"><span class="number">2</span>、阻塞传输是调用这个函数并在等待时间内一直等待操作完成。</span><br><span class="line">HAL_UART_Transmit</span><br><span class="line">HAL_UART_Receive</span><br><span class="line">查询的方式一般少用，这里不做过多介绍。</span><br><span class="line"><span class="number">3</span>、串口中断</span><br><span class="line">串口中断函数</span><br><span class="line">HAL_UART_TxHalfCpltCallback();一半数据发送完成时调用</span><br><span class="line">HAL_UART_TxCpltCallback();数据完全发送完成后调用</span><br><span class="line">HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用</span><br><span class="line">HAL_UART_RxCpltCallback();数据完全接受完成后调用</span><br><span class="line">HAL_UART_ErrorCallback();传输出现错误时调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/119029425">(具体配置) 【STM32】HAL库——串口中断通信(二)_Q大帅的博客-CSDN博客_hal 串口中断</a></p><p>当printf打印不好使时是因为工程中没有选Micro USB</p><p><a href="https://postimg.cc/Z9kXMvXH"><img src="https://i.postimg.cc/XvX3Xw8R/2022-10-04-193120.png" alt="2022-10-04-193120.png"></a></p><p><a href="https://blog.csdn.net/zxt510001/article/details/125892562">() STM32 HAL库串口串口通信基础知识+HAL库代码理解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言算法项</title>
      <link href="/2022/10/07/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/"/>
      <url>/2022/10/07/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>正三角(反三角)</p><p>使用为两个for循环进行嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">6</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;a;b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>金字塔</p><p>使用为四个for进行循环思想核心为中间数量为行数n的两倍减去1，外层循环控制换行，内层三个控制空格以及他的打印数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rows,i,j,space,star;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; rows);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         star = <span class="number">2</span>*i <span class="number">-1</span> ;     <span class="comment">//星号个数</span></span><br><span class="line">         space = rows - i;   <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//左边空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;star;++j)       <span class="comment">//中间 *</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//右边空格有没有都可以</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, space, rows, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter number of rows: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rows);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=rows; ++i, k=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(space=<span class="number">1</span>; space&lt;=rows-i; ++space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(三)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><u><strong>目录选项</strong></u></p><p>下列选项指定搜索路径，用于查头文件、库文件或编译器的某些成员。</p><p>(1)-Idir</p><p>在头文件的搜索路径列表中添加敌人目录。</p><p>(2)-I-</p><p>任何在“-I-” 前面用来指定的搜索路径只适用于“#include“file” ”这种情况，不适用于“#include&lt;stdio.h&gt;”</p><p>用-I-选项指定的搜索路径位于“-I-”选项后面，就可以搜索所有的#include指令</p><p>(3)-Ldir</p><p>在“-I”选项的搜索路径列表中添加dier目录。</p><p>(4)-Bprefix</p><p>这个选项指出在何处寻找可执行文件、库文件以及编译器自己的数据文件。编译器驱动程序需要使用某些工具，比如： cpp 、 ccl （或 C +＋的 cclplus )、 as 和 ld 。它把 prefix 当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。</p><p>对于要运行的工具，编译器驱动程序首先试着加上“- B ”前缀（如果存在），如果没有找到文件或没有指定“- B ”选项，编译器接着会试验两个标准前缀 usr &#x2F; lib &#x2F; gcc ／和&#x2F; usr &#x2F; local &#x2F; lib &#x2F; gcc - lib &#x2F;。如果仍然没能够找到所需文件，编译器就在“ PATH ”环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时（ run - time ）支持文件 libgcc . a 也在“- B ”前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找。如果上述方法没有找到这个文件，就不连接它了。多数情况的多数机器上， libgcc . a 并非必不可少。可以通过环境变量 GCCEXEC PREFIX 获得近似的效果：如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了“- B ”选项和 GCC EXEC _ PREFIX 变量，编译器首先使用“- B ”选项，然后才尝试环境变量值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(二)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>连接器选项</strong></p><p>（1）object-file-name</p><p>文件没有特别明确后缀，使用如下操作，obj文件可以变成连接器的输入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o  ,main.o和sub.o就是输入文件</span><br></pre></td></tr></table></figure><p>（2）-llibrary</p><p>连接名为library的库文件，这个方法找到的是库文件——即由OBJ文件组成的归档文件</p><p>（3）-nostartfiles</p><p>不连接系统标准启动文件，而标准库文件仍能正常启动</p><p>（4）-nostdlib</p><p>不连接系统标准启动文件和标准库文件，只把指定文件传递给连接器。仍以options程序作为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure><p>(5)-static</p><p>在支持动态连接的系统上阻止连接共享库</p><p>(6)-shared</p><p>生成一个共享OBJ文件，它可以和其他的OBJ文件连接产生可执行文件，只有部分系统支持，</p><p>不想用源代码发布程序时可以用它来生成库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line"></span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure><p>以后要使用sub.c 中的函数sub_fun时，连接程序时，将sub.a加入就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure><p>也可以多个文件作为一个库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub .o sub2.o sub3.o</span><br></pre></td></tr></table></figure><p>(7)-Xlinker opion</p><p>把选项option传递给连接器。可以用来传递系统特定的连接选项，gcc无法识别这些选项。必须使用两次-Xlinker，一次传递选项，另一次传递其他参数。</p><p>(8)-Wl,option</p><p>把选项option传递给连接器。如果option中有逗号，就在逗号处分割成多个选项。</p><p>(9)-u symbol</p><p>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义可以使用多个-u选项各自跟上不同的符号，使得连接器调入附加的库模块。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(一)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ cd 目标文件夹名称                 导向目标文件夹所在终端</span><br><span class="line"></span><br><span class="line">~$ touch hel                               创建一个叫hel的文件</span><br><span class="line"></span><br><span class="line">~$ gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span><br><span class="line"></span><br><span class="line">~$ gcc hel.c -o test                    编译hel.c为test可执行文件</span><br><span class="line"></span><br><span class="line">~$ ./test                                     执行test可执行文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ gcc -Wll -c hello.c</span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><a href="https://postimg.cc/KK9hg8zb"><img src="https://i.postimg.cc/XJWjmZ6r/yi.png" alt="yi.png"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32系统学习</title>
      <link href="/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>stm32主系统由四个去驱动单元和四个被动单元构成。</strong></p><p>四个驱动是内核DCode总线；系统总线；通用DMA1；通用DMA2</p><p>四被动单元是AHB到APB的桥：连接所有APB的设备；内存FLASH；内部SRAM；FSMC</p><p>① ICode 总线：该总线将 M3 内核指令总线和闪存指令接口相连，指令的预取在该总线上<br>面完成。<br>② DCode 总线：该总线将 M3 内核的 DCode 总线与闪存存储器的数据接口相连接，常量<br>加载和调试访问在该总线上面完成。<br>③ 系统总线：该总线连接 M3 内核的系统总线到总线矩阵，总线矩阵协调内核和 DMA 间<br>访问。<br>④ DMA 总线：该总线将 DMA 的 AHB 主控接口与总线矩阵相连，总线矩阵协调 CPU 的<br>DCode 和 DMA 到 SRAM,闪存和外设的访问。<br>⑤ 总线矩阵：总线矩阵协调内核系统总线和 DMA 主控总线之间的访问仲裁，仲裁利用<br>轮换算法。<br>⑥ AHB&#x2F;APB 桥:这两个桥在 AHB 和 2 个 APB 总线间提供同步连接，APB1 操作速度限于<br>36MHz,APB2 操作速度全速。</p><p><strong>stm32的5个时钟源</strong></p><p>用来配置时钟树</p><p>①HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。<br>②HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz到16MHz。<br>③LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同<br>时 LSI 还可以作为 RTC 的时钟源。<br>④LSE 是低速外部时钟，使用频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>⑤PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2到16 倍，但是其输出频率最大不得超过 72MHz。</p><p>程序执行顺序</p><p><a href="https://postimg.cc/68vJqYZh"><img src="https://i.postimg.cc/2SHzHt8g/liucheng.png" alt="liucheng.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用ｆｌａｓｈ，使用串口下载，或者可以选择使用SWD</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm-linux -ld、-objcopy和obdump</title>
      <link href="/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/"/>
      <url>/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/</url>
      
        <content type="html"><![CDATA[<p><strong>arm-linux-ld用于将多个目标文件、库文件连接成可执行文件。</strong></p><p>-T 直接指定代码段、数据段、bss段的起始地址,只用于连接Bootloader、内核等没有底层软件支持的软件</p><p>连接操作系统应用程序时候，无需-T，默认连接。</p><p>1.直接指定代码段、数据段、bss段的起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure><p>startaddr分别代表代码段、数据段、bss段的起始地址</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttext 0x000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure><p>代表代码段运行地址为0x000000，没有定义数据段、bss段起始地址所以被放入代码段的后面</p><p>2.使用连接脚本设置地址</p><p><strong>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可用不同于源文件的格式来输出目的文件，即可以进行格式转换。</strong></p><p>1、input-file、outfile分别是输入目标文件和输出目标文件，如果没有明确指定outfile，将创建一个临时文件来存放结果，用input-file的名字来命名。</p><p>2、 -l bfname或–input-target&#x3D;bfdname</p><p>用来指明源文件的格式，bfdname是BFD库描述的标准格式名，如果不指明格式，会自己分析源文件格式，去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</p><p>3、-O bfdname或–output-target&#x3D;bfdname</p><p>使用指定格式来输出文件，bdfname是BFD库中的标准格式名。</p><p><strong>arm-linux-objdump用于显示二进制文件信息</strong></p><p>未完待续。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32hal库</title>
      <link href="/2022/07/01/stm32hal%E5%BA%93/"/>
      <url>/2022/07/01/stm32hal%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>为方便使用，用typedef来给变量起名将以下放入main.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int16_t</span> s16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int8_t</span>  s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int32_t</span> sc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int16_t</span> sc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int8_t</span> sc8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int32_t</span>  vs32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int16_t</span>  vs16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int8_t</span>   vs8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int32_t</span> vsc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int16_t</span> vsc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int8_t</span> vsc8;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>  u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span>  u8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint32_t</span> uc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint16_t</span> uc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint8_t</span> uc8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint32_t</span>  vu32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint16_t</span> vu16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint8_t</span>  vu8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint32_t</span> vuc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint16_t</span> vuc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint8_t</span> vuc8;  </span><br></pre></td></tr></table></figure><p>点亮led</p><p>GPIO用IO口的输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);<span class="comment">//控制电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);<span class="comment">//翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOA, GPIO_Pin_8);<span class="comment">//读取电平</span></span><br></pre></td></tr></table></figure><p>点亮led就需要按键了，按键首先要看按键的引脚设置IO口为输入模式，写一个案件处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line"> <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>; <span class="comment">//支持连按</span></span><br><span class="line"> <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>);</span><br><span class="line"> key_up=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="keyword">return</span> KEY1_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">ALIENTEK MiniSTM32 V3<span class="number">.0</span> 开发板教程</span><br><span class="line"><span class="number">137</span></span><br><span class="line">STM32 不完全手册(HAL 库版)</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中进行添加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5) <span class="comment">//KEY0 按键 PC5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15) <span class="comment">//KEY1 按键 PA15</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) <span class="comment">//WKUP 按键 PA0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES 3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>串口通信</p><p>usart和uart区别为 usart比uart多了同步时钟频率通信，都有异步时钟通信。</p><p>串口设置的一般步骤可以总结为如下几个步骤：</p><ol><li>串口时钟使能，GPIO 时钟使能。</li><li>设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</li><li>GPIO 初始化设置：要设置模式为复用功能。</li><li>串口参数初始化：设置波特率，字长，奇偶校验等参数。</li><li>开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</li><li>使能串口。</li><li>编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</li></ol><p>串口通信的结构体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> uint32_t BaudRate; //波特率</span><br><span class="line"> uint32_t WordLength; //字长</span><br><span class="line"> uint32_t StopBits; //停止位</span><br><span class="line"> uint32_t Parity; //奇偶校验</span><br><span class="line"> uint32_t Mode; //收/发模式设置</span><br><span class="line"> uint32_t HwFlowCtl; //硬件流设置</span><br><span class="line"> uint32_t OverSampling; //过采样设置</span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的学习</title>
      <link href="/2022/06/30/makefile/"/>
      <url>/2022/06/30/makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tieba.baidu.com/p/591519800">Makefile详解（超级好）【mingw吧】_百度贴吧 (baidu.com)</a></p><p>上面挂一个较好的makefile的教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/03/hello-world/"/>
      <url>/2022/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
