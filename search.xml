<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C issue2</title>
      <link href="/2022/12/28/2022-11-25-C-issue2/"/>
      <url>/2022/12/28/2022-11-25-C-issue2/</url>
      
        <content type="html"><![CDATA[<h3 id="结构体和结构体指针的内存申请"><a href="#结构体和结构体指针的内存申请" class="headerlink" title="结构体和结构体指针的内存申请"></a>结构体和结构体指针的内存申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span><span class="comment">//包含malloc函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>//<span class="title">typedef</span>可以将<span class="keyword">struct</span> <span class="title">student</span>结构体类型用<span class="title">std</span>替代</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> subject[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;<span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span> student1;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;student1,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">std</span>));<span class="comment">//初始化从student1开始的地址到后面sizeof（std）也就是结构体的字节个空间，这些空间都初始化为0也就是空。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,student1.name);<span class="comment">//如果不用memset初始化内存，用scanf语句输入了student1.name的信息再用printf输出是看不出来的，如果不输入直接输出的话就会乱码（原因也是系统内存没有初始化谁也不知道里面本来存的是什么）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,student1.name);</span><br><span class="line">    <span class="comment">//结构体是直接由栈自动分配指针的所以不需要我们来手动分配和释放内存，而接下来是用结构体指针来申请内存</span></span><br><span class="line">    <span class="built_in">std</span>* student2 = (<span class="built_in">std</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="built_in">std</span>));</span><br><span class="line">    <span class="keyword">if</span>(student2 == <span class="literal">NULL</span>)<span class="comment">//如果申请内存失败，malloc会返回一个NULl</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc use failure&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//申请内存失败，错误退出</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">memset</span> (student2,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">std</span>));<span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,student2-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:%s\n&quot;</span>,student2-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(student2);<span class="comment">//释放指针指向的堆的内存但是不释放指针本身的内存，指针本身存放在栈区，再程序运行结束后才能自动释放</span></span><br><span class="line">    student2 = <span class="literal">NULL</span>;<span class="comment">//这里就是将指针指向空指针，避免被错误调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件中读取结构体"><a href="#文件中读取结构体" class="headerlink" title="文件中读取结构体"></a>文件中读取结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体, 存储一个字符串和年龄 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要写入文件的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开要写入的文件</span></span><br><span class="line">    FILE *p = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将结构体写出到文件中</span></span><br><span class="line">    fwrite(&amp;s1, <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="comment">// 读取文件中的结构体</span></span><br><span class="line">    <span class="comment">// 存储读取到的结构体数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *p2 = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果打开失败, 退出</span></span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从文件中读取结构体信息</span></span><br><span class="line">    fread(&amp;s2, <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p2);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p2);</span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;student : name=%s, age=%d\n&quot;</span>, s2.name, s2.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体, 存储一个字符串和年龄 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 要写入文件的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s1</span>[2] =</span> &#123;&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>&#125;, &#123;<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开要写入的文件</span></span><br><span class="line">    FILE *p = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败直接退出</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将结构体写出到文件中</span></span><br><span class="line">    fwrite(s1, <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="comment">// 读取文件中的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储读取到的结构体数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">s2</span>[2] =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    FILE *p2 = fopen(<span class="string">&quot;D:/File/student.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果打开失败, 退出</span></span><br><span class="line">    <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取结构体信息</span></span><br><span class="line">    fread(s2, <span class="number">2</span>, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> student), p2);</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(p2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数据</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student : name=%s, age=%d\n&quot;</span>, s2[i].name, s2[i].age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/ybny0421/article/details/123263594?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167220768816800184180646%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167220768816800184180646&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-3-123263594-null-null.142">数据结构对于文件的增删查改</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C错题</title>
      <link href="/2022/12/17/C%E9%94%99%E9%A2%98/"/>
      <url>/2022/12/17/C%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">sizeof</span>(i++);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出等于1</p><p><strong>根据C99规范， sizeof是一个编译时刻就起效果的运算符，在其内的任何运算都没有意义，sizeof(i++); 在编译的时候被翻译成 sizeof((i++的数据类型)) 也就是 sizeof(int); 不会执行i++了 。</strong></p><p>sizeof是操作符</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>下面说法中正确的是（） </p><ul><li><pre><code>若全局变量仅在单个C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  静态全局变量使用过多，可那会导致动态存储区(堆栈)溢出</span><br></pre></td></tr></table></figure></li></ul><p>Static 函数在非类中有三个作用： </p><p>  1、用来隐藏，利用这一特性，可以在不同的文件中定义同名变量和同名函数，而不用担心命名冲突，对应A选项； </p><p>  2、默认初始化为0； </p><p>  3、保持局部变量的持久 。所以A选项是对的。B选项毫无关系，C选项中动态全局变量、静态全局变量、静态局部变量生命期都为函数运行期间。 其中静态局部变量的生存周期虽然为整个源程序，但是其作用域任然与局部变量相同，当退出该函数时，该变量还继续存在，但是不能使用它。所以C选项是错的。  D选项中，静态全局变量存储在全局（静态）存储区。</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`int` `a = ``248``, b = ``4``;``int` `const` `c = ``21``;``const` `int` `*d = &amp;a; ``int` `*``const` `e = &amp;b;``int` `const` `* ``const` `f = &amp;a; `</span><br></pre></td></tr></table></figure><p>  请问下列表达式哪些会被编译器禁止? </p><ul><li><pre><code>*c=32<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  *d=43</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code>e=&amp;a<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  f=0x321f</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;<br>d&#x3D;&amp;b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  *e=34</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221217_210448.png"></p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>假设函数原型和变量说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span>(*p)[<span class="number">4</span>])</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>&#125;，&#123;<span class="number">5</span>，<span class="number">6</span>，<span class="number">7</span>，<span class="number">8</span>&#125;，&#123;<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>下面调用非法的是（b）<br>f3(&amp;a);<br>f3(b[1]);<br>f3(&amp;b[1]);<br>f3(b);</p><p>void f3(<strong>int(*p)[4]</strong>);    其参数是<strong>数组指针</strong> ，指向数组p的指针。</p><ul><li>​    选项A：f3(<strong>&amp;a</strong>);  参数为一个地址，符合指针定义。   </li><li>​    选项B：f3(<strong>b[1]</strong>); 参数为一个数组的具体元素，不符合指针定义。<strong>所以B是非法的调用。</strong>   </li><li>​    选项C：f3(<strong>&amp;b[1]</strong>); 参数为一个数组元素的地址，符合指针定义。   </li><li>​    选项D：f3(<strong>b</strong>);  参数为数组名，表示该数组的首地址，符合指针定义。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信号</title>
      <link href="/2022/12/17/%E4%BF%A1%E5%8F%B7/"/>
      <url>/2022/12/17/%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>信号是事件发生时对进程的通知机制，也可以把它称为软件中断。信号与硬件中断的相似之处在于能够打断程序当前执行的正常流程，其实是在软件层次上对中断机制的一种模拟。大多数情况下，是无法预测信号达到的准确时间，所以，信号提供了一种处理异步事件的方法。</p><p><strong>产生信号的方式：</strong></p><p>⚫ 硬件发生异常，即硬件检测到错误条件并通知内核，随即再由内核发送相应的信号给相关进程。硬件检测到异常的例子包括执行一条异常的机器语言指令，诸如，除数为 0、数组访问越界导致引用了无法访问的内存区域等，这些异常情况都会被硬件检测到，并通知内核、然后内核为该异常情况发生时正在运行的进程发送适当的信号以通知进程。<br>⚫ 用于在终端下输入了能够产生信号的特殊字符。譬如在终端上按下 CTRL + C 组合按键可以产生中断信号（SIGINT），通过这个方法可以终止在前台运行的进程；按下 CTRL + Z 组合按键可以产生暂停信（SIGCONT），通过这个方法可以暂停当前前台运行的进程。<br>⚫ 进程调用 kill()系统调用可将任意信号发送给另一个进程或进程组。当然对此是有所限制的，接收信号的进程和发送信号的进程的所有者必须相同，亦或者发送信号的进程的所有者是 root 超级用户。<br>⚫ 用户可以通过 kill 命令将信号发送给其它进程。kill 命令想必大家都会使用，通常我们会通过 kill命令来“杀死”（终止）一个进程，譬如在终端下执行”kill -9 xxx”来杀死 PID 为 xxx 的进程。kill命令其内部的实现原理便是通过 kill()系统调用来完成的。<br>⚫ 发生了软件事件，即当检测到某种软件条件已经发生。这里指的不是硬件产生的条件（如除数为 0、引用无法访问的内存区域等），而是软件的触发条件、触发了某种软件条件（进程所设置的定时器已经超时、进程执行的 CPU 时间超限、进程的某个子进程退出等等情况）</p><p><strong><u>通常进程会视具体信号执行以下操作之一：</u></strong><br>⚫ 忽略信号。也就是说，当信号到达进程后，该进程并不会去理会它、直接忽略，就好像是没有出该信号，信号对该进程不会产生任何影响。事实上，大多数信号都可以使用这种方式进行处理，但有两种信号却决不能被忽略，它们是 SIGKILL 和 SIGSTOP，这两种信号不能被忽略的原因是：它们向内核和超级用户提供了使进程终止或停止的可靠方法。另外，如果忽略某些由硬件异常产生的信号，则进程的运行行为是未定义的。<br>⚫ 捕获信号。当信号到达进程后，执行预先绑定好的信号处理函数。为了做到这一点，要通知内核在某种信号发生时，执行用户自定义的处理函数，该处理函数中将会对该信号事件作出相应的处理，Linux 系统提供了 signal()系统调用可用于注册信号的处理函数，将会在后面向大家介绍。<br>⚫ 执行系统默认操作。进程不对该信号事件作出处理，而是交由系统进行处理，每一种信号都会有其对应的系统默认的处理方式，8中对此有进行介绍。需要注意的是，对大多数信号来说，系统默认的处理方式就是终止该进程。</p><p>实时信号与非实时信号其实是从时间关系上进行的分类，与可靠信号与不可靠信号是相互对应的，非实<br>时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。实时信号保证了发送的多个<br>信号都能被接收，实时信号是 POSIX 标准的一部分，可用于应用进程。</p><p>Linux 下对标准信号（不可靠信号、非实时信号）的编号为 1~31。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221217_122938.png"></p><h3 id="进程对信号的处理"><a href="#进程对信号的处理" class="headerlink" title="进程对信号的处理"></a>进程对信号的处理</h3><p><strong>signal函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sig_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sig_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sig_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><p>signum：此参数指定需要进行设置的信号，可使用信号名（宏）或信号的数字编号，建议使用信号名。<br>handler：sig_t 类型的函数指针，指向信号对应的信号处理函数，当进程接收到信号后会自动执行该处理函数；参数 handler 既可以设置为用户自定义的函数，也就是捕获信号时需要执行的处理函数，也可以设置为 SIG_IGN 或 SIG_DFL，SIG_IGN 表示此进程需要忽略该信号，SIG_DFL 则表示设置为系统默认操作。<br>sig_t 函数指针的 int 类型参数指的是，当前触发该函数的信号，可将多个信号绑定到同一个信号处理函数上，此时就可通过此参数来判断当前触发的是哪个信号。</p><p>返回值：此函数的返回值也是一个 sig_t 类型的函数指针，成功情况下的返回值则是指向在此之前的信号处理函数；如果出错则返回 SIG_ERR，并会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">sig_t</span> ret = <span class="literal">NULL</span>;</span><br><span class="line"> ret = signal(SIGINT, (<span class="type">sig_t</span>)sig_handler);</span><br><span class="line"> <span class="keyword">if</span> (SIG_ERR == ret) </span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;signal error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 死循环 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123; &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>sigaction()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure><p>signum：需要设置的信号，除了 SIGKILL 信号和 SIGSTOP 信号之外的任何信号。<br>act：act 参数是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构，该数据结构描述了信<br>号的处理方式，稍后介绍该数据结构；如果参数 act 不为 NULL，则表示需要为信号设置新的处理方式；如<br>果参数 act 为 NULL，则表示无需改变信号当前的处理方式。<br>oldact：oldact 参数也是一个 struct sigaction 类型指针，指向一个 struct sigaction 数据结构。如果参数<br>oldact 不为 NULL，则会将信号之前的处理方式等信息通过参数 oldact 返回出来；如果无意获取此类信息，<br>那么可将该参数设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line"> <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line"> <span class="type">sigset_t</span> sa_mask;</span><br><span class="line"> <span class="type">int</span> sa_flags;</span><br><span class="line"> <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 死循环 */</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123; &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向进程发信号"><a href="#向进程发信号" class="headerlink" title="向进程发信号"></a>向进程发信号</h3><p><strong>kill</strong>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>pid：参数 pid 为正数的情况下，用于指定接收此信号的进程 pid；除此之外，参数 pid 也可设置为 0 或-1 以及小于-1 等不同值，稍后给说明。<br>sig：参数 sig 指定需要发送的信号，也可设置为 0，如果参数 sig 设置为 0 则表示不发送信号，但任执行错误检查，这通常可用于检查参数 pid 指定的进程是否存在。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>参数 pid 不同取值含义：<br>⚫ 如果 pid 为正，则信号 sig 将发送到 pid 指定的进程。<br>⚫ 如果 pid 等于 0，则将 sig 发送到当前进程的进程组中的每个进程。<br>⚫ 如果 pid 等于-1，则将 sig 发送到当前进程有权发送信号的每个进程，但进程 1（init）除外。<br>⚫ 如果 pid 小于-1，则将 sig 发送到 ID 为-pid 的进程组中的每个进程。<br>进程中将信号发送给另一个进程是需要权限的，并不是可以随便给任何一个进程发送信号，超级用户root 进程可以将信号发送给任何进程，但对于非超级用户（普通用户）进程来说，其基本规则是发送者进程的实际用户 ID 或有效用户 ID 必须等于接收者进程的实际用户 ID 或有效用户 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> pid;</span><br><span class="line"> <span class="comment">/* 判断传参个数 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 将传入的字符串转为整形数字 */</span></span><br><span class="line"> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>, pid);</span><br><span class="line"> <span class="comment">/* 向 pid 指定的进程发送信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == kill(pid, SIGINT)) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;kill error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>raise()函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>sig：需要发送的信号。<br>返回值：成功返回 0；失败将返回非零值。<br>raise()其实等价于：kill(getpid(), sig);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> ret = sigaction(SIGINT, &amp;sig, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 向自身发送 SIGINT 信号 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != raise(SIGINT)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;raise error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">3</span>); <span class="comment">// 每隔 3 秒发送一次</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="alarm-和-pause-函数"><a href="#alarm-和-pause-函数" class="headerlink" title="alarm()和 pause()函数"></a>alarm()和 pause()函数</h3><p>使用 alarm()函数可以设置一个定时器（闹钟），当定时器定时时间到时，内核会向进程发送 SIGALRM信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>seconds：设置定时时间，以秒为单位；如果参数 seconds 等于 0，则表示取消之前设置的 alarm 闹钟。<br>返回值：如果在调用 alarm()时，之前已经为该进程设置了 alarm 闹钟还没有超时，则该闹钟的剩余值作为本次 alarm()函数调用的返回值，之前设置的闹钟则被新的替代；否则返回 0。参数 seconds 的值是产生 SIGALRM 信号需要经过的时钟秒数，当这一刻到达时，由内核产生该信号，每个进程只能设置一个 alarm 闹钟；虽然 SIGALRM 信号的系统默认操作是终止进程，但是如果程序当中设置了 alarm 闹钟，但大多数使用闹钟的进程都会捕获此信号。<br>需要注意的是 alarm 闹钟并不能循环触发，只能触发一次，若想要实现循环触发，可以在 SIGALRM 信号处理函数中再次调用 alarm()函数设置定时器。</p><p>pause()系统调用可以使得进程暂停运行、进入休眠状态，直到进程捕获到一个信号为止，只有执行了信<br>号处理函数并从其返回时，pause()才返回，在这种情况下，pause()返回-1，并且将 errno 设置为 EINTR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Alarm timeout&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sig</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">int</span> second;</span><br><span class="line"> <span class="comment">/* 检验传参个数 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">2</span> &gt; argc)</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> <span class="comment">/* 为 SIGALRM 信号绑定处理函数 */</span></span><br><span class="line"> sig.sa_handler = sig_handler;</span><br><span class="line"> sig.sa_flags = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGALRM, &amp;sig, <span class="literal">NULL</span>)) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 启动 alarm 定时器 */</span></span><br><span class="line"> second = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;定时时长: %d 秒\n&quot;</span>, second);</span><br><span class="line"> alarm(second);</span><br><span class="line"> <span class="comment">/* 进入休眠状态 */</span></span><br><span class="line"> pause();</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;休眠结束&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统信息与系统资源</title>
      <link href="/2022/12/13/Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/"/>
      <url>/2022/12/13/Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="系统信息与系统资源"><a href="#系统信息与系统资源" class="headerlink" title="系统信息与系统资源"></a>系统信息与系统资源</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><h4 id="系统标识uname"><a href="#系统标识uname" class="headerlink" title="系统标识uname"></a>系统标识uname</h4><p>系统调用uname()用于获取有关当前操作系统内核的名称和信息，原型可以通过man 2 uname查看</p><p>函数参数和返回值含义如下：<br>buf：struct utsname 结构体类型指针，指向一个 struct utsname 结构体类型对象。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>uname()函数用法非常简单，先定义一个 struct utsname 结构体变量，调用 uname()函数时传入变量的地<br>址即可，struct utsname 结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line"> <span class="type">char</span> sysname[]; <span class="comment">/* 当前操作系统的名称 */</span></span><br><span class="line"> <span class="type">char</span> nodename[]; <span class="comment">/* 网络上的名称（主机名） */</span></span><br><span class="line"> <span class="type">char</span> release[]; <span class="comment">/* 操作系统内核版本 */</span></span><br><span class="line"> <span class="type">char</span> version[]; <span class="comment">/* 操作系统发行版本 */</span></span><br><span class="line"> <span class="type">char</span> machine[]; <span class="comment">/* 硬件架构类型 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line"> <span class="type">char</span> domainname[];<span class="comment">/* 当前域名 */</span></span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sysinfo函数"><a href="#sysinfo函数" class="headerlink" title="sysinfo函数"></a>sysinfo函数</h4><p>sysinfo 系统调用可用于获取一些系统统计信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *info)</span>;</span><br></pre></td></tr></table></figure><p>info：struct sysinfo 结构体类型指针，指向一个 struct sysinfo 结构体类型对象。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> &#123;</span></span><br><span class="line"> <span class="type">long</span> uptime; <span class="comment">/* 自系统启动之后所经过的时间（以秒为单位） */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> loads[<span class="number">3</span>]; <span class="comment">/* 1, 5, and 15 minute load averages */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalram; <span class="comment">/* 总的可用内存大小 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freeram; <span class="comment">/* 还未被使用的内存大小 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> sharedram; <span class="comment">/* Amount of shared memory */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> bufferram; <span class="comment">/* Memory used by buffers */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalswap; <span class="comment">/* Total swap space size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freeswap; <span class="comment">/* swap space still available */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> procs; <span class="comment">/* 系统当前进程数量 */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> totalhigh; <span class="comment">/* Total high memory size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">long</span> freehigh; <span class="comment">/* Available high memory size */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> mem_unit; <span class="comment">/* 内存单元大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">char</span> _f[<span class="number">20</span><span class="number">-2</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>)-<span class="keyword">sizeof</span>(<span class="type">int</span>)]; <span class="comment">/* Padding to 64 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="gethostname函数"><a href="#gethostname函数" class="headerlink" title="gethostname函数"></a>gethostname函数</h4><p>此函数可用于单独获取 Linux 系统主机名，与 struct utsname 数据结构体中的 nodename 变量一样，原型通过命令man 2 gethostname查看。</p><p>name：指向用于存放主机名字符串的缓冲区。<br>len：缓冲区长度。<br>返回值：成功返回 0,；失败将返回-1，并会设置 errno。</p><h4 id="sysconf函数"><a href="#sysconf函数" class="headerlink" title="sysconf函数"></a>sysconf函数</h4><p>sysconf()函数是一个库函数，可在运行时获取系统的一些配置信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">sysconf</span><span class="params">(<span class="type">int</span> name)</span>;</span><br></pre></td></tr></table></figure><p>⚫ _SC_ARG_MAX：exec 族函数的参数的最大长度，exec 族函数后面会介绍，这里先不管！<br>⚫ _SC_CHILD_MAX：每个用户的最大并发进程数，也就是同一个用户可以同时运行的最大进程数。<br>⚫ _SC_HOST_NAME_MAX：主机名的最大长度。<br>⚫ _SC_LOGIN_NAME_MAX：登录名的最大长度。<br>⚫ _SC_CLK_TCK：每秒时钟滴答数，也就是系统节拍率。<br>⚫ _SC_OPEN_MAX：一个进程可以打开的最大文件数。<br>⚫ _SC_PAGESIZE：系统页大小（page size）。<br>⚫ _SC_TTY_NAME_MAX：终端设备名称的最大长度。</p><p>更多请用man指令查询。</p><h3 id="时间、日期"><a href="#时间、日期" class="headerlink" title="时间、日期"></a>时间、日期</h3><h4 id="time函数"><a href="#time函数" class="headerlink" title="time函数"></a>time函数</h4><p>系统调用time()用于获取当前时间，以秒为单位，返回值是自 1970-01-01 00:00:00 +0000 (UTC)以来的秒数，原型可通过man2 time查看</p><p>tloc：如果 tloc 参数不是 NULL，则返回值也存储在 tloc 指向的内存中。</p><p>返回值：成功则返回自 1970-01-01 00:00:00 +0000 (UTC)以来的时间值（以秒为单位）；失败则返回-1，<br>并会设置 errno。</p><p>time 函数获取得到的是一个时间段，也就是从 1970-01-01 00:00:00 +0000 (UTC)到现在这段时间所经过的秒数，把这个称之为日历时间或 time_t 时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">time_t</span> t;</span><br><span class="line"> t = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == t) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;时间值: %ld\n&quot;</span>, t);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gettimeofday函数"><a href="#gettimeofday函数" class="headerlink" title="gettimeofday函数"></a>gettimeofday函数</h4><p>gettimeofday()函数提供微秒级时间精度。原型可通过man 2 gettimeofday查看</p><p>tv：参数 tv 是一个 struct timeval 结构体指针变量，struct timeval 结构体在前面章节内容中已经给大家介绍过，具体参考示例代码 5.6.3。<br>tz：参数 tz 是个历史产物，早期实现用其来获取系统的时区信息，目前已遭废弃，在调用 gettimeofday()函数时应将参数 tz 设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tval</span>;</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = gettimeofday(&amp;tval, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;gettimeofday error&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;时间值: %ld 秒+%ld 微秒\n&quot;</span>, tval.tv_sec, tval.tv_usec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间转换函数"><a href="#时间转换函数" class="headerlink" title="时间转换函数"></a>时间转换函数</h4><p><strong>ctime函数</strong></p><p>ctime可以将日历时间转换为可打印输出的字符串形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>timep：time_t 时间变量指针。<br>返回值：成功将返回一个 char *类型指针，指向转换后得到的字符串；失败将返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> tm_str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">time_t</span> tm;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> tm = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == tm) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将时间转换为字符串形式 */</span></span><br><span class="line"> ctime_r(&amp;tm, tm_str);</span><br><span class="line"><span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;当前时间: %s&quot;</span>, tm_str);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>localtime函数</strong></p><p>localtime()函数可以把 time()或 gettimeofday()得到的秒数（time_t 时间或日历时间）变成一个 struct tm<br>结构体所表示的时间，该时间对应的是本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">localtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure><p>timep：需要进行转换的 time_t 时间变量对应的指针，可通过 time()或 gettimeofday()获取得到。<br>result：是一个 struct tm 结构体类型指针，稍后给大家介绍 struct tm 结构体，参数 result 是可重入函数<br>localtime_r()需要额外提供的参数。<br>返回值：对于不可重入版本 localtime()来说，成功则返回一个有效的 struct tm 结构体指针，而对于可重入版本 localtime_r()来说，成功执行情况下，返回值将会等于参数result；失败则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> tm_sec; <span class="comment">/* 秒(0-60) */</span></span><br><span class="line"> <span class="type">int</span> tm_min; <span class="comment">/* 分(0-59) */</span></span><br><span class="line"> <span class="type">int</span> tm_hour; <span class="comment">/* 时(0-23) */</span></span><br><span class="line"> <span class="type">int</span> tm_mday; <span class="comment">/* 日(1-31) */</span></span><br><span class="line"> <span class="type">int</span> tm_mon; <span class="comment">/* 月(0-11) */</span></span><br><span class="line"> <span class="type">int</span> tm_year; <span class="comment">/* 年(这个值表示的是自 1900 年到现在经过的年数) */</span></span><br><span class="line"> <span class="type">int</span> tm_wday; <span class="comment">/* 星期(0-6, 星期日 Sunday = 0、星期一=1…) */</span></span><br><span class="line"> <span class="type">int</span> tm_yday; <span class="comment">/* 一年里的第几天(0-365, 1 Jan = 0) */</span></span><br><span class="line"> <span class="type">int</span> tm_isdst; <span class="comment">/* 夏令时 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">t</span>;</span></span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sec) &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 转换得到本地时间 */</span></span><br><span class="line"> localtime_r(&amp;sec, &amp;t);</span><br><span class="line"> <span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;当前时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> t.tm_year + <span class="number">1900</span>, t.tm_mon, t.tm_mday,</span><br><span class="line"> t.tm_hour, t.tm_min, t.tm_sec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>gmtime()函数</strong>把time_t时间变为struct tm结构体所表示的时间，得到的是UTC国际标准时间，不是本地时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br><span class="line"><span class="keyword">struct</span> tm *<span class="title function_">gmtime_r</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep, <span class="keyword">struct</span> tm *result)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">local_t</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">utc_t</span>;</span></span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == sec) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 转换得到本地时间 */</span></span><br><span class="line"> localtime_r(&amp;sec, &amp;<span class="type">local_t</span>);</span><br><span class="line"> <span class="comment">/* 转换得到国际标准时间 */</span></span><br><span class="line"> gmtime_r(&amp;sec, &amp;<span class="type">utc_t</span>);</span><br><span class="line"> <span class="comment">/* 打印输出 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本地时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> <span class="type">local_t</span>.tm_year + <span class="number">1900</span>, <span class="type">local_t</span>.tm_mon, <span class="type">local_t</span>.tm_mday,</span><br><span class="line"> <span class="type">local_t</span>.tm_hour, <span class="type">local_t</span>.tm_min, <span class="type">local_t</span>.tm_sec);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;UTC 时间: %d 年%d 月%d 日 %d:%d:%d\n&quot;</span>,</span><br><span class="line"> <span class="type">utc_t</span>.tm_year + <span class="number">1900</span>, <span class="type">utc_t</span>.tm_mon, <span class="type">utc_t</span>.tm_mday,</span><br><span class="line"> <span class="type">utc_t</span>.tm_hour, <span class="type">utc_t</span>.tm_min, <span class="type">utc_t</span>.tm_sec);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>mktime函数</strong>可以将使用 struct tm 结构体表示的分解时间转换为 time_t时间（日历时间）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">time_t</span> <span class="title function_">mktime</span><span class="params">(<span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure><p>tm：需要进行转换的 struct tm 结构体变量对应的指针。<br>返回值：成功返回转换得到 time_t 时间值；失败返回-1。</p><p><strong>asctime函数</strong>与 ctime()函数的作用一样，也可将时间转换为可打印输出的字符串形式，与 ctime()函数<br>的区别在于，ctime()是将 time_t 时间转换为固定格式字符串、而 asctime()则是将 struct tm 表示的分解时间转换为固定格式的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">asctime_r</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> tm *tm, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p>tm：需要进行转换的 struct tm 表示的时间。<br>buf：可重入版本函数 asctime_r 需要额外提供的参数 buf，指向一个缓冲区，用于存放转换得到的字符串。<br>返回值：转换失败将返回 NULL；成功将返回一个 char *类型指针，指向转换后得到的时间字符串，对asctime_r 函数来说，返回值就等于参数 buf。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">local_t</span>;</span></span><br><span class="line"> <span class="type">char</span> tm_str[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">time_t</span> sec;</span><br><span class="line"> <span class="comment">/* 获取时间 */</span></span><br><span class="line"> sec = time(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (sec == <span class="number">-1</span>) </span><br><span class="line"> &#123;</span><br><span class="line">perror(<span class="string">&quot;time error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> localtime_r(&amp;sec, &amp;<span class="type">local_t</span>);</span><br><span class="line"> asctime_r(&amp;<span class="type">local_t</span>, tm_str);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;本地时间: %s&quot;</span>, tm_str);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>strftime 函数</strong>可以自定义时间显示格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strftime</span><span class="params">(<span class="type">char</span> *s, <span class="type">size_t</span> max, <span class="type">const</span> <span class="type">char</span> *format, <span class="type">const</span> <span class="keyword">struct</span> tm *tm)</span>;</span><br></pre></td></tr></table></figure><p>s：指向一个缓存区的指针，该缓冲区用于存放生成的字符串。<br>max：字符串的最大字节数。<br>format：这是一个用字符串表示的字段，包含了普通字符和特殊格式说明符，可以是这两种字符的任意<br>组合。特殊格式说明符将会被替换为 struct tm 结构体对象所指时间的相应值。</p><p>特殊格式可用命令man strftime查询。</p><p><strong>设置时间 settimeofday</strong></p><p>使用 settimeofday()函数可以设置时间，也就是设置系统的本地时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">settimeofday</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> timeval *tv, <span class="type">const</span> <span class="keyword">struct</span> timezone *tz)</span>;</span><br></pre></td></tr></table></figure><p>tv：参数 tv 是一个 struct timeval 结构体指针变量，struct timeval 结构体在前面章节内容中已经给大家介绍了，需要设置的时间便通过参数 tv 指向的 struct timeval 结构体变量传递进去。<br>tz：参数 tz 是个历史产物，早期实现用其来设置系统的时区信息，目前已遭废弃，在调用 settimeofday()函数时应将参数 tz 设置为 NULL。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>使用 settimeofday 设置系统时间时内核会进行权限检查，只有超级用户（root）才可以设置系统时间，普通用户将无操作权限。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_20221211_135113.png"></p><h3 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h3><p>进程时间指的是进程从创建后（也就是程序运行后）到目前为止这段时间内使用 CPU 资源的时间总数，出于记录的目的，内核把 CPU 时间（进程时间）分为以下两个部分：<br>⚫ 用户 CPU 时间：进程在用户空间（用户态）下运行所花费的 CPU 时间。有时也成为虚拟时间（virtual time）。<br>⚫ 系统 CPU 时间：进程在内核空间（内核态）下运行所花费的 CPU 时间。这是内核执行系统调用或代表进程执行的其它任务（譬如，服务页错误）所花费的时间。<br>一般来说，进程时间指的是用户 CPU 时间和系统 CPU 时间的总和，也就是总的 CPU 时间。</p><h4 id="times函数"><a href="#times函数" class="headerlink" title="times函数"></a>times函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">times</span><span class="params">(<span class="keyword">struct</span> tms *buf)</span>;</span><br></pre></td></tr></table></figure><p>buf：times()会将当前进程时间信息存在一个 struct tms 结构体数据中</p><p>返回值：返回值类型为 clock_t（实质是 long 类型），调用成功情况下，将返回从过去任意的一个时间点（譬如系统启动时间）所经过的时钟滴答数（其实就是系统节拍数），将(节拍数 &#x2F; 节拍率)便可得到秒数，返回值可能会超过 clock_t 所能表示的范围（溢出）；调用失败返回-1，并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">clock_t</span> tms_utime; <span class="comment">/* user time, 进程的用户 CPU 时间, tms_utime 个系统节拍数 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_stime; <span class="comment">/* system time, 进程的系统 CPU 时间, tms_stime 个系统节拍数 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_cutime; <span class="comment">/* user time of children, 已死掉子进程的 tms_utime + tms_cutime 时间总和 */</span></span><br><span class="line"> <span class="type">clock_t</span> tms_cstime; <span class="comment">/* system time of children, 已死掉子进程的 tms_stime + tms_cstime 时间总和 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="clock函数"><a href="#clock函数" class="headerlink" title="clock函数"></a>clock函数</h4><p>库函数 clock()提供了一个更为简单的方式用于进程时间，它的返回值描述了进程使用的总的 CPU 时间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">clock_t</span> <span class="title function_">clock</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>无参数。<br>返回值：返回值是到目前为止程序的进程时间，为 clock_t 类型，注意 clock()的返回值并不是系统节拍数，如果想要获得秒数，请除以 CLOCKS_PER_SEC（这是一个宏）。如果返回的进程时间不可用或其值无法表示，则该返回值是-1。<br>clock()函数虽然可以很方便的获取总的进程时间，但并不能获取到单独的用户 CPU 时间和系统 CPU 时间，在实际编程当中，根据自己的需要选择。</p><h4 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h4><p>rand()函数用于获取随机数。（是一种伪随机数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rand</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>返回值：返回一个介于 0 到 RAND_MAX（包含）之间的值，也就是数学上的[0, RAND_MAX]。程度当中调用 rand()可以得到[0, RAND_MAX]之间的伪随机数，多次调用 rand()便可以生成一组伪随机树序列，但是这里有个问题，就是每一次运行程序所得到的随机数序列都是相同的，那如何使得每一次启动应用程序所得到的随机数序列是不一样的呢？那就通过设置不同的随机数种子，可通过 srand()设置随机数种子。<br>如果没有调用 srand()设置随机数种子的情况下，rand()会将 1 作为随机数种子，如果随机数种子相同，那么每一次启动应用程序所得到的随机数序列就是一样的，所以每次启动应用程序需要设置不同的随机数种子，这样就可以使得程序每次运行所得到随机数序列不同。</p><p><strong>srand 函数</strong></p><p>使用 srand()函数为 rand()设置随机数种子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span>;</span><br></pre></td></tr></table></figure><p>seed：指定一个随机数中，int 类型的数据，一般尝尝将当前时间作为随机数种子赋值给参数 seed，譬如 time(NULL)，因为每次启动应用程序时间上是一样的，所以就能够使得程序中设置的随机数种子在每次启动程序时是不一样的。<br>返回值：void<br>常用的用法 srand(time(NULL))</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> random_number_arr[<span class="number">8</span>];</span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> <span class="comment">/* 设置随机数种子 */</span></span><br><span class="line"> srand(time(<span class="literal">NULL</span>));</span><br><span class="line"> <span class="comment">/* 生成伪随机数 */</span></span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">8</span>; count++)</span><br><span class="line"> random_number_arr[count] = rand() % <span class="number">100</span>;</span><br><span class="line"> <span class="comment">/* 打印随机数数组 */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"> <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">8</span>; count++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, random_number_arr[count]);</span><br><span class="line"> <span class="keyword">if</span> (count != <span class="number">8</span> - <span class="number">1</span>)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h3><p>有时需要将进程暂停或休眠一段时间，进入休眠状态之后，程序将暂停运行，直到休眠结束。常用的系统调用和 C 库函数有 sleep()、usleep()以及 nanosleep()，这些函数在应用程序当中通常作为延时使用。</p><p><strong>秒级休眠sleep</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><p>seconds：休眠时长，以秒为单位。<br>返回值：如果休眠时长为参数 seconds 所指定的秒数，则返回 0；若被信号中断则返回剩余的秒数。<br>sleep()是一个秒级别休眠函数，程序在休眠过程中，是可以被其它信号所打断的。</p><p>微秒休眠usleep</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">usleep</span><span class="params">(<span class="type">useconds_t</span> usec)</span>;</span><br></pre></td></tr></table></figure><p>高精度休眠nanosleep</p><p>nanosleep()与 sleep()以及 usleep()类似，都用于程序休眠，但 nanosleep()具有更高精度来设置休眠时间长度，支持纳秒级时长设置。与 sleep()、usleep()不同的是，nanosleep()是一个 Linux 系统调用。</p><p>req：一个 struct timespec 结构体指针，指向一个 struct timespec 变量，用于设置休眠时间长度，可精确到纳秒级别。<br>rem：也是一个 struct timespec 结构体指针，指向一个 struct timespec 变量，也可设置 NULL。<br>返回值：在成功休眠达到请求的时间间隔后，nanosleep()返回 0；如果中途被信号中断或遇到错误，则返回-1，并将剩余时间记录在参数 rem 指向的 struct timespec 结构体变量中（参数 rem 不为 NULL 的情况下，如果为 NULL 表示不接收剩余时间），还会设置 errno 标识错误类型。</p><h3 id="申请堆内存"><a href="#申请堆内存" class="headerlink" title="申请堆内存"></a>申请堆内存</h3><p>在操作系统下，内存资源是由操作系统进行管理、分配的，当应用程序想要内存时（这里指的是堆内存），可以向操作系统申请内存，然后使用内存；当不再需要时，将申请的内存释放、归还给操作系统。</p><h4 id="堆上分配内存：malloc和free"><a href="#堆上分配内存：malloc和free" class="headerlink" title="堆上分配内存：malloc和free"></a>堆上分配内存：malloc和free</h4><p><strong>malloc</strong>为程序分配一段堆内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>size：需要分配的内存大小，以字节为单位。</p><p>返回值：返回值为 void *类型，如果申请分配内存成功，将返回一个指向该段内存的指针，void *并不是说没有返回值或者返回空指针，而是返回的指针类型未知,所以在调用 malloc()时通常需要进行强制类型转换，将 void *指针类型转换成我们希望的类型；如果分配内存失败（譬如系统堆内存不足）将返回 NULL，如果参数 size 为 0，返回值也是 NULL。</p><p>malloc()在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的，所以通常需要程序员对 malloc()分配的堆内存进行初始化操作。</p><p><strong>free</strong>释放堆内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>ptr：指向需要被释放的堆内存对应的指针。<br>返回值：无返回值。</p><p><strong>用 calloc()分配内存</strong><br>calloc()函数用来动态地分配内存空间并初始化为 0，其函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">calloc</span><span class="params">(<span class="type">size_t</span> nmemb, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>使用该函数同样也需要包含头文件。<br>calloc()在堆中动态地分配 nmemb 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 nmemb * size 个字节长度的内存空间，并且每个字节的值都是 0。<br>返回值：分配成功返回指向该内存的地址，失败则返回 NULL。<br>calloc()与 malloc()的一个重要区别是：calloc()在动态分配完内存后，自动初始化该内存空间为零，而malloc()不初始化，里边数据是未知的垃圾数据。下面的两种写法是等价的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calloc()分配内存空间并初始化</span></span><br><span class="line"><span class="type">char</span> *buf1 = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// malloc()分配内存空间并用 memset()初始化</span></span><br><span class="line"><span class="type">char</span> *buf2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="number">2</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf2, <span class="number">0</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="分配对齐内存"><a href="#分配对齐内存" class="headerlink" title="分配对齐内存"></a>分配对齐内存</h4><p><a href="https://xie.infoq.cn/article/e071632f617563002552a7232">一文轻松理解内存对齐_</a></p><p>C 函数库中还提供了一系列在堆上分配对齐内存的函数，对齐内存在某些应用场合非常有必要，常用于分配对其内存的库函数有：posix_memalign()、aligned_alloc()、memalign()、valloc()、pvalloc()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_memalign</span><span class="params">(<span class="type">void</span> **memptr, <span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">aligned_alloc</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">valloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memalign</span><span class="params">(<span class="type">size_t</span> alignment, <span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">pvalloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>posix_memalign()函数<br>posix_memalign()函数用于在堆上分配 size 个字节大小的对齐内存空间，将*memptr 指向分配的空间，分配的内存地址将是参数 alignment 的整数倍。参数 alignment 表示对齐字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void *)的整数倍，对于 32 位系统来说sizeof(void *)等于4，如果是 64 位系统 sizeof(void *)等于 8。<br>函数参数和返回值含义如下：<br>memptr：void *<em>类型的指针，内存申请成功后会将分配的内存地址存放在</em>memptr 中。<br>alignment：设置内存对其的字节数，alignment 必须是 2 的幂次方（譬如 2^4、2^5、2^8 等），同时也要是 sizeof(void <em>)的整数倍。<br>size：设置分配的内存大小，以字节为单位，如果参数 size 等于 0，那么</em>memptr 中的值是 NULL。<br>返回值：成功将返回 0；失败返回非 0 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> *base = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 申请内存: 256 字节对齐 */</span></span><br><span class="line"> ret = posix_memalign((<span class="type">void</span> **)&amp;base, <span class="number">256</span>, <span class="number">1024</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> != ret) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;posix_memalign error\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/* 使用内存 */</span></span><br><span class="line"> <span class="comment">// base[0] = 0;</span></span><br><span class="line"> <span class="comment">// base[1] = 1;</span></span><br><span class="line"> <span class="comment">// base[2] = 2;</span></span><br><span class="line"> <span class="comment">// base[3] = 3;</span></span><br><span class="line"> <span class="comment">/* 释放内存 */</span></span><br><span class="line"> <span class="built_in">free</span>(base);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="proc文件系统"><a href="#proc文件系统" class="headerlink" title="proc文件系统"></a>proc文件系统</h3><p>(1)proc是虚拟文件系统，虚拟的意思就是proc文件系统里的文件不对应硬盘上任何文件，我们用去查看proc目录下的文件大小都是零；<br>(2)proc文件系统是开放给上层了解内核运行状态的窗口，通过读取proc系统里的文件，可以知道内核中一些重要数据结构的数值，从而知道内核的运行情况，也可以方便调试内核和应用程序；<br>(3)proc文件系统的思路：在内核中构建一个虚拟文件系统&#x2F;proc，内核运行时将内核中一些关键的数据结构以文件的方式呈现在&#x2F;proc目录中的一些特定文件中，这样相当于将不可见的内核中的数据结构以可视化的方式呈现给内核的开发者</p><table><thead><tr><th align="center">文件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">&#x2F;proc&#x2F;cmdline</td><td align="center">查看内核的启动参数</td></tr><tr><td align="center">&#x2F;proc&#x2F;cpuinfo</td><td align="center">查看CPU的信息</td></tr><tr><td align="center">&#x2F;proc&#x2F;devices</td><td align="center">查看内核中已经注册的设备</td></tr><tr><td align="center">&#x2F;proc&#x2F;filesystems</td><td align="center">内核当前支持的文件系统类型</td></tr><tr><td align="center">&#x2F;proc&#x2F;interrupts</td><td align="center">中断的使用及触发次数，调试中断时很有用</td></tr><tr><td align="center">&#x2F;proc&#x2F;misc</td><td align="center">内核中注册的misc类设备</td></tr><tr><td align="center">&#x2F;proc&#x2F;modules</td><td align="center">已经加载的模块列表，对应lsmod命令</td></tr><tr><td align="center">&#x2F;proc&#x2F;partitions</td><td align="center">系统的分区表</td></tr><tr><td align="center">&#x2F;proc&#x2F;version</td><td align="center">系统的版本</td></tr><tr><td align="center">数字</td><td align="center">数字的文件夹都是相应的进程</td></tr><tr><td align="center">&#x2F;proc&#x2F;mounts</td><td align="center">已加载的文件系统的列表，对应mount命令</td></tr><tr><td align="center">&#x2F;proc&#x2F;meminfo</td><td align="center">内核的内存信息</td></tr><tr><td align="center">&#x2F;proc&#x2F;fb</td><td align="center">内核中注册的显示设备</td></tr></tbody></table><p><strong><u>proc 文件系统的使用就是去读取&#x2F;proc 目录下的这些文件，获取文件中记录的信息，可以直接使用 cat 命令读取，也可以在应用程序中调用 open()打开、然后再使用 read()函数读取。</u></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作的问题</title>
      <link href="/2022/12/12/Linux%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/12/12/Linux%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="gcc使用中的问题"><a href="#gcc使用中的问题" class="headerlink" title="gcc使用中的问题"></a>gcc使用中的问题</h3><p>一串代码反复检查没有问题，但是在gcc中会有警告和报错，但是放在C语言的devc++中就完美运行了，究其原因是将包含了结构体定义的函数放入了结构体声明的上面，由此可见正常的编译软件会将程序进行检索查询你定义的函数或声明，但是使用gcc的化就是从头到尾走一遍，所以在linux下编程的顺序是很重要的。</p><h3 id="linux中使用C-x2F-C-的调试工具gdb"><a href="#linux中使用C-x2F-C-的调试工具gdb" class="headerlink" title="linux中使用C&#x2F;C++的调试工具gdb"></a>linux中使用C&#x2F;C++的调试工具gdb</h3><p>gdb是GNU开源组织发布的一个强大的Linux下的程序调试工具。</p><p> 一般来说，GDB主要帮助你完成下面四个方面的功能：</p><p>1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</p><p>2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</p><p>3、当程序被停住时，可以检查此时你的程序中所发生的事。</p><p>4、你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。<br>首先要用gcc进行编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g 源文件 -o 目标文件</span><br></pre></td></tr></table></figure><p><strong><u>gdb的命令</u></strong></p><p>（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</p><p>（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</p><p>（gdb）start：单步执行，运行程序，停在第一执行语句</p><p>（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</p><p>（gdb）set：设置变量的值</p><p>（gdb）next：单步调试（逐过程，函数直接执行）,简写n</p><p>（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s</p><p>（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt</p><p>（gdb）frame：切换函数的栈帧,简写f</p><p>（gdb）info：查看函数内部局部变量的数值,简写i</p><p>（gdb）finish：结束当前函数，返回到函数调用点</p><p>（gdb）continue：继续运行,简写c</p><p>（gdb）print：打印值及地址,简写p</p><p>（gdb）quit：退出gdb,简写q</p><p>（gdb）break+num：在第num行设置断点,简写b</p><p>（gdb）info breakpoints：查看当前设置的所有断点</p><p>（gdb）delete breakpoints num：删除第num个断点,简写d</p><p>（gdb）display：追踪查看具体变量值</p><p>（gdb）undisplay：取消追踪观察变量</p><p>（gdb）watch：被设置观察点的变量发生修改时，打印显示</p><p>（gdb）i watch：显示观察点</p><p>（gdb）enable breakpoints：启用断点</p><p>（gdb）disable breakpoints：禁用断点</p><p>（gdb）x：查看内存x&#x2F;20xw 显示20个单元，16进制，4字节每单元</p><p>（gdb）run argv[1] argv[2]：调试时命令行传参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; ilt;=<span class="number">100</span>; i++)</span><br><span class="line">     &#123;</span><br><span class="line">           sum+=i;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">          result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[1-100] = %d&quot;</span>, result );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d&quot;</span>, func(<span class="number">250</span>) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">root&lt;span style=<span class="string">&quot;&quot;</span>&gt;@&lt;/span&gt;linux: /home/benben /test<span class="meta"># gdb tst &lt;---------- 启动GDB</span></span><br><span class="line">GNU gdb <span class="number">5.1</span><span class="number">.1</span></span><br><span class="line">Copyright <span class="number">2002</span> Free Software Foundation, Inc.</span><br><span class="line">GDB is <span class="built_in">free</span> software, covered by the GNU General Public License, and you are</span><br><span class="line">welcome to change it and/or distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> to see the conditions.</span><br><span class="line">There is absolutely no warranty <span class="keyword">for</span> GDB. Type <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;i386-suse-linux&quot;</span>...</span><br><span class="line">(gdb) l &lt;-------------------- l命令相当于<span class="built_in">list</span>，从第一行开始例出原码。</span><br><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span></span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">int</span> func(<span class="type">int</span> n)</span><br><span class="line"><span class="number">4</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">0</span>; i</span><br><span class="line"><span class="number">7</span> &#123;</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line"><span class="number">9</span> &#125;</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span> sum;</span><br><span class="line">(gdb) &lt;-------------------- 直接回车表示，重复上一次命令</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span> main()</span><br><span class="line"><span class="number">15</span> &#123;</span><br><span class="line"><span class="number">16</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">17</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line"><span class="number">19</span> &#123;</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) <span class="keyword">break</span> <span class="number">16</span> &lt;-------------------- 设置断点，在源程序第<span class="number">16</span>行处。</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048496</span>: file tst.c, line <span class="number">16.</span></span><br><span class="line">(gdb) <span class="keyword">break</span> func &lt;-------------------- 设置断点，在函数func()入口处。</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0x8048456</span>: file tst.c, line <span class="number">5.</span></span><br><span class="line">(gdb) info <span class="keyword">break</span> &lt;-------------------- 查看断点信息。</span><br><span class="line">Num Type Disp Enb Address What</span><br><span class="line"><span class="number">1</span> breakpoint keep y <span class="number">0x08048496</span> in main at tst.c:<span class="number">16</span></span><br><span class="line"><span class="number">2</span> breakpoint keep y <span class="number">0x08048456</span> in func at tst.c:<span class="number">5</span></span><br><span class="line">(gdb) r &lt;--------------------- 运行程序，run命令简写</span><br><span class="line">Starting program: /home/benben /test/tst</span><br><span class="line"> </span><br><span class="line">Breakpoint <span class="number">1</span>, main () at tst.c:<span class="number">17</span> &lt;---------- 在断点处停住。</span><br><span class="line"><span class="number">17</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">(gdb) n &lt;--------------------- 单条语句执行，next命令简写。</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">20</span> result += i;</span><br><span class="line">(gdb) c &lt;--------------------- 继续运行程序，<span class="keyword">continue</span>命令简写。</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-100</span>] = <span class="number">5050</span> &lt;----------程序输出。</span><br><span class="line"> </span><br><span class="line">Breakpoint <span class="number">2</span>, func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="type">int</span> sum=<span class="number">0</span>,i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p i &lt;--------------------- 打印变量i的值，print命令简写。</span><br><span class="line">$<span class="number">1</span> = <span class="number">134513808</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">2</span> = <span class="number">1</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">8</span> sum+=i;</span><br><span class="line">(gdb) p i</span><br><span class="line">$<span class="number">3</span> = <span class="number">2</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line">$<span class="number">4</span> = <span class="number">3</span></span><br><span class="line">(gdb) bt &lt;--------------------- 查看函数堆栈。</span><br><span class="line">#<span class="number">0</span> func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"> </span><br><span class="line">#<span class="number">1</span> <span class="number">0x080484e4</span> in main () at tst.c:<span class="number">24</span></span><br><span class="line"> </span><br><span class="line">#<span class="number">2</span> <span class="number">0x400409ed</span> in __libc_start_main () from /lib/libc.so<span class="number">.6</span></span><br><span class="line">(gdb) finish &lt;--------------------- 退出函数。</span><br><span class="line">Run till <span class="built_in">exit</span> from #<span class="number">0</span> func (n=<span class="number">250</span>) at tst.c:<span class="number">5</span></span><br><span class="line"> </span><br><span class="line"><span class="number">0x080484e4</span> in main () at tst.c:<span class="number">24</span></span><br><span class="line"><span class="number">24</span> <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d&quot;</span>, func(<span class="number">250</span>) );</span><br><span class="line">Value returned is $<span class="number">6</span> = <span class="number">31375</span></span><br><span class="line">(gdb) c &lt;--------------------- 继续运行。</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-250</span>] = <span class="number">31375</span> &lt;----------程序输出。</span><br><span class="line"> </span><br><span class="line">Program exited with code <span class="number">027.</span> &lt;--------程序退出，调试结束。</span><br><span class="line">(gdb) q &lt;--------------------- 退出gdb。</span><br><span class="line">root@linux:/home/benben/test#</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html">【Linux】GDB用法详解(5小时快速教程)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习一个阶段的感受</title>
      <link href="/2022/12/04/%E6%94%BE%E5%81%87/"/>
      <url>/2022/12/04/%E6%94%BE%E5%81%87/</url>
      
        <content type="html"><![CDATA[<p>​因为疫情原因提前放假回家，大部分考试还不知道怎么考，现在要准备好材料，刷网课和弄选修论文，打算12月份学完C语言剩余两章，之后每天写个联系代码，linux方面继续应用层的编写学习，看看弄完后，可能要进入到C++，这样才能学习QT应用编程，东西还是不少的，先完成总的百分之40吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C issue1</title>
      <link href="/2022/11/25/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/25/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="scanf输入问题-输入缓冲区"><a href="#scanf输入问题-输入缓冲区" class="headerlink" title="scanf输入问题-输入缓冲区"></a>scanf输入问题-输入缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(b == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i++);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;?&quot;</span>);</span><br><span class="line"></span><br><span class="line">b=<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Done\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会得到</span><br><span class="line"></span><br><span class="line">​```c</span><br><span class="line">a<span class="comment">//输入a</span></span><br><span class="line"><span class="number">0</span>?a1?</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原因是因为scanf()函数会把回车、空格、Tab或一些不合理输入的字符当作此次输入的结束标志，它不会把这些字符输入到想要保存此次输入数据的变量中，而是把这些字符遗留在了输入缓冲区，那么，当下一次想要从标准输入中读取一个字符时，这个遗留的字符就正好充当了此次的输入字符。</p><p>程序在输入a后输入了回车来结束此次输入，那么回车就遗留在了输入缓冲区，当需要给c输入字符时，它自动的充当了输入的字符，因此，程序没有给我们输入c的字符的机会。</p><p>C语言为了解决这种问题，为我们提供了一种很方便的清空输入缓冲区的方式—-&gt;&gt;fflush()函数，fflush(stdin)它会把残留在输入缓冲区里的所有数据清空。头文件为stdio.h</p><p>或者使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//跳过该行剩下的内容。</span></span><br></pre></td></tr></table></figure><h3 id="错题：位运算"><a href="#错题：位运算" class="headerlink" title="错题：位运算"></a>错题：位运算</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,fun(<span class="number">2017</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">i = i&amp;(i<span class="number">-1</span>);<span class="comment">//i = i &amp; (i-1)，统计i二进制中有多少个1</span></span><br><span class="line">&#125;               <span class="comment">//i = i | (i+1)，统计i二进制中有多少个0</span></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *str[<span class="number">3</span>] =&#123;<span class="string">&quot;stra&quot;</span>, <span class="string">&quot;strb&quot;</span>, <span class="string">&quot;strc&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *p =str[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>,p++);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char<a href="https://so.csdn.net/so/search?q=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">指针数组</a>可以指向多个字符，直到遇到空为止。p本来指向第一个字符，但是因为是指针，所以要遇到空为止才算读完第一个‘字符’，后面p+1指向第二个字符，同样也是遇到空为止，同理p+2 所以输出为stra，tra，ra。注意循环里面是p++所以从p0开始打印啦。</p><h3 id="指针和自增自减的优先级"><a href="#指针和自增自减的优先级" class="headerlink" title="指针和自增自减的优先级"></a>指针和自增自减的优先级</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">3668</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ );<span class="comment">//拿到arr[0]的值1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p++ ); <span class="comment">//上条语句结束后指针往后移动了一下，</span></span><br><span class="line"><span class="comment">//指到到arr[1]，然后又++，因为是后++，</span></span><br><span class="line"><span class="comment">//所以解得是arr[1]的值3668</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//拿到上个++指向了arr[2],</span></span><br><span class="line"><span class="comment">//因为加了括号，所以先解值为5，然后++，</span></span><br><span class="line"><span class="comment">//把结果丢给了下语句。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*p)++ );<span class="comment">//括号优先级高，先解值，指针未移动，</span></span><br><span class="line"><span class="comment">//还指向着arr[2],拿到上个printf丢下来的值5+1=6，</span></span><br><span class="line"><span class="comment">//故解值为6，然6++,语句执行结束把6++结果丢给下一条语句。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p>在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量&#x2F;函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。</p><h3 id="extern”C”-作用"><a href="#extern”C”-作用" class="headerlink" title="extern”C” 作用"></a>extern”C” 作用</h3><p>C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时无法找到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//把所有函数声明放在这。</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="if…-endif的作用"><a href="#if…-endif的作用" class="headerlink" title="#if…#endif的作用"></a>#if…#endif的作用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">code 执行代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">code 屏蔽代码</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>同样可以“屏蔽”一段代码，你想把说明文字写在里面也可以，这些和“&#x2F;* *&#x2F;”都一样，但不一样的是：第一它允许嵌套（层数上限由预处理器决定）、第二你随时可以把“#if 0”改成“#if 1”来取消对某段代码的“屏蔽。</p><h3 id="结构体大小"><a href="#结构体大小" class="headerlink" title="结构体大小"></a>结构体大小</h3><p>结构体计算遵循对齐原则：</p><p>1）结构体变量首地址能够背其最宽基本类型成员的大小所整除；</p><p>2）结构体<u>每个成员相对于结构体首地址的偏移量都是成员大小的整数倍</u>，如有比那一起会在成员之间加上填充字节；</p><p>3）结构体的<u>总大小为结构体最宽基本类型成员的大小的整数倍</u>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p><strong>偏移量指的是结构体变量中成员的地址和结构体变量地址的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。</strong></p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> fname;<span class="comment">//第一个成员偏移量为0</span></span><br><span class="line">    <span class="type">int</span> age;<span class="comment">//第二个成员偏移量等于0+第一个的大小1=1但是得是第二个成员大小的整数倍所以是4</span></span><br><span class="line">    <span class="type">double</span> time;<span class="comment">//第三个成员偏移量等于4+第二个的大小4=8但是得是第三个成员大小的整数倍所以是8</span></span><br><span class="line">    <span class="type">float</span> old;<span class="comment">//第四个成员偏移量等于8+第三个的大小8=16但是得是第四个成员大小的整数倍所以是16</span></span><br><span class="line">&#125;;<span class="comment">//16+4=20但是得是所有的整数倍所以是24；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">student</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, <span class="keyword">sizeof</span>(student));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内存对齐是什么</p><p><a href="https://xie.infoq.cn/article/e071632f617563002552a7232">一文轻松理解内存对齐_程序员_C语言与CPP编程</a></p><h3 id="为什么要用malloc何时用"><a href="#为什么要用malloc何时用" class="headerlink" title="为什么要用malloc何时用"></a>为什么要用malloc何时用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *malloc(unsigned int num_bytes);//分配num_bytes字节的内存块</span><br></pre></td></tr></table></figure><p>返回值是void指针，void* 表示未确定类型的指针，void *可以指向任何类型的数据，更明确的说是指申请内存空间时还不知道用户是用这段空间来存储什么类型的数据（比如是char还是int或者其他数据类型），可以通过类型强制转化转化为其他任意类型指针。如果分配成功则返回指向被分配内存的指针(此存储区中的初始值不确定)，否则返回空指针NULL。</p><p>malloc（）是动态内存分配函数，用来向系统请求分配内存空间。当无法知道内存具体的位置时，想要绑定真正的内存空间，就要用到malloc（）函数。因为malloc只管分配内存空间，并不能对分配的空间进行初始化，所以申请到的内存中的值是随机的，经常会使用memset()进行置0操作后再使用。</p><p>与其配套的是free（），当申请到的空间不再使用时，要用free（）函数将内存空间释放掉，这样可以提高资源利用率，最重要的是—-就是因为它可以申请内存空间，然后根据需要进行释放，才被称为“动态内存分配”！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line">　　p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">128</span>);</span><br><span class="line">　　　　<span class="comment">//分配128个整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中</span></span><br><span class="line">　　<span class="type">double</span> *pd = (<span class="type">double</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>) * <span class="number">12</span>);　　</span><br><span class="line">　　　　<span class="comment">//分配12个double型存储单元，并将首地址存储到指针变量pd中</span></span><br><span class="line">　　<span class="built_in">free</span>(p);</span><br><span class="line">　　<span class="built_in">free</span>(pd);</span><br><span class="line">　　p = <span class="literal">NULL</span>;</span><br><span class="line">　　pd = <span class="literal">NULL</span>;　　</span><br><span class="line">　　指针用完赋值<span class="literal">NULL</span>是一个很好的习惯。</span><br></pre></td></tr></table></figure><p>C语言中的联合</p><p>联合是在同一个内存空间中存储不同的数据类型（不能同时存在多个类型）。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> digit;</span><br><span class="line"><span class="type">double</span> bigf1;</span><br><span class="line"><span class="type">char</span> letter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上声明的结构只能存储整型或浮点型或者字符型的变量，不能同时存在。</p><p><u>初始化联合</u></p><p>有三种方法初始化联合：<br>1、把一个联合初始化为另一个同类型的联合</p><p>2、初始化联合的第一个成员</p><p>3、使用指定初始化器（C99标准）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">first_car</span>;</span></span><br><span class="line">first_car.car_name=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">sec_car</span>=</span>first_car; <span class="comment">//把一个联合初始化为另一个同类型的联合</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">car_a</span>=</span>&#123;<span class="string">&#x27;B&#x27;</span>&#125;;　　　　　<span class="comment">//初始化联合的第一个成员</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">car</span> <span class="title">car_b</span>=</span>&#123;.car_num=<span class="number">2</span>&#125;;　<span class="comment">//使用指定初始化器来初始化联合car_b</span></span><br></pre></td></tr></table></figure><p>用指针访问联合时候也是用-&gt;运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu -&gt;digit;</span><br></pre></td></tr></table></figure><h3 id="传递结构体数组地址"><a href="#传递结构体数组地址" class="headerlink" title="传递结构体数组地址"></a>传递结构体数组地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTITL  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXAUTL  40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBKS  100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> title [MAXTITL];</span><br><span class="line"><span class="type">char</span> author[MAXAUTL];</span><br><span class="line"><span class="type">float</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">srt</span><span class="params">( <span class="keyword">struct</span> book prt[], <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> book pt[], <span class="type">int</span> m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> *<span class="title">pst</span>;</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">pst = &amp;library[<span class="number">0</span>];</span><br><span class="line">menu();</span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; MAXBKS; i++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s_gets(library[i].title, MAXTITL) == <span class="literal">NULL</span> || library[i].title[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入作者\n&quot;</span>);</span><br><span class="line">s_gets(library[i].author, MAXAUTL);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入价格\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;library[i].value);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入书名\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">srt(library, i);</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; i; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名%s作者%s价格%.2f\n&quot;</span>, library[t].title, library[t].author, library[t].value);</span><br><span class="line">&#125;</span><br><span class="line">change(library, i);</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; i; t++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;书名%s作者%s价格%.2f\n&quot;</span>, library[t].title, library[t].author, library[t].value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">char</span> * find;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = <span class="built_in">strchr</span>(st, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(find)</span><br><span class="line">* find = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************************************************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please enter the book title and author and value \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*************************************************************\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入书名\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">srt</span><span class="params">( <span class="keyword">struct</span> book prt[], <span class="type">int</span> n)</span><span class="comment">//价格排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">quantity</span>;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)<span class="comment">//冒泡排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(prt[j].value &gt; prt[j+<span class="number">1</span>].value)</span><br><span class="line">&#123;</span><br><span class="line">quantity = prt[j];</span><br><span class="line">prt[j] = prt[j+<span class="number">1</span>];</span><br><span class="line">prt[j+<span class="number">1</span>] = quantity;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="keyword">struct</span> book pt[], <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">letter</span>;</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++)                <span class="comment">//冒泡排序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m<span class="number">-1</span>-i; j++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">int</span>)pt[j].title[<span class="number">0</span>]&gt;(<span class="type">int</span>)pt[j+<span class="number">1</span>].title[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">letter = pt[j];</span><br><span class="line">pt[j] = pt[j+<span class="number">1</span>];</span><br><span class="line">pt[j+<span class="number">1</span>] = letter;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——字符串处理</title>
      <link href="/2022/11/23/Linux%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2022/11/23/Linux%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><p>设备输出stdout、设备键盘输入stdin、设备错误显示stderr。</p><p>常用的字符串输入函数有putchar()、puts()、fputc()、fputs()只能输出字符串函数，不像printf可以格式化输出，所以一般用printf。</p><p><strong>puts</strong>函数原型可通过man 3 puts查看。</p><p>使用 puts()函数连换行符’ \n ‘都省了，函数内部会自动在其后添加一个换行符。</p><p><strong>putchar</strong>函数原型可通过man 3 putchar查看。</p><p>putchar()函数可以把参数 c 指定的字符（一个无符号字符）输出到标准输出设备，其输出可以是一个字符，可以是介于 0~127 之间的一个十进制整型数（包含 0 和 127，输出其对应的 ASCII 码字符），也可以是用 char 类型定义好的一个字符型变量。</p><p><strong>fputc</strong>函数原型可通过man 3 fputc查看</p><p>fputc()与 putchar()类似，也用于输出参数 c 指定的字符（一个无符号字符），与 putchar()区别在于，putchar()只能输出到标准输出设备，而 fputc()可把字符输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。</p><p><strong>fputs</strong></p><p>fputs()与 puts()类似，也用于输出一条字符串，与 puts()区别在于，puts()只能输出到标准输出设备，而 fputs()可把字符串输出到指定的文件中，既可以是标准输出、标准错误设备，也可以是一个普通文件。</p><h3 id="内存填充"><a href="#内存填充" class="headerlink" title="内存填充"></a>内存填充</h3><p>在编程中，经常需要将某一块内存中的数据全部设置为指定的值，譬如在定义数组、结构体这种类型变量时，通常需要对其进行初始化操作，而初始化操作一般都是将其占用的内存空间全部填充为 0。</p><p><strong>memset函数</strong>用于将某一块内存的数据全部设置为指定的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">int</span> c, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>s：需要进行数据填充的内存空间起始地址。<br>c：要被设置的值，该值以 int 类型传递。但在使用过程中是以无符号字符形式<br>n：填充的字节数。</p><p><strong>bzero函数</strong>用于将一块内存的数据都设置为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *s, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>s：内存空间的起始地址。<br>n：填充的字节数。<br>返回值：无返回值。</p><h3 id="Linux正则表达式"><a href="#Linux正则表达式" class="headerlink" title="Linux正则表达式"></a>Linux正则表达式</h3><p>正则表达式，又称为规则表达式（英语: Regular Expression），正则表达式通常被用来检索、替换那些符合某个模式（规则）的字符串，正则表达式描述了一种字符串的匹配模式（pattern），可以用来检查一个给定的字符串中是否含有某种子字符串、将匹配的字符串替换或者从某个字符串中取出符合某个条件的子字符串。</p><p>正则表达式其实也是一个字符串，该字符串由普通字符（譬如，数字 0~9、大小写字母以及其它字符）和特殊字符（称为“元字符”）所组成，由这些字符组成一个“规则字符串”，这个“规则字符串”用来表达对给定字符串的一种查找、匹配逻辑。</p><p><a href="https://www.runoob.com/regexp/regexp-intro.html">正则表达式 菜鸟教程</a></p><p>C语言中使用正则表达式一般分为三步：</p><p>1.编译正则表达式regcomp()</p><p>2匹配正则表达式regexec()</p><p>3释放正则表达式regfree()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">regmatch_t</span> pmatch = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="type">regex_t</span> reg;</span><br><span class="line"> <span class="type">char</span> errbuf[<span class="number">64</span>];</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> *sptr;</span><br><span class="line"> <span class="type">int</span> length;</span><br><span class="line"> <span class="type">int</span> nmatch; <span class="comment">//最多匹配出的结果</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">4</span> != argc) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="comment">/**********************************</span></span><br><span class="line"><span class="comment"> * 执行程序时需要传入两个参数:</span></span><br><span class="line"><span class="comment"> * arg1: 正则表达式</span></span><br><span class="line"><span class="comment"> * arg2: 待测试的字符串</span></span><br><span class="line"><span class="comment"> * arg3: 最多匹配出多少个结果</span></span><br><span class="line"><span class="comment"> **********************************/</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;regex&gt; &lt;string&gt; &lt;nmatch&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(ret = regcomp(&amp;reg, argv[<span class="number">1</span>], REG_EXTENDED)) </span><br><span class="line">    &#123;</span><br><span class="line"> regerror(ret, &amp;reg, errbuf, <span class="keyword">sizeof</span>(errbuf));</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regcomp error: %s\n&quot;</span>, errbuf);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 赋值操作 */</span></span><br><span class="line"> sptr = argv[<span class="number">2</span>]; <span class="comment">//待测试的字符串</span></span><br><span class="line"> length = <span class="built_in">strlen</span>(argv[<span class="number">2</span>]);<span class="comment">//获取字符串长度</span></span><br><span class="line"> nmatch = atoi(argv[<span class="number">3</span>]); <span class="comment">//获取最大匹配数</span></span><br><span class="line"> <span class="comment">/* 匹配正则表达式 */</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nmatch; j++) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="type">char</span> temp_str[<span class="number">100</span>];</span><br><span class="line"> <span class="comment">/* 调用 regexec 匹配正则表达式 */</span></span><br><span class="line"> <span class="keyword">if</span>(ret = regexec(&amp;reg, sptr, <span class="number">1</span>, &amp;pmatch, <span class="number">0</span>)) </span><br><span class="line">    &#123;</span><br><span class="line"> regerror(ret, &amp;reg, errbuf, <span class="keyword">sizeof</span>(errbuf));</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;regexec error: %s\n&quot;</span>, errbuf);</span><br><span class="line"> <span class="keyword">goto</span> out;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">-1</span> != pmatch.rm_so) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="keyword">if</span> (pmatch.rm_so == pmatch.rm_eo) </span><br><span class="line">        &#123;<span class="comment">//空字符串</span></span><br><span class="line"> sptr += <span class="number">1</span>;</span><br><span class="line"> length -= <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">//打印出空字符串</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt;= length)<span class="comment">//如果已经移动到字符串末尾、则退出</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">continue</span>; <span class="comment">//从 for 循环开始执行</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">memset</span>(temp_str, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(temp_str));<span class="comment">//清零缓冲区</span></span><br><span class="line"> <span class="built_in">memcpy</span>(temp_str, sptr + pmatch.rm_so,</span><br><span class="line"> pmatch.rm_eo - pmatch.rm_so);<span class="comment">//将匹配出来的子字符串拷贝到缓冲区</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp_str); <span class="comment">//打印字符串</span></span><br><span class="line">sptr += pmatch.rm_eo;</span><br><span class="line"> length -= pmatch.rm_eo;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt;= length)</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 释放正则表达式 */</span></span><br><span class="line">out:</span><br><span class="line"> regfree(&amp;reg);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习一个阶段的感受</title>
      <link href="/2022/11/18/%E9%9A%8F%E7%AC%94/"/>
      <url>/2022/11/18/%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<p>​目前在linux上学习了一个浅显的阶段，学会了命令行的一些常规的操作，也对Linux的内核有了少部分的了解，目前在C语言上的系统学习进入了尾声，之后应该就要时常复习C语言的编程，之前没有编写过底层，现在感觉C语言的应用编写确实复杂，主要是东西有点多，记不下来，打算趁着写选修论文的时候，用平时笔记复习复习，再加强一下C语言前些章节的编写能力，跨过这一阶段，再思考下一阶段科技树点哪的问题吧，科技树可真多呀，只能说还好现在课业不是很重。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文件属性</title>
      <link href="/2022/11/18/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/2022/11/18/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>正所谓Linux下皆文件，系统下一共分为7种文件：</p><p><strong>①普通文件</strong></p><p>普通文件（regular file）在 Linux 系统下是最常见的，譬如文本文件、二进制文件，我们编写的源代码文件这些都是普通文件。</p><p>普通文件分为文本文件和二进制文件。</p><p>文本文件：文件中的内容是由文本构成的，所谓文本指的是 ASCII 码字符。文件中的内容其本质上都是数字。</p><p>二进制文件：二进制文件中存储的本质上也是数字，只不过对于二进制文件来说，这些数字并不是文本字符编码，而是真正的数字。譬如 Linux 系统下的可执行文件、C 代码编译之后得到的.o 文件、.bin 文件等都是二进制件。</p><p><strong>②目录文件</strong></p><p>目录（directory）就是文件夹，文件夹在 Linux 系统中也是一种文件，是一种特殊文件。</p><p><strong>③字符设备文件和块设备文件</strong></p><p>Linux 系统下，一切皆文件，也包括各种硬件设备。设备文件（字符设备文件、块设备文件）对应的是硬件设备，在 Linux 系统中，硬件设备会对应到一个设备文件，应用程序通过对设备文件的读写来操控、使用硬件设备。</p><p>Linux 系统中，可将硬件设备分为字符设备和块设备，所以就有了字符设备文件和块设备文件两种文件类型。虽然有设备文件，但是设备文件并不对应磁盘上的一个文件，也就是说设备文件并不存在于磁盘中，而是由文件系统虚拟出来的，一般是由内存来维护，当系统关机时，设备文件都会消失；字符设备文件一般存放在 Linux 系统&#x2F;dev&#x2F;目录下。</p><p><strong>④符号链接文件</strong></p><p>符号链接文件（link）类似于 Windows 系统中的快捷方式文件，是一种特殊文件，它的内容指向的是另一个文件路径，当对符号链接文件进行操作时，系统根据情况会对这个操作转移到它指向的文件上去，而不是对它本身进行操作。</p><p><strong>⑤管道文件</strong></p><p>管道文件（pipe）主要用于进程间通信。</p><p><strong>⑥套接字文件</strong></p><p>套接字文件（socket）也是一种进程间通信的方式，与管道文件不同的是，它们可以在不同主机上的进程间通信，实际上就是网络通信。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stat</span> test_file<span class="comment">##可以查看文件属性</span></span></span><br></pre></td></tr></table></figure><p>这个命令内部就是通过调用 stat()函数来获取文件属性的，stat 函数是 Linux 中的系统调用，用于获取文件相关的信息，函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p>函数参数及返回值含义如下：<br>pathname：用于指定一个需要查看属性的文件路径。<br>buf：struct stat 类型指针，用于指向一个 struct stat 结构体变量。调用 stat 函数的时候需要传入一个 struct<br>stat 变量的指针，获取到的文件属性信息就记录在 struct stat 结构体中，稍后给大家介绍 struct stat 结构体中有记录了哪些信息。<br>返回值：成功返回 0；失败返回-1，并设置 error。</p><h4 id="struct-stat-结构体"><a href="#struct-stat-结构体" class="headerlink" title="struct stat 结构体"></a>struct stat 结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* 文件所在设备的 ID */</span></span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* 文件对应 inode 节点编号 */</span></span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* 文件对应的模式 */</span></span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* 文件的链接数 */</span></span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* 文件所有者的用户 ID */</span></span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* 文件所有者的组 ID */</span></span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* 设备号（指针对设备文件） */</span></span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* 文件大小（以字节为单位） */</span></span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* 文件内容存储的块大小 */</span></span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* 文件内容所占块数 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span> <span class="comment">/* 文件最后被访问的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span> <span class="comment">/* 文件内容最后被修改的时间 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span> <span class="comment">/* 文件状态最后被改变的时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="st-mode变量"><a href="#st-mode变量" class="headerlink" title="st_mode变量"></a>st_mode变量</h4><p>st_mode 是 structstat 结构体中的一个成员变量，是一个 32 位无符号整形数据，该变量记录了文件的类型、文件的权限这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/st_mode.png"></p><p>这些 bit 位表达内容与 open 函数的 mode 参数相对应，这里不再重述。同样，在 mode 参数中表示权限的宏定义，在这里也是可以使用的，这些宏定义如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">S_IRWXU 00700 owner has read, write, and execute permission</span><br><span class="line">S_IRUSR 00400 owner has read permission</span><br><span class="line">S_IWUSR 00200 owner has write permission</span><br><span class="line">S_IXUSR 00100 owner has execute permission</span><br><span class="line">S_IRWXG 00070 group has read, write, and execute permission</span><br><span class="line">S_IRGRP 00040 group has read permission</span><br><span class="line">S_IWGRP 00020 group has write permission</span><br><span class="line">S_IXGRP 00010 group has execute permission</span><br><span class="line">S_IRWXO 00007 others (not in group) have read, write, and execute permission</span><br><span class="line">S_IROTH 00004 others have read permission</span><br><span class="line">S_IWOTH 00002 others have write permission</span><br><span class="line">S_IXOTH 00001 others have execute permission</span><br><span class="line"></span><br><span class="line">S_IFSOCK 0140000 socket（套接字文件）</span><br><span class="line">S_IFLNK 0120000 symbolic link（链接文件）</span><br><span class="line">S_IFREG 0100000 regular file（普通文件）</span><br><span class="line">S_IFBLK 0060000 block device（块设备文件）</span><br><span class="line">S_IFDIR 0040000 directory（目录）</span><br><span class="line">S_IFCHR 0020000 character device（字符设备文件）</span><br><span class="line">S_IFIFO 0010000 FIFO（管道文件）</span><br><span class="line"></span><br><span class="line">S_ISREG(m) #判断是不是普通文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISDIR(m) #判断是不是目录，如果是返回 true，否则返回 false</span><br><span class="line">S_ISCHR(m) #判断是不是字符设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISBLK(m) #判断是不是块设备文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISFIFO(m) #判断是不是管道文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISLNK(m) #判断是不是链接文件，如果是返回 true，否则返回 false</span><br><span class="line">S_ISSOCK(m) #判断是不是套接字文件，如果是返回 true，否则返回 false</span><br></pre></td></tr></table></figure><h4 id="struct-timespec结构体"><a href="#struct-timespec结构体" class="headerlink" title="struct timespec结构体"></a>struct timespec结构体</h4><p>该结构体定义在头文件中，是 Linux 系统中时间相关的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">time_t</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"> <span class="type">syscall_slong_t</span> tv_nsec; <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="fstat和lstat函数"><a href="#fstat和lstat函数" class="headerlink" title="fstat和lstat函数"></a>fstat和lstat函数</h4><p><strong>fstat函数</strong></p><p>fstat 与 stat 区别在于，stat 是从文件名出发得到文件属性信息，不需要先打开文件；而 fstat 函数则是从文件描述符出发得到文件属性信息，所以使用 fstat 函数之前需要先打开文件得到文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><p><strong>lstat 函数</strong></p><p>lstat()与 stat、fstat 的区别在于，对于符号链接文件，stat、fstat 查阅的是符号链接文件所指向的文件对应的文件属性信息，而 lstat 查阅的是符号链接文件本身的属性信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *buf)</span>;</span><br></pre></td></tr></table></figure><h3 id="文件属主"><a href="#文件属主" class="headerlink" title="文件属主"></a>文件属主</h3><p>Linux 是一个多用户操作系统，系统中一般存在着好几个不同的用户，而 Linux 系统中的每一个文件都有一个与之相关联的用户和用户组，通过这个信息可以判断文件的所有者和所属组。</p><p>文件所有者表示该文件属于“谁”，也就是属于哪个用户。一般来说文件在创建时，其所有者就是创建该文件的那个用户。文件所属组则表示该文件属于哪一个用户组。在 Linux 中，系统并不是通过用户名或用户组名来识别不同的用户和用户组，而是通过 ID。ID 就是一个编号，Linux 系统会为每一个用户或用户组分配一个 ID，将用户名或用户组名与对应的 ID 关联起来，所以系统通过用户 ID（UID）或组 ID（GID）就可以识别出不同的用户和用组。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/ID.png"></p><h4 id="有效用户-ID-和有效组-ID"><a href="#有效用户-ID-和有效组-ID" class="headerlink" title="有效用户 ID 和有效组 ID"></a>有效用户 ID 和有效组 ID</h4><p>这是进程所持有的概念，对于文件来说，并无此属性！有效用户 ID 和有效组 ID 是站在操作系统的角度，用于给操作系统判断当前执行该进程的用户在当前环境下对某个文件是否拥有相应的权限。</p><p>当进行权限检查时，并不是通过进程的实际用户和实际组来参与权限检查的，而是通过有效用户和有效组来参与文件权限检查。</p><p><strong>chown函数</strong></p><p>chown 是一个系统调用，该系统调用可用于改变文件的所有者（用户 ID）和所属组（组 ID）。其实在Linux 系统下也有一个 chown 命令，该命令的作用也是用于改变文件的所有者和所属组，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> root:root testApp.c<span class="comment">##该命令的作用也是用于改变文件的所有者和所属组</span></span></span><br></pre></td></tr></table></figure><h4 id="chown函数原型"><a href="#chown函数原型" class="headerlink" title="chown函数原型"></a>chown函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值如下所示：<br>pathname：用于指定一个需要修改所有者和所属组的文件路径。<br>owner：将文件的所有者修改为该参数指定的用户（以用户 ID 的形式描述）；<br>group：将文件的所属组修改为该参数指定的用户组（以用户组 ID 的形式描述）；<br>返回值：成功返回 0；失败将返回-1，兵并且会设置 errno。</p><p>有以下两个限制条件：</p><p>⚫ 只有超级用户进程能更改文件的用户 ID；<br>⚫ 普通用户进程可以将文件的组 ID 修改为其所从属的任意附属组 ID，前提条件是该进程的有效用户 ID 等于文件的用户 ID；而超级用户进程可以将文件的组 ID 修改为任意值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Linux 系统下，可以使用 getuid 和 getgid 两个系统调用分别用于获取当前进程的用户 ID 和用户组ID，这里说的进程的用户 ID 和用户组 ID 指的就是进程的实际用户 ID 和实际组 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;uid: %d\n&quot;</span>, getuid());</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == chown(<span class="string">&quot;./test_file&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;chown error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h3><p>struct stat 结构体中的 st_mode 字段记录了文件的访问权限位。当提及到文件时，并不仅仅指的是普通文件；所有文件类型（目录、设备文件）都有访问权限（access permission）。</p><p>文件的权限可以分为两个大类，分别是<u>普通权限和特殊权限</u>（也可称为附加权限）。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls-l##查看访问权限</span><br></pre></td></tr></table></figure><p><strong><u>-rwxrwxr-x</u></strong></p><p>-表示文件类型，前三位rwx为所有者权限，中间三位为同组用户权限，后三位为其它用户权限。</p><p>r表示具有读权限；w表示具有写权限；x表示具有执行权限；-表示没有权限</p><p><em><strong>当进程每次对文件进行读、写、执行等操作时，内核就会对文件进行访问权限检查，以确定该进程对文件是否拥有相应的权限。</strong></em>而对于进程来说，参与文件权限检查的是进程的有效用户、有效用户组以及进程的附属组用户。</p><p>如何判断权限，首先要搞清楚该进程对于需要进行操作的文件来说是属于哪一类“角色”：<br>⚫ 如果进程的有效用户 ID 等于文件所有者 ID（st_uid），意味着该进程以文件所有者的角色存在；<br>⚫ 如果进程的有效用户 ID 并不等于文件所有者 ID，意味着该进程并不是文件所有者身份；但是进程<br>的有效用户组 ID 或进程的附属组 ID 之一等于文件的组 ID（st_gid），那么意味着该进程以文件所<br>属组成员的角色存在，也就是文件所属组的同组用户成员。<br>⚫ 如果进程的有效用户 ID 不等于文件所有者 ID、并且进程的有效用户组 ID 或进程的所有附属组 ID<br>均不等于文件的组 ID（st_gid），那么意味着该进程以其它用户的角色存在。<br>⚫ 如果进程的有效用户 ID 等于 0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90.png"></p><p>宏定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S_ISUID 04000 set-user-ID bit</span><br><span class="line">S_ISGID 02000 set-group-ID bit (see below)</span><br><span class="line">S_ISVTX 01000 sticky bit (see below)</span><br></pre></td></tr></table></figure><p>譬如通过 st_mode 变量判断文件是否设置了 set-user-ID 位权限，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (st.st_mode &amp; S_ISUID) &#123;</span><br><span class="line"><span class="comment">//设置了 set-user-ID 位权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//没有设置 set-user-ID 位权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种权限位的具体作用：</p><p>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有的权限、以文件所有者的身份操作该文件。<br>⚫ 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了文件所属组成员的权限、以文件所属组成员的身份操作该文件。</p><h4 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h4><p>⚫ 目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。<br>⚫ 目录的写权限：可以在目录下创建文件、删除文件。<br>⚫ 目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。</p><p>要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限。反之，若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。</p><h4 id="检查文件权限"><a href="#检查文件权限" class="headerlink" title="检查文件权限"></a>检查文件权限</h4><p>文件的权限检查不只关于文件本身的权限，还需要涉及到文件所在目录的权限，只有同时都满足了，才能通过操作系统的权限检查，进而才可以对文件进行相关操作。可以通过access来检查执行进程的用户是否对该文件拥有应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>pathname：需要进行权限检查的文件路径。<br>mode：该参数可以取以下值：<br>⚫ F_OK：检查文件是否存在<br>⚫ R_OK：检查是否拥有读权限<br>⚫ W_OK：检查是否拥有写权限<br>⚫ X_OK：检查是否拥有执行权限</p><p>返回值：检查项通过则返回 0，表示拥有相应的权限并且文件存在；否则返回-1，如果多个检查项组合在一起，只要其中任何一项不通过都会返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%: file does not exist.\n&quot;</span>, MY_FILE);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 检查权限 */</span></span><br><span class="line"> ret = access(MY_FILE, R_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Read permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, W_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: Yes\n&quot;</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Write permission: NO\n&quot;</span>);</span><br><span class="line"> ret = access(MY_FILE, X_OK);</span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: Yes\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Execution permission: NO\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><p>在 Linux 系统下，可以使用 chmod 命令修改文件权限，该命令内部实现方法其实是调用了 chmod 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要进行权限修改的文件路径，若该参数所指为符号链接，实际改变权限的文件是符号链接所指向的文件，而不是符号链接文件本身。<br>mode：该参数用于描述文件权限，与 open 函数的第三个参数一样，这里不再重述，可以直接使用八进制数据来描述，也可以使用相应的权限宏（单个或通过位或运算符” | “组合）。<br>返回值：成功返回 0；失败返回-1，并设置 errno。</p><p>fchmod()与 chmod()的区别在于使用了文件描述符来代替文件路径，就像是 fstat 与 stat 的区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchmod</span><span class="params">(<span class="type">int</span> fd, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><h4 id="umask函数"><a href="#umask函数" class="headerlink" title="umask函数"></a>umask函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ umask##查看/设置权限掩码</span><br></pre></td></tr></table></figure><p>权限掩码主要用于对新建文件的权限进行屏蔽。权限掩码的表示方式与文件权限的表示方式相同，但是需要去除特殊权限位，umask 不能对特殊权限位进行屏蔽。</p><p>umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。进程的umask 通常继承至其父进程，譬如在 Ubuntu shell终端下执行的应用程序，它的 umask 继承至该 shell 进程。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">mode_t</span> <span class="title function_">umask</span><span class="params">(<span class="type">mode_t</span> mask)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>mask：需要设置的权限掩码值，可以发现 make 参数的类型与 open 函数、chmod 函数中的 mode 参数对应的类型一样，所以其表示方式也是一样的，前面也给大家介绍了，既可以使用数字表示（譬如八进制数），也可以直接使用宏（S_IRUSR、S_IWUSR 等）。<br>返回值：返回设置之前的 umask 值，也就是旧的 umask。</p><h3 id="文件的时间属性"><a href="#文件的时间属性" class="headerlink" title="文件的时间属性"></a>文件的时间属性</h3><p>文件最后被访问的时间、文件内容最后被修改的时间以及文件状态最后被改变的时间，分别记录在 struct stat 结构体的 st_atim、st_mtim 以及 st_ctim 变量中。</p><table><thead><tr><th align="center">字段</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">st_atim</td><td align="center">文件最后被访问的时间</td></tr><tr><td align="center">st_mtim</td><td align="center">文件内容最后被修改的时间</td></tr><tr><td align="center">st_ctim</td><td align="center">文件状态最后被改变的时间</td></tr></tbody></table><p>⚫ 文件最后被访问的时间：访问指的是读取文件内容，文件内容最后一次被读取的时间，譬如使用read()函数读取文件内容便会改变该时间属性；<br>⚫ 文件内容最后被修改的时间：文件内容发生改变，譬如使用 write()函数写入数据到文件中便会改变该时间属性；<br>⚫ 文件状态最后被改变的时间：状态更改指的是该文件的 inode 节点最后一次被修改的时间，譬如更改文件的访问权限、更改文件的用户 ID、用户组 ID、更改链接数等，但它们并没有更改文件的实际内容，也没有访问（读取）文件内容。inode 中包含了很多文件信息，譬如：文件字节大小、文件所有者、文件对应的读&#x2F;写&#x2F;执行权限、文件时间戳（时间属性）、文件数据存储的 block（块）等，所以由此可知，状态的更改指的就是 inode 节点内容的更改。譬如 chmod()、chown()等<br>这些函数都能改变该时间属性。</p><p>列出了一些系统调用或 C 库函数对文件时间属性的影响，有些操作并不仅仅只会影响文件本身的时间属性，还会影响到其父目录的相关时间属性。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/time.png"></p><h4 id="utime-、utimes-修改时间属性"><a href="#utime-、utimes-修改时间属性" class="headerlink" title="utime()、utimes()修改时间属性"></a>utime()、utimes()修改时间属性</h4><p>utime()函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utime</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> utimbuf *times)</span>;</span><br></pre></td></tr></table></figure><p>filename：需要修改时间属性的文件路径。<br>times：将时间属性修改为该参数所指定的时间值，times 是一个 struct utimbuf 结构体类型的指针，如果times 参数设置为 NULL，则会将文件的访问时间和修改时间设置为系统当前时间。<br>返回值：成功返回值 0；失败将返回-1，并会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utimbuf</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">time_t</span> actime; <span class="comment">/* 访问时间 */</span></span><br><span class="line"><span class="type">time_t</span> modtime; <span class="comment">/* 内容修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体中包含了两个 time_t 类型的成员，分别用于表示访问时间和内容修改时间，time_t 类型其实就是 long int 类型。</p><p>同样对于文件来说，时间属性也是文件非常重要的属性之一，对文件时间属性的修改也不是任何用户都可以随便修改的，只有以下两种进程可对其进行修改：<br>⚫ 超级用户进程（以 root 身份运行的进程）。<br>⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。<br>⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。<br>除以上三种情况之外的用户进程将无法对文件时间戳进行修改。</p><p>utimes函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">utimes</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="keyword">struct</span> timeval times[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>filename：需要修改时间属性的文件路径。<br>times：将时间属性修改为该参数所指定的时间值，times 是一个 struct timeval 结构体类型的数组，数组共有两个元素，第一个元素用于指定访问时间，第二个元素用于指定内容修改时间，稍后给大家介绍，如果times 参数为 NULL，则会将文件的访问时间和修改时间设置为当前时间。<br>返回值：成功返回 0；失败返回-1，并且会设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">/* 微秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="futimens-、utimensat-修改时间属性"><a href="#futimens-、utimensat-修改时间属性" class="headerlink" title="futimens()、utimensat()修改时间属性"></a>futimens()、utimensat()修改时间属性</h4><p>futimens()、utimensat()函数是两个系统调用由于显示修改文件时间。</p><p>这两个系统调用相对于 utime 和 utimes 函数有以下三个优点：<br>⚫ 可按纳秒级精度设置时间戳。相对于提供微秒级精度的 utimes()，这是重大改进！<br>⚫ 可单独设置某一时间戳。譬如，只设置访问时间、而修改时间保持不变，如果要使用 utime()或 utimes()来实现此功能，则需要首先使用 stat()获取另一个时间戳的值，然后再将获取值与打算变更的时间戳一同指定。<br>⚫ 可独立将任一时间戳设置为当前时间。使用 utime()或 utimes()函数虽然也可以通过将 times 参数设置为NULL 来达到将时间戳设置为当前时间的效果，但是不能单独指定某一个时间戳，必须全部设置为当前时间（不考虑使用额外函数获取当前时间的方式，譬如 time()）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">futimens</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> timespec times[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符。<br>times：将时间属性修改为该参数所指定的时间值，times 指向拥有 2 个 struct timespec 结构体类型变量的数组，数组共有两个元素，第一个元素用于指定访问时间，第二个元素用于指定内容修改时间。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>该函数的时间戳可以按下列 4 种方式之一进行指定：<br>⚫ 如果 times 参数是一个空指针，也就是 NULL，则表示将访问时间和修改时间都设置为当前时间。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，任一数组元素的 tv_nsec 字段的值设置为 UTIME_NOW，则表示相应的时间戳设置为当前时间，此时忽略相应的 tv_sec 字段。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，任一数组元素的 tv_nsec 字段的值设置为 UTIME_OMIT，则表示相应的时间戳保持不变，此时忽略 tv_sec 字段。<br>⚫ 如果 times 参数指向两个 struct timespec 结构体类型变量的数组，且 tv_nsec 字段的值既不是UTIME_NOW 也不是 UTIME_OMIT，在这种情况下，相应的时间戳设置为相应的 tv_sec 和 tv_nsec字段指定的值。</p><p>使用 <u>futimens()函数只有以下进程，可对文件时间戳进行修改：</u><br>⚫ 超级用户进程。<br>⚫ 在参数 times 等于 NULL 的情况下，对文件拥有写权限的进程。<br>⚫ 有效用户 ID 与该文件用户 ID（文件所有者）相匹配的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FILE <span class="string">&quot;./test_file&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp_arr</span>[2];</span></span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 检查文件是否存在 */</span></span><br><span class="line"> ret = access(MY_FILE, F_OK);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Error: %s file does not exist!\n&quot;</span>, MY_FILE);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(MY_FILE, O_RDONLY);</span><br><span class="line"> <span class="keyword">if</span> (fd == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 修改文件时间戳 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"> ret = futimens(fd, <span class="literal">NULL</span>); <span class="comment">//同时设置为当前时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> tmsp_arr[<span class="number">0</span>].tv_nsec = UTIME_OMIT;<span class="comment">//访问时间保持不变</span></span><br><span class="line"> tmsp_arr[<span class="number">1</span>].tv_nsec = UTIME_NOW;<span class="comment">//内容修改时间设置为当期时间</span></span><br><span class="line"> ret = futimens(fd, tmsp_arr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> tmsp_arr[<span class="number">0</span>].tv_nsec = UTIME_NOW;<span class="comment">//访问时间设置为当前时间</span></span><br><span class="line"> tmsp_arr[<span class="number">1</span>].tv_nsec = UTIME_OMIT;<span class="comment">//内容修改时间保持不变</span></span><br><span class="line"> ret = futimens(fd, tmsp_arr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;futimens error&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line">err:</span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utimensat()函数功能也是一样的，具体可以使用man 2  utimensat查询用法</p><h3 id="符号链接与硬链接"><a href="#符号链接与硬链接" class="headerlink" title="符号链接与硬链接"></a>符号链接与硬链接</h3><p>在 Linux 系统中有两种链接文件，分为软链接（也叫符号链接）文件和硬链接文件，软链接文件也就是前面给大家的 Linux 系统下的七种文件类型之一，其作用类似于 Windows 下的快捷方式。硬链接两个文件相互影响。</p><p>复习一下shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ln</span> 源文件 链接文件<span class="comment">##硬链接</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">ln-s 源文件 链接文件<span class="comment">##软链接</span></span></span><br></pre></td></tr></table></figure><p>使用 ln 命令创建的两个硬链接文件与源文件 test_file 都拥有相同的 inode 号，既然inode 相同，也就意味着它们指向了物理硬盘的同一个区块，仅仅只是文件名字不同而已，创建出来的硬链接文件与源文件对文件系统来说是完全平等的关系。</p><p>当为文件每创建一个硬链接，inode 节点上的链接数就会加一，每删除一个硬链接，inode 节点上的链接数就会减一，直到为 0，inode 节点和对应的数据块才会被文件系统所回收，也就意味着文件已经从文件系统中被删除了。</p><p>软链接文件与源文件有着不同的 inode 号，所以也就是意味着它们之间有着不同的数据块，但是软链接文件的数据块中存储的是源文件的路径名，链接文件可以通过这个路径找到被链接的源文件，它们之间类似于一种“主从”关系，当源文件被删除之后，软链接文件依然存在，但此时它指向的是一个无效的文件路径，这种链接文件被称为悬空链接。</p><p>⚫ 不能对目录创建硬链接（超级用户可以创建，但必须在底层文件系统支持的情况下）。<br>⚫ 硬链接通常要求链接文件和源文件位于同一文件系统中。<br>而软链接文件的使用并没有上述限制条件，优点如下所示：<br>⚫ 可以对目录创建软链接；<br>⚫ 可以跨越不同文件系统；<br>⚫ 可以对不存在的文件创建软链接。</p><h4 id="创建硬链接link"><a href="#创建硬链接link" class="headerlink" title="创建硬链接link"></a>创建硬链接link</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>oldpath：用于指定被链接的源文件路径，应避免 oldpath 参数指定为软链接文件，为软链接文件创建硬链接没有意义，虽然并不会报错。<br>newpath：用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。<br>返回值：成功返回 0；失败将返回-1，并且会设置 errno。</p><h4 id="创建软链接symlink"><a href="#创建软链接symlink" class="headerlink" title="创建软链接symlink"></a>创建软链接symlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">symlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *linkpath)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>target：用于指定被链接的源文件路径，target 参数指定的也可以是一个软链接文件。<br>linkpath：用于指定硬链接文件路径，如果 newpath 指定的文件路径已存在，则会产生错误。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。<br>创建软链接时，并不要求 target 参数指定的文件路径已经存在，如果文件不存在，那么创建的软链接将成为“悬空链接”。</p><h4 id="读取软链接文件"><a href="#读取软链接文件" class="headerlink" title="读取软链接文件"></a>读取软链接文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要读取的软链接文件路径。只能是软链接文件路径，不能是其它类型文件，否则调用函<br>数将报错。<br>buf：用于存放路径信息的缓冲区。<br>bufsiz：读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。<br>返回值：失败将返回-1，并会设置 errno；成功将返回读取到的字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *buf, <span class="type">size_t</span> bufsiz)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要读取的软链接文件路径。只能是软链接文件路径，不能是其它类型文件，否则调用函数将报错。<br>buf：用于存放路径信息的缓冲区。<br>bufsiz：读取大小，一般读取的大小需要大于链接文件数据块中存储的文件路径信息字节大小。<br>返回值：失败将返回-1，并会设置 errno；成功将返回读取到的字节数。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="目录存储形式"><a href="#目录存储形式" class="headerlink" title="目录存储形式"></a>目录存储形式</h4><p>目录这种特殊文件在文件系统中的存储形式，其实目录在文件系统中的存储方式与常规文件类似，常规文件包括了 inode 节点以及文件内容数据存储块（block），但对于目录来说，其存储形式则是由 inode 节点和目录块所构成，目录块当中记录了有哪些文件组织在这个目录下，记录它们的文件名以及对应的 inode 编号。</p><p><img src="https://gitee.com/hanfengdyh/image/raw/master/bloglmg/guazai.jpg"></p><p>目录块当中有多个目录项（或叫目录条目），每一个目录项（或目录条目）都会对应到该目录下的某一个文件，目录项当中记录了该文件的文件名以及它的 inode 节点编号，所以通过目录的目录块便可以遍历找到该目录下的所有文件以及所对应的 inode 节点。<br>所以对此总结如下：<br>⚫ 普通文件由 inode 节点和数据块构成<br>⚫ 目录由 inode 节点和目录块构成</p><h4 id="创建删除目录"><a href="#创建删除目录" class="headerlink" title="创建删除目录"></a>创建删除目录</h4><p><strong>mkdir函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要创建的目录路径。<br>mode：新建目录的权限设置，设置方式与 open 函数的 mode 参数一样，最终权限为（mode &amp; ~umask）。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。<br>pathname 参数指定的新建目录的路径，该路径名可以是相对路径，也可以是绝对路径，若指定的路径名已经存在，则调用 mkdir()将会失败。<br>mode 参数指定了新目录的权限，目录拥有与普通文件相同的权限位，但是其表示的含义与普通文件却有不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> ret = mkdir(<span class="string">&quot;./new_dir&quot;</span>, S_IRWXU |</span><br><span class="line"> S_IRGRP | S_IXGRP |</span><br><span class="line">S_IROTH | S_IXOTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;mkdir error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除目录rmdir</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的目录对应的路径名，并且该目录必须是一个空目录，也就是该目录下只有.和..这两个目录项；pathname 指定的路径名不能是软链接文件，即使该链接文件指向了一个空目录。<br>返回值：成功返回 0；失败将返回-1，并会设置 errno。</p><p><strong>打开、读取以及关闭目录</strong></p><p><strong>opendir()函数</strong>用于打开一个目录，并返回指向该目录的句柄，供后续操作使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR *<span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>name：指定需要打开的目录路径名，可以是绝对路径，也可以是相对路径。<br>返回值：成功将返回指向该目录的句柄，一个 DIR 指针（其实质是一个结构体指针），其作用类似于<br>open函数返回的文件描述符fd，后续对该目录的操作需要使用该DIR指针变量；若调用失败，则返回NULL。</p><p>**readdir()**用于读取目录，获取目录下所有文件的名称以及对应 inode 号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> dirent *<span class="title function_">readdir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄 DIR 指针。<br>返回值：返回一个指向 struct dirent 结构体的指针，该结构体表示 dirp 指向的目录流中的下一个目录条目。在到达目录流的末尾或发生错误时，它返回 NULL。</p><p><u>“流”这个概念是动态的，而不是静态的。编程当中提到这个概念，一般都是与 I&#x2F;O 相关，所以也经常叫做 I&#x2F;O 流；但对于目录这种特殊文件来说，这里将目录块中存储的数据称为目录流，存储了一个一个的目录项（目录条目）。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">ino_t</span> d_ino; <span class="comment">/* inode 编号 */</span></span><br><span class="line"> <span class="type">off_t</span> d_off; <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file; not supported by all filesystem types */</span></span><br><span class="line"> <span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* 文件名 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每调用一次 readdir()，就会从 drip 所指向的目录流中读取下一条目录项（目录条目），并返回 struct dirent结构体指针，指向经静态分配而得的 struct dirent 类型结构，每次调用 readdir()都会覆盖该结构。一旦遇到目录结尾或是出错，readdir()将返回 NULL，针对后一种情况，还会设置 errno 以示具体错误。</p><p>那如何区别究竟是到了目录末尾还是出错了呢，可通过如下代码进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error = <span class="number">0</span>;</span><br><span class="line">direntp = readdir(dirp);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == direntp) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> != error) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 出现了错误 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 已经到了目录末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rewinddir()</strong><u>可将目录流重置为目录起点。</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rewinddir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄。<br>返回值：无返回值。</p><p>关闭目录close()函数用于关闭处于打开状态的目录，同时释放他所用的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">closedir</span><span class="params">(DIR *dirp)</span>;</span><br></pre></td></tr></table></figure><p>dirp：目录句柄。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p><strong>进程的当前工作目录</strong></p><p>Linux 下的每一个进程都有自己的当前工作目录（current working directory），当前工作目录是该进程解析、搜索相对路径名的起点。</p><p>一般情况下，运行一个进程时、其父进程的当前工作目录将被该进程所继承，成为该进程的当前工作目录。可通过 getcwd 函数来获取进程的当前工作目录，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>buf：getcwd()将内含当前工作目录绝对路径的字符串存放在 buf 缓冲区中。<br>size：缓冲区的大小，分配的缓冲区大小必须要大于字符串长度，否则调用将会失败。<br>返回值：如果调用成功将返回指向 buf 的指针，失败将返回 NULL，并设置 errno。</p><p><strong>改变当前工作目录</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fchdir</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>path：将进程的当前工作目录更改为 path 参数指定的目录，可以是绝对路径、也可以是相对路径，指定的目录必须要存在，否则会报错。<br>fd：将进程的当前工作目录更改为 fd 文件描述符所指定的目录（譬如使用 open 函数打开一个目录）。<br>返回值：成功均返回 0；失败均返回-1，并设置 errno。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><strong>使用unlink函数删除一个文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的文件路径，可使用相对路径、也可使用绝对路径，如果 pathname 参数指定的文件不存在，则调用 unlink()失败。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>unlink()系统调用实质上是移除 pathname 参数指定的文件路径对应的目录项（从其父级目录中移除该目录项），并将文件的 inode 链接计数将 1，如果该文件还有其它硬链接，则任可通过其它链接访问该文件的数据；只有当链接计数变为 0 时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容—只要有进程打开了该文件，其内容也不能被删除。关闭一个文件时，内核会检查打开该文件的进程个数，如果这个计数达到 0，内核再去检查其链接计数，如果链接计数也是 0，那么就删除该文件对应的内容（也就是文件对应的 inode 以及数据块被回收，如果一个文件存在多个硬链接，删除其中任何一个硬链接，其inode 和数据块并没有被回收，还可通过其它硬链接访问文件的数据）。</p><p><strong>使用 remove 函数删除文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><p>pathname：需要删除的文件或目录路径，可以是相对路径、也可是决定路径。<br>返回值：成功返回 0；失败将返回-1，并设置 errno。<br>pathname 参数指定的是一个非目录文件，那么 remove()去调用 unlink()，如果 pathname 参数指定的是一个目录，那么 remove()去调用 rmdir()。</p><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>本小节给大家介绍 rename()系统调用，借助于 rename()既可以对文件进行重命名，又可以将文件移至同一文件系统中的另一个目录下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><p>返回值：成功返回 0；失败将返回-1，并设置 errno。</p><p>根据 oldpath、newpath 的不同，有以下不同的情况需要进行说明：<br>⚫ 若 newpath 参数指定的文件或目录已经存在，则将其覆盖；<br>⚫ 若 newpath 和 oldpath 指向同一个文件，则不发生变化（且调用成功）。<br>⚫ rename()系统调用对其两个参数中的软链接均不进行解引用。如果 oldpath 是一个软链接，那么将重命名该软链接；如果 newpath 是一个软链接，则会将其移除、被覆盖。<br>⚫ 如果 oldpath 指代文件，而非目录，那么就不能将 newpath 指定为一个目录的路径名。要想重命名<br>一个文件到某一个目录下，newpath 必须包含新的文件名。<br>⚫ 如果 oldpath 指代为一个目录，在这种情况下，newpath 要么不存在，要么必须指定为一个空目录。<br>⚫ oldpath 和 newpath 所指代的文件必须位于同一文件系统。由前面的介绍，可以得出此结论！<br>⚫ 不能对.（当前目录）和..（上一级目录）进行重命名。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux标准IO库</title>
      <link href="/2022/11/12/Linux%E6%A0%87%E5%87%86IO%E5%BA%93/"/>
      <url>/2022/11/12/Linux%E6%A0%87%E5%87%86IO%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓标准 I&#x2F;O 库则是标准 C 库中用于文件 I&#x2F;O 操作（譬如读文件、写文件等）相关的一系列库函数的集合，通常标准 I&#x2F;O 库函数相关的函数定义都在头文件中。</p><p><u>设计库函数是为了提供比底层系统调用更为方便、好用的调用接口，虽然标准 I&#x2F;O 构建于文件 I&#x2F;O 之上，但标准 I&#x2F;O 却有它自己的优势。</u></p><p>标准 I&#x2F;O 和文件 I&#x2F;O 的区别如下：</p><p>⚫ 虽然标准 I&#x2F;O 和文件 I&#x2F;O 都是 C 语言函数，但是标准 I&#x2F;O 是标准 C 库函数，而文件 I&#x2F;O 则是 Linux<br>系统调用；<br>⚫ 标准 I&#x2F;O 是由文件 I&#x2F;O 封装而来，标准 I&#x2F;O 内部实际上是调用文件 I&#x2F;O 来完成实际操作的；<br>⚫ 可移植性：标准 I&#x2F;O 相比于文件 I&#x2F;O 具有更好的可移植性。</p><p>⚫ 性能、效率：标准 I&#x2F;O 库在用户空间维护了自己的 stdio 缓冲区，所以标准 I&#x2F;O 是带有缓存的，而<br>文件 I&#x2F;O 在用户空间是不带有缓存的，所以在<em>性能、效率上，标准 I&#x2F;O 要优于文件 I&#x2F;O</em>。</p><h3 id="FILE-指针"><a href="#FILE-指针" class="headerlink" title="FILE 指针"></a>FILE 指针</h3><p>而对于标准 I&#x2F;O 库函数来说，它们的操作是围绕 FILE 指针进行的，当使用标准 I&#x2F;O 库函数打开或创建一个<br>文件时，会返回一个指向 FILE 类型对象的指针（FILE *），使用该 FILE 指针与被打开或创建的文件相关<br>联，然后该 FILE 指针就用于后续的标准 I&#x2F;O 操作（使用标准 I&#x2F;O 库函数进行 I&#x2F;O 操作），所以由此可知，<br>FILE 指针的作用相当于文件描述符，只不过 FILE 指针用于标准 I&#x2F;O 库函数中、而文件描述符则用于文件<br>I&#x2F;O 系统调用中。</p><p>FILE 是一个结构体数据类型，它包含了标准 I&#x2F;O 库函数为管理文件所需要的所有信息，包括用于实际<br>I&#x2F;O 的文件描述符、指向文件缓冲区的指针、缓冲区的长度、当前缓冲区中的字节数以及出错标志等。FILE<br>数据结构定义在标准 I&#x2F;O 库函数头文件 stdio.h 中。</p><h3 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h3><p>所谓标准输入设备指的就是计算机系统的标准的输入设备，通常指的是计算机所连接的键盘；而标准输出设备指的是计算机系统中用于输出标准信息的设备，通常指的是计算机所连接的显示器；标准错误设备则指的是计算机系统中用于显示错误信息的设备，通常也指的是显示器设备。</p><p>用户通过标准输入设备与系统进行交互，进程将从标准输入（stdin）文件中得到输入数据，将正常输出<br>数据（譬如程序中 printf 打印输出的字符串）输出到标准输出（stdout）文件，而将错误信息（譬如函数调用报错打印的信息）输出到标准错误（stderr）文件。</p><h3 id="打开文件fopen"><a href="#打开文件fopen" class="headerlink" title="打开文件fopen()"></a>打开文件fopen()</h3><p>在标准 I&#x2F;O 中，我们将使用库函数fopen()打开或创建文件.函数原型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>path：参数 path 指向文件路径，可以是绝对路径、也可以是相对路径。<br>mode：参数 mode 指定了对该文件的读写权限，是一个字符串。<br>返回值：调用成功返回一个指向 FILE 类型对象的指针（FILE *），该指针与打开或创建的文件相关联，<br>后续的标准 I&#x2F;O 操作将围绕 FILE 指针进行。如果失败则返回 NULL，并设置 errno 以指示错误原因。</p><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件</td></tr><tr><td>r+</td><td>以可读、可写方式打开文件</td></tr><tr><td>w</td><td>以只写方式打开文件，如果参数path指定的文件存在，将文件长度截断为0，不存在则创建该文件</td></tr><tr><td>w+</td><td>以可读、可写方式打开文件，如果参数 path 指定的文件存在，将文件长度截断为 0；如果指定文件不存在则创建该文件。</td></tr><tr><td>a</td><td>以只写方式打开文件，打开以进行追加内容（在文件末尾写入），如果文件不存在则创建该文件。</td></tr><tr><td>a+</td><td>以可读、可写方式打开文件，以追加方式写入（在文件末尾写入），如果文件不存在则创建该文件。</td></tr></tbody></table><p>虽然调用 fopen()函数新建文件时无法手动指定文件的权限，但却有一个默认值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH (0666)</span><br></pre></td></tr></table></figure><h3 id="fclose-关闭文件"><a href="#fclose-关闭文件" class="headerlink" title="fclose()关闭文件"></a>fclose()关闭文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 为 FILE 类型指针，调用成功返回 0；失败将返回 EOF（也就是-1），并且会设置 errno 来<br>指示错误原因。</p><h3 id="读文件和写文件"><a href="#读文件和写文件" class="headerlink" title="读文件和写文件"></a>读文件和写文件</h3><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>库函数 fread()用于读取文件数据，其参数和返回值含义如下：</p><p>ptr：fread()将读取到的数据存放在参数 ptr 指向的缓冲区中；<br>size：fread()从文件读取 nmemb 个数据项，每一个数据项的大小为 size 个字节，所以总共读取的数据大<br>小为 nmemb * size 个字节。<br>nmemb：参数 nmemb 指定了读取数据项的个数。<br>stream：FILE 指针。<br>返回值：调用成功时返回读取到的数据项的数目（数据项数目并不等于实际读取的字节数，除非参数<br>size 等于 1）；如果发生错误或到达文件末尾，则 fread()返回的值将小于参数 nmemb，那么到底发生了错误还是到达了文件末尾，fread()不能区分文件结尾和错误，究竟是哪一种情况，此时可以使用 ferror()或 feof()函数来判断。</p><p>库函数 fwrite()用于将数据写入到文件中，其参数和返回值含义如下：<br>ptr：将参数 ptr 指向的缓冲区中的数据写入到文件中。<br>size：参数 size 指定了每个数据项的字节大小，与 fread()函数的 size 参数意义相同。<br>nmemb：参数 nmemb 指定了写入的数据项个数，与 fread()函数的 nmemb 参数意义相同。<br>stream：FILE 指针。<br>返回值：调用成功时返回写入的数据项的数目（数据项数目并不等于实际写入的字节数，除非参数 size<br>等于 1）；如果发生错误，则 fwrite()返回的值将小于参数 nmemb（或者等于 0）。<br>由此可知，库函数 fread()、fwrite()中指定读取或写入数据大小的方式与系统调用 read()、write()不同，<br>前者通过 nmemb（数据项个数）*size（每个数据项的大小）的方式来指定数据大小，而后者则直接通过一个 size 参数指定数据大小。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[] = <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 写入数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">sizeof</span>(buf) &gt; fwrite(buf, <span class="number">1</span>, <span class="keyword">sizeof</span>(buf), fp)) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fwrite error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;数据写入成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="literal">NULL</span> == (fp = fopen(<span class="string">&quot;./test_file&quot;</span>, <span class="string">&quot;r&quot;</span>))) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;文件打开成功!\n&quot;</span>);</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">12</span> &gt; (size = fread(buf, <span class="number">1</span>, <span class="number">12</span>, fp))) &#123;</span><br><span class="line"> <span class="keyword">if</span> (ferror(fp)) &#123; <span class="comment">//使用 ferror 判断是否是发生错误</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fread error\n&quot;</span>);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 如果未发生错误则意味着已经到达了文件末尾 */</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;成功读取%d 个字节数据: %s\n&quot;</span>, size, buf);</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fseek定位"><a href="#fseek定位" class="headerlink" title="fseek定位"></a>fseek定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针。<br>offset：与 lseek()函数的 offset 参数意义相同。<br>whence：与 lseek()函数的 whence 参数意义相同。<br>返回值：成功返回 0；发生错误将返回-1，并且会设置 errno 以指示错误原因；与 lseek()函数的返回值<br>意义不同，这里要注意！<br>调用库函数 fread()、fwrite()读写文件时，文件的读写位置偏移量会自动递增，使用 fseek()可手动设置<br>文件当前的读写位置偏移量。</p><p><u>将一个文件的打开写入文件数据，并进行读取要使用fseek来将读写位置移动到头部才能读取，否则fead</u></p><p><u>读取后面的空白信息，没有内容。</u></p><h3 id="ftell-函数"><a href="#ftell-函数" class="headerlink" title="ftell()函数"></a>ftell()函数</h3><p>用于获取文件当前的读写位置偏移量，函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数 stream 指向对应的文件，函数调用成功将返回当前读写位置偏移量；调用失败将返回-1，并会设置<br>errno 以指示错误原因。</p><h3 id="feof函数"><a href="#feof函数" class="headerlink" title="feof函数"></a>feof函数</h3><p>库函数 feof()用于测试参数 stream 所指文件的 end-of-file 标志，如果 end-of-file 标志被设置了，则调用<br>feof()函数将返回一个非零值，如果 end-of-file 标志没有被设置，则返回 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="ferror-函数"><a href="#ferror-函数" class="headerlink" title="ferror()函数"></a>ferror()函数</h3><p>库函数 ferror()用于测试参数 stream 所指文件的错误标志，如果错误标志被设置了，则调用 ferror()函数<br>将返回一个非零值，如果错误标志没有被设置，则返回 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ferror</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="clearerr函数"><a href="#clearerr函数" class="headerlink" title="clearerr函数"></a>clearerr函数</h3><p>库函数 clearerr()用于清除 end-of-file 标志和错误标志，当调用 feof()或 ferror()校验这些标志后，通常需<br>要清除这些标志，避免下次校验时使用到的是上一次设置的值，此时可以手动调用 clearerr()函数清除标志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearerr</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="IO缓冲"><a href="#IO缓冲" class="headerlink" title="IO缓冲"></a>IO缓冲</h3><p>调用 write()后仅仅只是将这 5 个字节数据拷贝到了内核空间的缓冲区中，拷贝完成之后函数就返回了，在后面的某个时刻，内核会将其缓冲区中的数据写入（刷新）到磁盘设备中，所以由此可知，系统调用 write()与磁盘操作并不是同步的，write()函数并不会等待数据真正写入到磁盘之后再返回。如果在此期间，其它进程调用 read()函数读取该文件的这几个字节数据，那么内核将自动从缓冲区中读取这几个字节数据返回给应用程序。</p><p>这个内核缓冲区就称为文件 I&#x2F;O 的内核缓冲。这样的设计，目的是为了提高文件 I&#x2F;O 的速度和效率，使得系统调用 read()、write()的操作更为快速，不需要等待磁盘操作（将数据写入到磁盘或从磁盘读取出数据），磁盘操作通常是比较缓慢的。同时这一设计也更为高效，减少了内核操作磁盘的次数，譬如线程1 调用 write()向文件写入数据”abcd”，线程 2 也调用 write()向文件写入数据”1234”，这样的话，数据”abcd”和”1234”都被缓存在了内核的缓冲区中，在稍后内核会将它们一起写入到磁盘中，只发起一次磁盘操作请求；加入没有内核缓冲区，那么每一次调用 write()，内核就会执行一次磁盘操作。</p><h4 id="刷新文件-I-x2F-O-的内核缓冲区"><a href="#刷新文件-I-x2F-O-的内核缓冲区" class="headerlink" title="刷新文件 I&#x2F;O 的内核缓冲区"></a>刷新文件 I&#x2F;O 的内核缓冲区</h4><p>当我们在 Ubuntu 系统下拷贝文件到 U 盘时，文件拷贝完成之后，通常在拔掉 U 盘之前，需要执行 sync 命令进行同步操作，这个同步操作其实就是将文件 I&#x2F;O 内核缓冲区中的数据更新到 U 盘硬件设备，所以如果在没有执行 sync 命令时拔掉 U 盘，很可能就会导致拷贝到 U 盘中的文件遭到破坏！</p><h4 id="fsync-函数"><a href="#fsync-函数" class="headerlink" title="fsync()函数"></a>fsync()函数</h4><p>系统调用 fsync()将参数 fd 所指文件的内容数据和元数据写入磁盘，只有在对磁盘设备的写入操作完成之后，fsync()函数才会返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>参数 fd 表示文件描述符，函数调用成功将返回 0，失败返回-1 并设置 errno 以指示错误原因。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_FILE <span class="string">&quot;./rfile&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_FILE <span class="string">&quot;./wfile&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> rfd, wfd;</span><br><span class="line"> <span class="type">size_t</span> size;</span><br><span class="line"> <span class="comment">/* 打开源文件 */</span></span><br><span class="line"> rfd = open(READ_FILE, O_RDONLY);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; rfd) </span><br><span class="line"> &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 打开目标文件 */</span></span><br><span class="line"> wfd = open(WRITE_FILE, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; wfd) </span><br><span class="line">    &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 拷贝数据 */</span></span><br><span class="line"> <span class="keyword">while</span>(<span class="number">0</span> &lt; (size = read(rfd, buf, BUF_SIZE)))</span><br><span class="line"> write(wfd, buf, size);</span><br><span class="line"> <span class="comment">/* 对目标文件执行 fsync 同步 */</span></span><br><span class="line"> fsync(wfd);</span><br><span class="line"> <span class="comment">/* 关闭文件退出程序 */</span></span><br><span class="line"> close(rfd);</span><br><span class="line">  close(wfd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fdatasync-函数"><a href="#fdatasync-函数" class="headerlink" title="fdatasync()函数"></a>fdatasync()函数</h4><p>系统调用 fdatasync()与 fsync()类似，不同之处在于 fdatasync()仅将参数 fd 所指文件的内容数据写入磁<br>盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h4 id="sync-函数"><a href="#sync-函数" class="headerlink" title="sync()函数"></a>sync()函数</h4><p>系统调用 sync()会将所有文件 I&#x2F;O 内核缓冲区中的文件内容数据和元数据全部更新到磁盘设备中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="O-DSYNC-标志"><a href="#O-DSYNC-标志" class="headerlink" title="O_DSYNC 标志"></a>O_DSYNC 标志</h4><p>在调用 open()函数时，指定 O_DSYNC 标志，其效果类似于在每个 write()调用之后调用 fdatasync()函数<br>进行数据同步。</p><h4 id="O-SYNC-标志"><a href="#O-SYNC-标志" class="headerlink" title="O_SYNC 标志"></a>O_SYNC 标志</h4><p>在调用 open()函数时，指定 O_SYNC 标志，使得每个 write()调用都会自动将文件内容数据和元数据刷<br>新到磁盘设备中，其效果类似于在每个 write()调用之后调用 fsync()函数进行数据同步</p><h4 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h4><p>Linux 允许应用程序在执行文件 I&#x2F;O 操作时绕过内核缓冲区，从用户空间直接将数据传递到文件或磁盘设备，把这种操作也称为直接 I&#x2F;O（direct I&#x2F;O）或裸 I&#x2F;O（raw I&#x2F;O）。</p><p>因为直接 I&#x2F;O 涉及到对磁盘设备的直接访问，所以在执行直接 I&#x2F;O 时，必须要遵守以下三个对齐限制要求：<br>⚫ 应用程序中用于存放数据的缓冲区，其内存起始地址必须以块大小的整数倍进行对齐；<br>⚫ 写文件时，文件的位置偏移量必须是块大小的整数倍；<br>⚫ 写入到文件的数据大小必须是块大小的整数倍。</p><h4 id="stdio缓冲"><a href="#stdio缓冲" class="headerlink" title="stdio缓冲"></a>stdio缓冲</h4><p>标准 I&#x2F;O（fopen、fread、fwrite、fclose、fseek 等）是 C 语言标准库函数，而文件 I&#x2F;O（open、read、write、close、lseek 等）是系统调用，虽然标准 I&#x2F;O 是在文件 I&#x2F;O 基础上进行封装而实现（譬如 fopen 内部实际上调用了 open、fread 内部调用了 read 等），但在效率、性能上标准 I&#x2F;O 要优于文件 I&#x2F;O，其原因在于标准 I&#x2F;O 实现维护了自己的缓冲区，把这个缓冲区称为 stdio 缓冲区。为了减少调用系统调用的次数，标准 I&#x2F;O 函数会将用户写入或读取文件的数据缓存在 stdio 缓冲区，然后再一次性将 stdio 缓冲区中缓存的数据通过调用系统调用I&#x2F;O（文件 I&#x2F;O）写入到文件 I&#x2F;O 内核缓冲区或者拷贝到应用程序的 buf 中。</p><h5 id="stdio缓冲区的函数"><a href="#stdio缓冲区的函数" class="headerlink" title="stdio缓冲区的函数"></a>stdio缓冲区的函数</h5><h5 id="setvbuf-函数"><a href="#setvbuf-函数" class="headerlink" title="setvbuf()函数"></a>setvbuf()函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>stream：FILE 指针，用于指定对应的文件，每一个文件都可以设置它对应的 stdio 缓冲区。<br>buf：如果参数 buf 不为 NULL，那么 buf 指向 size 大小的内存区域将作为该文件的 stdio 缓冲区，因为stdio 库会使用 buf 指向的缓冲区，所以应该以动态（分配在堆内存）或静态的方式在堆中为该缓冲区分配一块空间，而不是分配在栈上的函数内的自动变量（局部变量）。如果 buf 等于 NULL，那么 stdio 库会自动分配一块空间作为该文件的 stdio 缓冲区（除非参数 mode 配置为非缓冲模式）。<br>mode：参数 mode 用于指定缓冲区的缓冲类型，可取值如下：<br>⚫ _IONBF：不对 I&#x2F;O 进行缓冲（无缓冲）。意味着每个标准 I&#x2F;O 函数将立即调用 write()或者 read()，并且忽略 buf 和 size 参数，可以分别指定两个参数为 NULL 和 0。标准错误 stderr 默认属于这一种类型，从而保证错误信息能够立即输出。<br>⚫ _IOLBF：采用行缓冲 I&#x2F;O。在这种情况下，当在输入或输出中遇到换行符”\n”时，标准 I&#x2F;O 才会执行文件 I&#x2F;O 操作。对于输出流，在输出一个换行符前将数据缓存（除非缓冲区已经被填满），当输出换行符时，再将这一行数据通过文件 I&#x2F;O write()函数刷入到内核缓冲区中；对于输入流，每次读取一行数据。对于终端设备默认采用的就是行缓冲模式，譬如标准输入和标准输出。<br>⚫ _IOFBF：采用全缓冲 I&#x2F;O。在这种情况下，在填满 stdio 缓冲区后才进行文件 I&#x2F;O 操作（read、write）。对于输出流，当 fwrite 写入文件的数据填满缓冲区时，才调用 write()将 stdio 缓冲区中的数据刷入内核缓冲区；对于输入流，每次读取 stdio 缓冲区大小个字节数据。默认普通磁盘上的常规文件默认常用这种缓冲模式。<br>size：指定缓冲区的大小。<br>返回值：成功返回 0，失败将返回一个非 0 值，并且会设置 errno 来指示错误原因。</p><h5 id="setbuffer-函数"><a href="#setbuffer-函数" class="headerlink" title="setbuffer()函数"></a>setbuffer()函数</h5><p>setbuffer函数类似setbuf（）但是允许调用者指定buf缓冲区的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><h5 id="刷新-stdio-缓冲区"><a href="#刷新-stdio-缓冲区" class="headerlink" title="刷新 stdio 缓冲区"></a>刷新 stdio 缓冲区</h5><p>无论我们采取何种缓冲模式，在任何时候都可以使用库函数 fflush()来强制刷新（将输出到 stdio 缓冲区中的数据写入到内核缓冲区，通过 write()函数）stdio 缓冲区，该函数会刷新指定文件的 stdio 输出缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"> fflush(<span class="built_in">stdout</span>); <span class="comment">//刷新标准输出 stdio 缓冲区</span></span><br><span class="line"> <span class="keyword">for</span> ( ; ; )</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些其它的情况下，也会自动刷新 stdio 缓冲区，譬如当文件关闭时、程序退出时。</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/set.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux深入文件IO</title>
      <link href="/2022/11/10/Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/"/>
      <url>/2022/11/10/Linux%E6%B7%B1%E5%85%A5%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux管理文件"><a href="#Linux管理文件" class="headerlink" title="Linux管理文件"></a>Linux管理文件</h3><h4 id="静态文件与inode"><a href="#静态文件与inode" class="headerlink" title="静态文件与inode"></a>静态文件与inode</h4><p>文件存放在磁盘文件系统中，并且以一种固定的形式进行存放，称为静态文件。调用 open 函数的时候，会将文件数据（文件内容）从磁盘等块设备读取到内存中，将文件数据在内存中进行维护，内存中的这份文件数据我们就把它称为动态文件。</p><p>硬盘的最小存储单位叫做“扇区”（Sector），每个扇区储存 512 字节（相当于 0.5KB），操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。这种由多个扇区组成的“块”，是文件存取的最小单位。“块”的大小，最常见的4KB，即连续八个 sector 组成一个 block。</p><p>磁盘在进行分区、格式化的时候会将其分为两个区域，一个是数据区，用于存储文件中的数据；<br>另一个是 inode 区，用于存放 inode table（inode 表），inode table 中存放的是一个一个的 inode（也成为 inode节点），不同的 inode 就可以表示不同的文件，每一个文件都必须对应一个 inode。</p><p><a href="https://postimg.cc/JD4mjgVd"><img src="https://i.postimg.cc/DZ1Z3kCF/2022-11-10-142428.png" alt="2022-11-10-142428.png"></a></p><p>打开一个文件，系统内部会将这个过程分为三步：</p><ol><li>系统找到这个文件名所对应的 inode 编号；</li><li>通过 inode 编号从 inode table 中找到对应的 inode 结构体；</li><li>根据 inode 结构体中记录的信息，确定文件数据所在的 block，并读出数据。</li></ol><p>调用 open 函数去打开文件的时候，内核会申请一段内存（一段缓冲区），并且将静态文件的数据内容从磁盘这些存储设备中读取到内存中进行管理、缓存（也把内存中的这份文件数据叫做动态文件、内核缓冲区）。打开文件后，以后对这个文件的读写操作，都是针对内存中这一份动态文件进行相关的操作，而并不是针对磁盘中存放的静态文件。</p><p>因为磁盘、硬盘、U 盘等存储设备基本都是 Flash 块设备，因为块设备硬件本身有读写限制等特征，块设备是以一块一块为单位进行读写的（一个块包含多个扇区，而一个扇区包含多个字节），一个字节的改动也需要将该字节所在的 block 全部读取出来进行修改，修改完成之后再写入块设备中，所以导致对块设备的读写操作非常不灵活；而内存可以按字节为单位来操作，而且可以随机操作任意地址数据，非常地很灵活。</p><p>内核会为每个进程设置一个专门的数据结构用于管理该进程，譬如用于记录进程的状态信息、运行特征等，我们把这个称为进程控制块（Process control block，缩写PCB）。<br>PCB 数据结构体中有一个指针指向了文件描述符表（File descriptors），文件描述符表中的每一个元素索引到对应的文件表（File table），文件表也是一个数据结构体。</p><h4 id="返回错误处理与errno"><a href="#返回错误处理与errno" class="headerlink" title="返回错误处理与errno"></a>返回错误处理与errno</h4><p>在 Linux 系统下对常见的错误做了一个编号，每一个编号都代表着每一种不同的错误类型，当函数执行发生错误的时候，操作系统会将这个错误所对应的编号赋值给 errno 变量，每一个进程（程序）都维护了自己的 errno 变量，它是程序中的全局变量，该变量用于存储就近发生的函数执行错误编号，也就意味着下一次的错误码会覆盖上一次的错误码。</p><p>errno 本质上是一个 int 类型的变量，用于存储错误编号，但是需要注意的是，并不是执行所有的系统调用或 C 库函数出错时，操作系统都会设置 errno。</p><h5 id="常用的函数perror函数"><a href="#常用的函数perror函数" class="headerlink" title="常用的函数perror函数"></a>常用的函数perror函数</h5><p>一般用的最多的还是这个函数，调用此函数不需要传入 errno，函数内部会自己去获取 errno 变量的值，调用此函数会直接将错误提示字符串打印出来，而不是返回字符串。</p><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>s：在错误提示字符串信息之前，可加入自己的打印信息，也可不加，不加则传入空字符串即可。<br>返回值：void 无返回值。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/* 打开文件 */</span></span><br><span class="line">fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line">perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exit、-exit、-Exit"><a href="#exit、-exit、-Exit" class="headerlink" title="exit、__exit、_Exit"></a>exit、__exit、_Exit</h4><p>在 Linux 系统下，进程（程序）退出可以分为正常退出和异常退出，注意这里说的异常并不是执行函数出现了错误这种情况，异常往往更多的是一种不可预料的系统异常，可能是执行了某个函数时发生的、也有可能是收到了某种信号等.</p><p>main 函数中使用 return 后返回，return 执行后把控制权交给调用函数，结束该进程。调用_exit()函数会清除其使用的内存空间，并销毁其在内核中的各种数据结构，关闭进程的所有文件描述符，并结束进程、将控制权交给操作系统。exit()是一个标准 C 库函数，而_exit()和_Exit()是系统调用。</p><p>__exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>_Exit()函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>exit()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><h4 id="空洞文件"><a href="#空洞文件" class="headerlink" title="空洞文件"></a>空洞文件</h4><p>使用 write()函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个空洞，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为空洞文件。<br>文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它<br>分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的</p><p><u>空洞文件对多线程共同操作文件是及其有用的</u>，有时候我们创建一个很大的文件，如果单个线程从头开始依次构建该文件需要很长的时间，有一种思路就是将文件分为多段，然后使用多线程来操作，每个线程负责其中一段数据的写入。</p><p>eg：新建一个空洞文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./hole_file&quot;</span>, O_WRONLY | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将文件读写位置移动到偏移文件头 4096 个字节(4K)处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">4096</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 为 0xFF */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0xFF</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 循环写入 4 次，每次写入 1K */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例代码中，使用 open 函数新建了一个文件 hole_file，在 Linux 系统中，新建文件大小是 0，也就<br>是没有任何数据写入，此时使用lseek函数将读写偏移量移动到4K字节处，再使用write函数写入数据0xFF，每次写入 1K，一共写入 4 次，也就是写入了 4K 数据，也就意味着该文件前 4K 是文件空洞部分，而后 4K数据才是真正写入的数据。</p><h4 id="O-APPEND-和-O-TRUNC-标志"><a href="#O-APPEND-和-O-TRUNC-标志" class="headerlink" title="O_APPEND 和 O_TRUNC 标志"></a>O_APPEND 和 O_TRUNC 标志</h4><p>O_TRUNC 这个标志的作用是调用 open 函数打开文件的时候会将文件原本的内容全部丢弃，文件大小变为 0。</p><p><u><strong>O_APPEND</strong></u>标志作用open函数携带了O_APPEND，调用 open 函数打开文件，当每次使用 write()函数对文件进行写操作时，都会自动把文件当前位置偏移量移动到文件末尾，从文件末尾开始写入数据，也就是意味着每次写入数据都是从文件末尾开始。</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 打开文件 */</span></span><br><span class="line"> fd = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 初始化 buffer 中的数据 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x55</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 写入数据: 写入 4 个字节数据 */</span></span><br><span class="line"> ret = write(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将 buffer 缓冲区中的数据全部清 0 */</span></span><br><span class="line"> <span class="built_in">memset</span>(buffer, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line"> <span class="comment">/* 将位置偏移量移动到距离文件末尾 4 个字节处 */</span></span><br><span class="line"> ret = lseek(fd, <span class="number">-4</span>, SEEK_END);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line">    ret = read(fd, buffer, <span class="number">4</span>);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x 0x%x 0x%x\n&quot;</span>, buffer[<span class="number">0</span>], buffer[<span class="number">1</span>],</span><br><span class="line"> buffer[<span class="number">2</span>], buffer[<span class="number">3</span>]);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用O_APPEND多次打开同一个文件测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL | O_APPEND,</span><br><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd1) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 再次打开 test_file 文件 */</span></span><br><span class="line"> fd2 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_APPEND);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == fd2) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h4><p>在 Linux 系统中，open 返回得到的文件描述符 fd 可以进行复制，复制成功之后可以得到一个新的文件描述符，使用新的文件描述符和旧的文件描述符都可以对文件进行 IO 操作，复制得到的文件描述符和旧的文件描述符拥有相同的权限，譬如使用旧的文件描述符对文件有读写权限，那么新的文件描述符同样也具有读写权限。</p><p>dup函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>返回值：成功时将返回一个新的文件描述符，由操作系统分配，分配置原则遵循文件描述符分配原则；<br>如果复制失败将返回-1，并且会设置 errno 值</p><p>eg：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> buffer1[<span class="number">4</span>], buffer2[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup(fd1);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> <span class="comment">/* buffer 数据初始化 */</span></span><br><span class="line"> buffer1[<span class="number">0</span>] = <span class="number">0x11</span>;</span><br><span class="line"> buffer1[<span class="number">1</span>] = <span class="number">0x22</span>;</span><br><span class="line"> buffer1[<span class="number">2</span>] = <span class="number">0x33</span>;</span><br><span class="line"> buffer1[<span class="number">3</span>] = <span class="number">0x44</span>;</span><br><span class="line"> buffer2[<span class="number">0</span>] = <span class="number">0xAA</span>;</span><br><span class="line"> buffer2[<span class="number">1</span>] = <span class="number">0xBB</span>;</span><br><span class="line"> buffer2[<span class="number">2</span>] = <span class="number">0xCC</span>;</span><br><span class="line"> buffer2[<span class="number">3</span>] = <span class="number">0xDD</span>;</span><br><span class="line"> <span class="comment">/* 循环写入数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"> ret = write(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> ret = write(fd2, buffer2, <span class="keyword">sizeof</span>(buffer2));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将读写位置偏移量移动到文件头 */</span></span><br><span class="line"> ret = lseek(fd1, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;lseek error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 读取数据 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"> ret = read(fd1, buffer1, <span class="keyword">sizeof</span>(buffer1));</span><br><span class="line"> <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line"> <span class="keyword">goto</span> err2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x%x%x%x&quot;</span>, buffer1[<span class="number">0</span>], buffer1[<span class="number">1</span>],</span><br><span class="line"> buffer1[<span class="number">2</span>], buffer1[<span class="number">3</span>]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line">err2:</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dup 系统调用分配的文件描述符是由系统分配的，遵循文件描述符分配原则，并不能自己指定一个文件<br>描述符，这是 dup 系统调用的一个缺陷；而 dup2 系统调用修复了这个缺陷，可以手动指定文件描述符，而不需要遵循文件描述符分配原则。dup2函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>oldfd：需要被复制的文件描述符。<br>newfd：指定一个文件描述符（需要指定一个当前进程没有使用到的文件描述符）。<br>返回值：成功时将返回一个新的文件描述符，也就是手动指定的文件描述符 newfd；如果复制失败将返回-1，并且会设置 errno 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd1, fd2;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="comment">/* 创建新文件 test_file 并打开 */</span></span><br><span class="line"> fd1 = open(<span class="string">&quot;./test_file&quot;</span>, O_RDWR | O_CREAT | O_EXCL,</span><br><span class="line"> S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);</span><br><span class="line"> <span class="keyword">if</span> (fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 复制文件描述符 */</span></span><br><span class="line"> fd2 = dup2(fd1, <span class="number">100</span>);</span><br><span class="line"> <span class="keyword">if</span> (fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line"> perror(<span class="string">&quot;dup error&quot;</span>);</span><br><span class="line"> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="keyword">goto</span> err1;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;fd1: %d\nfd2: %d\n&quot;</span>, fd1, fd2);</span><br><span class="line"> ret = <span class="number">0</span>;</span><br><span class="line"> close(fd2);</span><br><span class="line">err1:</span><br><span class="line"> <span class="comment">/* 关闭文件 */</span></span><br><span class="line"> close(fd1);</span><br><span class="line"> <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><p>文件共享指的是同一个文件（譬如磁盘上的同一个文件，对应同一个 inode）被多个独立的读写体同时进行 IO 操作。同时进行 IO 操作指的是一个读写体操作文件尚未调用 close 关闭的情况下，另一个读写体去操作文件。</p><p>文件共享的意义有很多，多用于多进程或多线程编程环境中，譬如我们可以通过文件共享的方式来实现<br>多个线程同时操作同一个大文件，以减少文件读写时间、提升效率。<br><strong><u>文件共享的核心</strong></u>是：如何制造出多个不同的文件描述符来指向同一个文件。其实方法在上面的内容中都已经给大家介绍过了，譬如多次调用 open 函数重复打开同一个文件得到多个不同的文件描述符、使用 dup()或 dup2()函数对文件描述符进行复制以得到多个不同的文件描述符。</p><p><strong>常见三种文件共享实现方式</strong></p><p>(1)同一个进程中多次调用 open 函数打开同一个文件</p><p>(2)不同进程中分别使用 open 函数打开同一个文件</p><p>(3)同一个进程中通过 dup（dup2）函数对文件描述符进行复制</p><h4 id="原子操作和竞争冒险"><a href="#原子操作和竞争冒险" class="headerlink" title="原子操作和竞争冒险"></a>原子操作和竞争冒险</h4><p>[原子操作和竞争冒险]: <a href="https://copyfuture.com/blogs-details/202208241006207606">https://copyfuture.com/blogs-details/202208241006207606</a>“竞争冒险”</p><h4 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h4><p>truncate()或ftruncate()可将普通文件截断为指定字节长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>这两个函数都可以对文件进行截断操作，将文件截断为参数 length 指定的字节长度，什么是截断？如<br>果文件目前的大小大于参数 length 所指定的大小，则多余的数据将被丢失，类似于多余的部分被“砍”掉<br>了；如果文件目前的大小小于参数 length 所指定的大小，则将其进行扩展，对扩展部分进行读取将得到空字节”\0”。</p><p>使用 ftruncate()函数进行文件截断操作之前，必须调用 open()函数打开该文件得到文件描述符，并且必<br>须要具有可写权限，也就是调用 open()打开文件时需要指定 O_WRONLY 或 O_RDWR。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> fd;</span><br><span class="line"> <span class="comment">/* 打开 file1 文件 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; (fd = open(<span class="string">&quot;./file1&quot;</span>, O_RDWR))) &#123;</span><br><span class="line"> perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 ftruncate 将 file1 文件截断为长度 0 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; ftruncate(fd, <span class="number">0</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;ftruncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 使用 truncate 将 file2 文件截断为长度 1024 字节 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">0</span> &gt; truncate(<span class="string">&quot;./file2&quot;</span>, <span class="number">1024</span>)) &#123;</span><br><span class="line"> perror(<span class="string">&quot;truncate error&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 关闭 file1 退出程序 */</span></span><br><span class="line"> close(fd);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——文件IO操作</title>
      <link href="/2022/11/08/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/08/Linux%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="文件IO基础"><a href="#文件IO基础" class="headerlink" title="文件IO基础"></a>文件IO基础</h3><p>文件IO是指对文件的输入输出操作。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>调用函数会有返回值，该返回值为一个文件描述符，对于Linux内核而言，所有打开文件都会通过文件描述符进行索引。</p><p>当调用open函数打开或者创建一个新文件，内核会向进程返回一个文件描述符，用于指带被打开的文件，所有执行 IO 操作的系统调用都是通过文件描述符来索引到对应的文件。一个进程可以打开多个文件，但是在 Linux 系统中，一个进程可以打开的文件数是有限制，并不是可以无限制打开很多的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ulimit</span> -n<span class="comment">##查看进程打开文件的最大数量</span></span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure><p>每一个被打开的文件在同一个进程中都有一个唯一的文件描述符，不会重复，如果文件被关闭后，它对应的文件描述符将会被释放，那么这个文件描述符将可以再次分配给其它打开的文件、与对应的文件绑定起来。</p><p>每次给打开的文件分配文件描述符都是从最小的没有被使用的文件描述符（0~1023）开始，当之前打开的文件被关闭之后，那么它对应的文件描述符会被释放，释放之后也就成为了一个没有被使用的文件描述符了。</p><p>但是 0、1、2 这三个文件描述符已经默认被系统占用了，分别分配给了系统标准输入（0）、标准输出（1）以及标准错误（2）。</p><h4 id="open打开文件"><a href="#open打开文件" class="headerlink" title="open打开文件"></a>open打开文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>open 函数用于打开文件，当然除了打开已经存在的文件之外，还可以创建一个新的文件。</p><p>在应用程序中调用 open 函数即可传入 2 个参数（pathname、flags）、也可传入 3 个参数（pathname、flags、mode），但是第三个参数 mode 需要在第二个参数 flags 满足条件时才会有效，稍后将对此进行说明；从图 2.3.1 可知，在应用程序中使用 open 函数时，需要包含 3 个头文件“#include<br>”、“#include ”、“#include ”。</p><p>函数参数和返回值定义</p><p>pathname：字符串类型，用于标识需要打开或创建的文件，可以包含路径（绝对路径或者相对路径）信息。</p><p>flags：调用open函数时需要提供的标志，包括文件访问模式标志以及其它文件相关标志，这些标志使用宏定义进行描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./app.c&quot;</span>, O_RDWR)<span class="comment">//打开一个已经存在的文件，使用可读可写的方式打开</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line"><span class="keyword">return</span> fd;</span><br></pre></td></tr></table></figure><h4 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数返回值含义如下：</p><p>fd：文件描述符。将进行写操作的文件所对应的文件描述符传递给 write 函数。<br>buf：指定写入数据对应的缓冲区。<br>count：指定写入的字节数。<br>返回值：如果成功将返回写入的字节数（0 表示未写入任何字节），如果此数字小于 count 参数，这不是错误，譬如磁盘空间已满，可能会发生这种情况；如果写入出错，则返回-1。</p><h4 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下：<br>fd：文件描述符。与 write 函数的 fd 参数意义相同。</p><p>buf：指定用于存储读取数据的缓冲区。</p><p>count：指定需要读取的字节数。</p><p>返回值：如果读取成功将返回读取到的字节数，实际读取到的字节数可能会小于 count 参数指定的字节<br>数，也有可能会为 0，譬如进行读操作时，当前文件位置偏移量已经到了文件末尾。实际读取到的字节数少<br>于要求读取的字节数，譬如在到达文件末尾之前有 30 个字节数据，而要求读取 100 个字节，则 read 读取成<br>功只能返回 30；而下一次再调用 read 读，它将返回 0（文件末尾）。</p><h4 id="close关闭文件"><a href="#close关闭文件" class="headerlink" title="close关闭文件"></a>close关闭文件</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p>fd：文件描述符，需要关闭的文件所对应的文件描述符。<br>返回值：如果成功返回 0，如果失败则返回-1。</p><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>对于每个打开的文件，系统都会记录它的读写位置偏移量，我们也把这个读写位置偏移量称为读写偏移<br>量，记录了文件当前的读写位置，当调用 read()或 write()函数对文件进行读写操作时，就会从当前读写位置<br>偏移量开始进行数据读写。</p><p>读写偏移量用于指示 read()或 write()函数操作时文件的起始位置，会以相对于文件头部的位置偏移量来<br>表示，文件第一个字节数据的位置偏移量为 0。</p><p>函数参数和返回值含义如下：<br>fd：文件描述符。<br>offset：偏移量，以字节为单位。<br>whence：用于定义参数 offset 偏移量对应的参考值，该参数为下列其中一种（宏定义）：</p><p>SEEK_SET：读写偏移量将指向 offset 字节位置处（从文件头部开始算）</p><p>SEEK_CUR：读写偏移量将指向当前位置偏移量 + offset 字节位置处，offset 可以为正、也可以为负，如果是正数表示往后偏移，如果是负数则表示往前偏移；</p><p>SEEK_END：读写偏移量将指向文件末尾 + offset 字节位置处，同样 offset 可以为正、也可以为负，如果是正数表示往后偏移、如果是负数则表示往前偏移。</p><p>eg：<br>(1)将读写位置移动到文件开头处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(2)将读写位置移动到文件末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(3)将读写位置移动到偏移文件开头 100 个字节处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">100</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>(4)获取当前读写位置偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> off = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br><span class="line"><span class="keyword">if</span> (off == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>函数执行成功将返回文件当前读写位置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux——Shell脚本学习</title>
      <link href="/2022/10/23/Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/10/23/Linux%E2%80%94%E2%80%94Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="shell介绍"><a href="#shell介绍" class="headerlink" title="shell介绍"></a>shell介绍</h3><p>Shell通常指的是命令行界面的解析器,也用于泛指所有为用户提供操作界面的程序，也就是程序和用户<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%A4%E4%BA%92&action=edit&redlink=1">交互</a>的层面。</p><p>Shell 执行shell程序，这些程序叫脚本。</p><p>创建脚本使用文本编辑器来创建包含指令的文件，这里使用vim</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim bash.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash<span class="comment">##创建脚本文件时候必须在文件第一行指明要用到的shell</span></span></span><br><span class="line">for file in *#以#开头的行不会被shell处理</span><br><span class="line">do </span><br><span class="line">  if grep -q POSIX $file</span><br><span class="line">  then</span><br><span class="line">    echo $file</span><br><span class="line">  fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>把脚本设置为可执行，</p><p>1、</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/bash bash.sh</span></span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x bash.sh<span class="comment">##改变文件权限，使这个文件可以被所有用户执行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bash.sh</span></span><br></pre></td></tr></table></figure><h3 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>所有变量都被看作字符串并以字符串来存储.</p><p> 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：（变量名称使用小写英文命名，因为系统中的全局变量是大写命名的，为防止重复定义就用小写）</p><p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线 _。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p><p>在shell中，可以通过在变量名前加上$符号来访问它的内容， 一种检查变量内容的简单方式就是变量前加上$再用echo命令将它的内容输出到终端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> salutation=Hello</span><br><span class="line"> echo $salutation</span><br><span class="line"> echo salutation</span><br><span class="line">Hello</span><br><span class="line">salutation</span><br></pre></td></tr></table></figure><p>read可以给变量复制相当于C语言的input</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> read salutation</span><br><span class="line"> echo $ salutation</span><br><span class="line">sa</span><br><span class="line">sa</span><br></pre></td></tr></table></figure><p>要想输出空格需要用双引号给引用出来，要想显示双引号可，以用单引号来显示出来，在显示信息中想要有美元符号，必须在前面加上\</p><p>变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符。</p><p>可以通过&#96;反引号来将命令输出赋值给变量或者$()</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = `<span class="built_in">date</span>`</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">testing = $(<span class="built_in">date</span>)</span></span><br></pre></td></tr></table></figure><p>使用 unset 命令可以删除变量。</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h4 id="Shell数组"><a href="#Shell数组" class="headerlink" title="Shell数组"></a>Shell数组</h4><p>bash支持一维数组，并且没有限制大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)#例如这样array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;数组名[下标]&#125;<span class="comment">#例如echo $&#123;array_name[@]&#125;</span></span></span><br></pre></td></tr></table></figure><h5 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><p>bash shell脚本不支持浮点型运算，只支持整数运算，如果想要计算可用bash的计算器bc</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else"><a href="#if-else" class="headerlink" title="if -else"></a>if -else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>如果使用 ((…)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if (( $a == $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif (( $a &gt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif (( $a &lt; $b ))</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p><p>顺序输出当前列表中的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h4><p>until 循环执行一系列命令直至条件为 true 时停止。condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="case…-esac"><a href="#case…-esac" class="headerlink" title="case… esac"></a>case… esac</h4><p>case … esac 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分支选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p><u><strong>和C语言一样break用来跳出所有循环，continue是用来跳出当前循环。</strong></u></p><h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于等于则为真</td></tr><tr><td>-ge</td><td>小于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><p>eg：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e文件名</td><td>如果文件存在则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &#x27;文件已存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;文件不存在!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure><p>传参</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数处理</th><th>说明</th></tr></thead><tbody><tr><td align="left">$#</td><td>传递到脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td align="left">$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr><tr><td align="left">@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td align="left">$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言算法项</title>
      <link href="/2022/10/20/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/"/>
      <url>/2022/10/20/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="正三角-反三角"><a href="#正三角-反三角" class="headerlink" title="正三角(反三角)"></a>正三角(反三角)</h3><p>使用为两个for循环进行嵌套</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;<span class="number">6</span>;a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(b=<span class="number">0</span>;b&lt;a;b++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h3><p>使用为四个for进行循环思想核心为中间数量为行数n的两倍减去1，外层循环控制换行，内层三个控制空格以及他的打印数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> rows,i,j,space,star;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp; rows);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">         star = <span class="number">2</span>*i <span class="number">-1</span> ;     <span class="comment">//星号个数</span></span><br><span class="line">         space = rows - i;   <span class="comment">//空格个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//左边空格</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;star;++j)       <span class="comment">//中间 *</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;space;++j)<span class="comment">//右边空格有没有都可以</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i, space, rows, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter number of rows: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;rows);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=rows; ++i, k=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(space=<span class="number">1</span>; space&lt;=rows-i; ++space)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>);</span><br><span class="line">        ++k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>判断一个数字是否素数</p><p>判断一个数字是否能被比他小的数整除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;x;i++)</span><br><span class="line">            <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//一旦判断不是，跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==x) <span class="built_in">puts</span>(<span class="string">&quot;yes!&quot;</span>);<span class="comment">//如果是的话，for循环一定执行到了i=x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C语言二分查找"><a href="#C语言二分查找" class="headerlink" title="C语言二分查找"></a>C语言二分查找</h3><p>找到最左边元素（low）和最右边元素（high），确定中间元素（mid），比较中间元素（mid）和目标元素（k）的大小，调整low和high，再确定新的mid….我们要不断确定mid直到找到k，自然需要用到循环，我们有明确的目标：找到k。因此选择while循环，找到k后循环不再进行，而当low和high之间还有元素，即low在high的左边或与之重合，k就依然可能存在，所以循环条件为low&lt;&#x3D;high，接下来的问题在于怎样调整low和high的值，mid和k比较无非就三种情况：mid&lt;k，mid&gt;k,mid&#x3D;k。第一种情况，k在mid的右边，我们将low调整为mid+1，high不用调整；第二种情况，k在mid的左边，我们将high调整为mid-1，low不用调整。最后一种情况最简单，我们已经找到了k，直接将mid打印出来就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bin_Search</span><span class="params">(<span class="type">int</span> *num,<span class="type">int</span> cnt,<span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> first = <span class="number">0</span>,last = cnt<span class="number">-1</span>,mid;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(first &lt;= last)</span><br><span class="line">&#123;</span><br><span class="line">counter ++;</span><br><span class="line">mid = (first + last) / <span class="number">2</span>;<span class="comment">//确定中间元素</span></span><br><span class="line"><span class="keyword">if</span>(num[mid] &gt; target)</span><br><span class="line">&#123;</span><br><span class="line">last = mid<span class="number">-1</span>; <span class="comment">//mid已经交换过了,last往前移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num[mid] &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">first = mid+<span class="number">1</span>;<span class="comment">//mid已经交换过了,first往后移一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//判断是否相等</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查找次数:%d\n&quot;</span>,counter);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>,target;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入您要查找的数字:\n&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;target);</span><br><span class="line">flag = Bin_Search(num,<span class="number">10</span>,target);</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;已经找到该数字!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;无该数字!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="查找数组最大值"><a href="#查找数组最大值" class="headerlink" title="查找数组最大值"></a>查找数组最大值</h3><h4 id="循环对比"><a href="#循环对比" class="headerlink" title="循环对比"></a>循环对比</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">findMaxValue(arr) &#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123; <span class="comment">// 当前值大于最大值，赋值为最大值</span></span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串排列顺序"><a href="#字符串排列顺序" class="headerlink" title="字符串排列顺序"></a>字符串排列顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HALT <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> *strings [], <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> input[LIM][SIZE];</span><br><span class="line"><span class="type">char</span> *ptstr[LIM];</span><br><span class="line"><span class="type">int</span> ct = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input up to %d lines, and I will sort them.\n&quot;</span>, LIM);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;To stop ,press the Enter key at a line&#x27;s start.\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(ct &lt; LIM &amp;&amp; s_gets(input[ct], SIZE) != <span class="literal">NULL</span> &amp;&amp; input[ct][<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ptstr[ct] = input[ct];</span><br><span class="line">ct ++;</span><br><span class="line">&#125;</span><br><span class="line">stsrt(ptstr, ct);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\nHere&#x27;s the sorted list:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>( k = <span class="number">0</span>; k &lt; ct; k++)</span><br><span class="line"><span class="built_in">puts</span>(ptstr[k]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stsrt</span><span class="params">(<span class="type">char</span> * strings[], <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * temp;</span><br><span class="line"><span class="type">int</span> top, seek;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(top = <span class="number">0</span>; top &lt; num - <span class="number">1</span>; top++)</span><br><span class="line"><span class="keyword">for</span>(seek = top + <span class="number">1</span>; seek &lt; num; seek++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(strings[top], strings[seek]) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = strings[top];</span><br><span class="line">strings[top] = strings[seek];</span><br><span class="line">strings[seek] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="title function_">s_gets</span><span class="params">(<span class="type">char</span> * st, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> * ret_val;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret_val = fgets(st , n , <span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ret_val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(st[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">while</span>(getchar() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span> len)</span><span class="comment">//函数实现</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)<span class="comment">//需要进行len-1趟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//flag=1，说明已经排好序</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i;j++)<span class="comment">//每趟两两比较较未排好序元素个数-1次。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[j] &gt; p[j+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = p[j];</span><br><span class="line">p[j] = p[j + <span class="number">1</span>];</span><br><span class="line">p[j + <span class="number">1</span>] = tmp;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag==<span class="number">1</span>)<span class="comment">//判断是否排好序</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">46</span>,<span class="number">79</span>,<span class="number">12</span> &#125;;</span><br><span class="line"><span class="type">int</span> sz = <span class="keyword">sizeof</span> arr / <span class="keyword">sizeof</span> arr[<span class="number">0</span>];</span><br><span class="line">bubble_sort(arr,sz);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工具vim</title>
      <link href="/2022/10/20/Linux%E5%B7%A5%E5%85%B7vim/"/>
      <url>/2022/10/20/Linux%E5%B7%A5%E5%85%B7vim/</url>
      
        <content type="html"><![CDATA[<p>vi编辑器是所有Unix及<a href="http://www.2cto.com/os/linux/">Linux</a>系统下标准的编辑器，他就相当于<a href="http://www.2cto.com/os/windows/">windows</a>系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。<a href="https://so.csdn.net/so/search?q=vim&spm=1001.2101.3001.7020">vim</a> 具有程序编辑的能力，可以以字体颜色辨别语法的正确性。</p><p>vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式</p><p>一般模式：<br>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。</p><p>编辑模式：<br>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】即可退出编辑模式。</p><p>命令行模式：<br>输入【 : &#x2F; ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！</p><p>针对程序员配置</p><p>打开高亮功能，vim会通过文件的扩展名自动决定哪些是关键字。</p><p>：syntax on</p><p>自动缩进</p><p>：set autoindent</p><p>设置tab键的空格数</p><p>：set shiftwidth&#x3D;4</p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/vimopen.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/vimParenthesis.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/sn.png"></p><p><img src="https://cdn.jsdelivr.net/gh/hanfengdyh/image@main/bloglmg/close.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——进程管理</title>
      <link href="/2022/10/20/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/20/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>进程</p><p><u>进程是用来表示正在进行的程序。</u></p><p>内核中一些重要的进程信息如下：</p><p>进程的内存地址；</p><p>进程当前的状态；</p><p>进程正在使用的资源；</p><p>进程的优先级；</p><p>进程的属组；</p><p><strong>PID</strong>：进程的ID号</p><p><strong>PPID</strong>：父进程的PID</p><p>所有的进程都必须由另一个进程创建——除了系统在系统引导时，由内核自主创建并安装的进程。当一个进程被创建时，创建他的那个进程称为父进程。这个进程叫做子进程；PPID就是父进程的PID。</p><p>只有进程的创建者和root用户才有权对该进程进行操作，记录进程的创建者（属组）就必要了，进程的<strong>UID</strong>就是创建者的ID。</p><p>Linux为进程保存了有效用户ID号叫<strong>EUID</strong>，用来确定进程对某些资源和文件的访问权限。绝大部分情况，UID和EUID一样，除了seruid程序。</p><p>进程的<strong>GID</strong>是创建者所属组的ID号，进程同样有一个<strong>EGID</strong>号，当进程需要创建一个新文件时候，这个文件将采用该进程的GID。</p><h4 id="监视进程：PS命令"><a href="#监视进程：PS命令" class="headerlink" title="监视进程：PS命令"></a>监视进程：PS命令</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d0ada7c0d.png" alt="屏幕截图 2022-10-20 123723.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">$ ps lax##可以提供父进程ID（PPID）和谦让度（IN）</span><br></pre></td></tr></table></figure><h4 id="即时跟踪进程信息"><a href="#即时跟踪进程信息" class="headerlink" title="即时跟踪进程信息"></a>即时跟踪进程信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top##实时检测10更新一回q退出</span><br></pre></td></tr></table></figure><h4 id="查看占用文件的进程"><a href="#查看占用文件的进程" class="headerlink" title="查看占用文件的进程"></a>查看占用文件的进程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof database.doc##查找文件的进程</span><br></pre></td></tr></table></figure><h4 id="向进程发送信号：kill"><a href="#向进程发送信号：kill" class="headerlink" title="向进程发送信号：kill"></a>向进程发送信号：kill</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d50bb4963.png" alt="屏幕截图 2022-10-20 125610.png"></a></p><h4 id="调整进程的谦让度（优先级的反义）nice和renice"><a href="#调整进程的谦让度（优先级的反义）nice和renice" class="headerlink" title="调整进程的谦让度（优先级的反义）nice和renice"></a>调整进程的谦让度（优先级的反义）nice和renice</h4><p><a href="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png"><img src="https://cdn2.pandaimg.com/2022/10/20/6350d9a16f49d.png" alt="屏幕截图 2022-10-20 131600.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——用户管理</title>
      <link href="/2022/10/19/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/19/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="添加新用户并建立主目录"><a href="#添加新用户并建立主目录" class="headerlink" title="添加新用户并建立主目录"></a>添加新用户并建立主目录</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesradd -m john##添加用户叫john并建立主目录</span><br><span class="line">$ sudo passwd john##更改john的密码</span><br></pre></td></tr></table></figure><h4 id="添加用户命令行工具"><a href="#添加用户命令行工具" class="headerlink" title="添加用户命令行工具"></a>添加用户命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useradd john##添加用户john</span><br><span class="line">$ passwd john##john设置密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -g users john##创立john并指定属于users组</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -s /bin/bash mike##建立mike用户并指定登陆后使用bash作为Shell</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd newgroup##在系统中太内疚newgroup的组</span><br></pre></td></tr></table></figure><h4 id="记录用户操作"><a href="#记录用户操作" class="headerlink" title="记录用户操作"></a>记录用户操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br><span class="line">$ history 10##记录了最近用的10条指令</span><br></pre></td></tr></table></figure><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uesrdel mike##删除用户mike</span><br><span class="line">$ sudo userdel -r john##删除john删除其主目录</span><br></pre></td></tr></table></figure><h4 id="管理用户账号"><a href="#管理用户账号" class="headerlink" title="管理用户账号"></a>管理用户账号</h4><p><a href="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png"><img src="https://cdn2.pandaimg.com/2022/10/19/634ff773348ce.png" alt="屏幕截图 2022-10-19 211029.png"></a></p><h4 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id hanfeng##查看用户的UID、GID及所属组的信息</span><br></pre></td></tr></table></figure><h4 id="用户转换"><a href="#用户转换" class="headerlink" title="用户转换"></a>用户转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su john##进入john用户</span><br><span class="line">$ exit##回到之前的用户</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-压缩与解压缩</title>
      <link href="/2022/10/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2022/10/18/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<h4 id="gzip压缩工具"><a href="#gzip压缩工具" class="headerlink" title="gzip压缩工具"></a>gzip压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gzip gztest##压缩gztest</span><br><span class="line">$ gzip -d gztest##解压缩gztest</span><br><span class="line">$ gzip -r gztest##对文件夹压缩</span><br><span class="line">$ gzip -rd gztest.gz##对文件夹解压缩</span><br></pre></td></tr></table></figure><p>gzip 虽然对文件夹进行压缩，但是不能提供打包服务，只对文件夹<strong>内部的文件进行单独压缩。</strong></p><h4 id="bzip2压缩工具"><a href="#bzip2压缩工具" class="headerlink" title="bzip2压缩工具"></a>bzip2压缩工具</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bzip2 -z a.c##压缩</span><br><span class="line">$ bzip2 -d a.c.bz2##解压缩</span><br></pre></td></tr></table></figure><h4 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h4><p>tar工具提供打包服务，就是将多个文件打包。常用参数-f归档 ,-c创建新归档创建压缩文件，-x：从文档中解压缩</p><p>-j：使用bzip2压缩格式，-z 使用gzip压缩格式 -v 打印命令执行过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tar -vxjf xxx.tar.bz2##解压缩</span><br><span class="line">$ tar -vcjf xxx.tar.bz2 xxx ##压缩</span><br><span class="line">$ tar -vxzfxxx.tar.gz##解压缩</span><br><span class="line">$ tar -vczf xxx.tar.gz xxx ##压缩</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇-软件包管理</title>
      <link href="/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="管理-deb软件包"><a href="#管理-deb软件包" class="headerlink" title="管理.deb软件包"></a>管理.deb软件包</h4><h6 id="查看已安装的软件包"><a href="#查看已安装的软件包" class="headerlink" title="查看已安装的软件包"></a>查看已安装的软件包</h6><p> OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet(终端仿真协议)、 rcp ftp、 rlogin、rsh都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg -l | grep openssh##查找openssh的版本信息</span><br><span class="line">$ dekg -s openssh##查看哪些文件是openssh带来的</span><br></pre></td></tr></table></figure><h6 id="安装卸载软件包"><a href="#安装卸载软件包" class="headerlink" title="安装卸载软件包"></a>安装卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sudo dpkg -i xxx.deb##安装xxx</span><br><span class="line"></span><br><span class="line">$sudo dpkg --remove opera##删除opera浏览器</span><br></pre></td></tr></table></figure><h4 id="管理RPM软件包"><a href="#管理RPM软件包" class="headerlink" title="管理RPM软件包"></a>管理RPM软件包</h4><h6 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -i -v -h dump-0.4b41-1.src.rpm##-i是安装命令-v显示正在执行工作-h打印提醒进度</span><br></pre></td></tr></table></figure><p>升级安装包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -Uvh dump-0.4b41-1.src.rpm</span><br></pre></td></tr></table></figure><p>查看已经安装的软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -q check##rpm -q命令可以查询已经安装的软件包是安装包文件的名字，不是文件的名字</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634ba96fd0a8e.png" alt="屏幕截图 2022-10-16 144841.png"></a></p><h6 id="卸载软件包"><a href="#卸载软件包" class="headerlink" title="卸载软件包"></a>卸载软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rpm -e tcpdump##卸载tcpdump软件包</span><br></pre></td></tr></table></figure><h4 id="高级软件包工具APT"><a href="#高级软件包工具APT" class="headerlink" title="高级软件包工具APT"></a>高级软件包工具APT</h4><h6 id="下载和安装软件包"><a href="#下载和安装软件包" class="headerlink" title="下载和安装软件包"></a>下载和安装软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update##更新软件包</span><br><span class="line">$ sduo apt-get install wesnoth##下载安装wesnoth</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png"><img src="https://cdn2.pandaimg.com/2022/10/16/634baf70f406c.png" alt="屏幕截图 2022-10-16 151437.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get -h##可以列出apt-get的完整用法</span><br></pre></td></tr></table></figure><h6 id="查询软件包"><a href="#查询软件包" class="headerlink" title="查询软件包"></a>查询软件包</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache search flight##搜索带有flight的软件包</span><br><span class="line">$ apt-cache depends flightgear##查询flightgear的依赖关系</span><br></pre></td></tr></table></figure><p>apt-get是安装源放在&#x2F;etc&#x2F;apt&#x2F;source.list中，这是一个文本文件。</p><h6 id="源码文件安装"><a href="#源码文件安装" class="headerlink" title="源码文件安装"></a>源码文件安装</h6><p>make先编译</p><p>之后使用make install具体方法看软件安装要求</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——磁盘管理</title>
      <link href="/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/10/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>磁盘管理三个常用的命令fdisk、du、df</p><p>df：检查文件系统的整体磁盘使用量</p><p>du：检查磁盘空间使用量</p><p>fdisk：用于磁盘的分区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [-ahikHTm][目录或文件名]##具体参数可以查看 df --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ du [-ahskm] 文件或目录名称    ##具体参数可以查看 du --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk [-l] 装置名称##fdisk是Linux的磁盘分区表操作工具</span><br></pre></td></tr></table></figure><p>若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><p>linux操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。挂载就是把设备放在一个目录下，让系统知道怎么管理这个设备里的文件，了解这个存储设备的可读写特性之类的过程。fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck [-t 文件系统] [-ACay] 装置名称</span><br></pre></td></tr></table></figure><p>磁盘挂载使用mount卸载使用umount命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount [-fn] 装置文件名或挂载点</span><br></pre></td></tr></table></figure><p>关于具体操作事例可以看<a href="https://zhuanlan.zhihu.com/p/296777898">一篇看懂！Linux磁盘的管理（分区、格式化、挂载），LVM逻辑卷，RAID磁盘阵列 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——文件目录管理指令</title>
      <link href="/2022/10/13/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/10/13/Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>linux系统不存在盘这个概念，用户通过操作目录来实现磁盘读写，Linux需要首先建立一个根‘“&#x2F;”文件系统，并在这个文件系统中建立一系列空目录，然后将其他硬盘分区中的 文件系统挂载到这些目录中。</p><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347abc1a4403.png" alt="屏幕截图 2022-10-13 140836.png"></a></p><h6 id="用户间共享文件"><a href="#用户间共享文件" class="headerlink" title="用户间共享文件"></a>用户间共享文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##新建一个名为workgroup的用户组</span><br><span class="line">$ sudo groupadd workgroup</span><br><span class="line">##新建用户，并归入workgroup组</span><br><span class="line">$sudo useradd -G workgroup lucy</span><br><span class="line">$sudo passwd lucy##为用户lewis设置登录密码</span><br><span class="line">$sudo useradd -G workgroup lewis</span><br><span class="line">$sudo passwd lewis##为用户peter设置登录密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="建立文件和目录"><a href="#建立文件和目录" class="headerlink" title="建立文件和目录"></a>建立文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~##进入用户主目录</span><br><span class="line">$ mkdir document picture##新建两个目录</span><br><span class="line">$ mkdir ~/picture/temp##在主目录下新建名为temp的目录</span><br><span class="line">##如果没有中间的目录也就无法在下面创建一个新的文件或目录为此，使用-p选项</span><br><span class="line">$ mkdir -p ~/tempx/job##创建一个tempx文件夹在下面创建一个job文件夹</span><br></pre></td></tr></table></figure><h6 id="建立一个空文件"><a href="#建立一个空文件" class="headerlink" title="建立一个空文件"></a>建立一个空文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch hello##新建一个hello的文件</span><br><span class="line">$ touch hello##已经有hello的文件，所以可以更新hello文件的创建日期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="移动和重命名"><a href="#移动和重命名" class="headerlink" title="移动和重命名"></a>移动和重命名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv hello bin/##移动hello到bin/中</span><br><span class="line">$ mv photos/桌面/   ##移动photos目录到桌面</span><br><span class="line">$ mv -i hello test/##使用防止替换同名文件并加以提示.</span><br><span class="line">$ mv -b hello test/##在目标目录的同名文件后面加上~，相当于重命名</span><br></pre></td></tr></table></figure><h6 id="复制文件和目录"><a href="#复制文件和目录" class="headerlink" title="复制文件和目录"></a>复制文件和目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp test.php test/##将test.php 放入到test下</span><br><span class="line">$ cp -i test.php test/##提示是否覆盖同名文件</span><br><span class="line">$ cp -r test/ 桌面/   ##连子目录带文件一起复制到下面</span><br></pre></td></tr></table></figure><h6 id="删除目录和文件"><a href="#删除目录和文件" class="headerlink" title="删除目录和文件"></a>删除目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redir remove##删除目录</span><br><span class="line">$ redir text/*.php##删除test目录下的所有php文件</span><br><span class="line">$ redir -r test##删除前有提示</span><br><span class="line">$ redir -f##避免交互直接回答y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="改变文件所有权"><a href="#改变文件所有权" class="headerlink" title="改变文件所有权"></a>改变文件所有权</h6><p>chown语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [OPTION]... [OWNEr][:[GROUP]] FILE..</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f350c425d.png" alt="屏幕截图 2022-10-13 191232.png"></a></p><p>sudo 提供-R选项用于改变一个目录及其下所有文件的所有权设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R lewis iso/##将iso/和下面所有文件交给lewis</span><br></pre></td></tr></table></figure><h6 id="改变目标文件权限"><a href="#改变目标文件权限" class="headerlink" title="改变目标文件权限"></a>改变目标文件权限</h6><p>chmod用于改变一个文件的权限。使用用户组+&#x2F;-权限的表达方式，来增加&#x2F;删除权限。用户组包括文件属主（u）、文件数组（g）、其他人（o）和所有人（a），权限包括读取（r）、写入（w）和执行（x）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod u+x days##增加属主对文件的执行权限</span><br><span class="line">$ chmod a-x days##删除所有人对days的执行权限</span><br><span class="line">$ chmod o=u days##将其他人的权限和属主一致</span><br></pre></td></tr></table></figure><h6 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6347f9e831a3c.png" alt="屏幕截图 2022-10-13 194308.png"></a></p><p>Linux有两类设备文件：字符设备和块设备文件。字符设备指的是能够从他那里读取成字符序列的设备，如磁带和串行线路，块设备指的是用来存储数据并对其各部分内容提供同等访问权的设备。如磁盘。</p><h6 id="建立链接"><a href="#建立链接" class="headerlink" title="建立链接"></a>建立链接</h6><p>符号链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s days my_days##建立一个my_days的符号链接指向文本文件days</span><br></pre></td></tr></table></figure><p>访问my_days就相当于访问days了。可以看作快捷方式删除并不会对源文件有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -s /usr/local/share/ local_share##建立一个指向/usr/local/share的符号链接local_share</span><br></pre></td></tr></table></figure><p>硬链接：将两个独立的文件联系在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln days hard_days##建立一个链接到days的新文件hard_days</span><br></pre></td></tr></table></figure><p>两个文件的改动会相互影响。</p><h6 id="输入输出重定向和管道"><a href="#输入输出重定向和管道" class="headerlink" title="输入输出重定向和管道"></a>输入输出重定向和管道</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls &gt; ~/ls_out##将ls的输出重定向到lsout文件中，ls的输出不显示在屏幕上</span><br></pre></td></tr></table></figure><p>如果ls_out不存在那么会尝试建立这个文件，如果已经存在会替换原来的文件内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt; days##让程序从一个文件中获取输入</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png"><img src="https://cdn2.pandaimg.com/2022/10/13/634808e94fcc6.png" alt="屏幕截图 2022-10-13 204659.png"></a></p><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><p><a href="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png"><img src="https://cdn2.pandaimg.com/2022/10/13/6348095b998d1.png" alt="屏幕截图 2022-10-13 204909.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux系统管理篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理篇——基本指令</title>
      <link href="/2022/10/12/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/10/12/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="vim文本编译器"><a href="#vim文本编译器" class="headerlink" title="vim文本编译器"></a>vim文本编译器</h2><p>vim编译器编写文档、配置主机名称、网卡参数以及仓库。</p><p>三种模式——命令模式、末行模式、编辑模式。</p><p>命令模式：控制光标，可对文本删除、复制、粘贴</p><p>输入模式：正常的文本录入</p><p>末行模式：保存、退出与设置编译环境。</p><p><a href="https://cdn2.pandaimg.com/2022/10/12/63464afc99ff1.png"><img src="https://cdn2.pandaimg.com/2022/10/12/63464afc99ff1.png" alt="vim.png"></a></p><p><strong>vim命令模式常用快捷键</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>5dd</td><td>删除光标开始的5行</td></tr><tr><td>yy</td><td>复制所在行</td></tr><tr><td>5yy</td><td>复制光标开始的5行</td></tr><tr><td>p</td><td>将之前删除或者复制的粘贴到光标后</td></tr><tr><td>&#x2F;字符串</td><td>文本中从上至下搜索该字符串</td></tr><tr><td>？字符串</td><td>文本中从下至上搜索该字符串</td></tr><tr><td>n</td><td>显示搜索命令定位到下一个字符串</td></tr><tr><td>N</td><td>显示搜索命令定位到上一个字符串</td></tr><tr><td>u</td><td>撤销上一步操作</td></tr></tbody></table><p><strong>vim末行模式常用命令</strong></p><table><thead><tr><th>命令</th><th align="center">作用</th></tr></thead><tbody><tr><td>:w</td><td align="center">保存</td></tr><tr><td>:q</td><td align="center">退出</td></tr><tr><td>:q!</td><td align="center">强制退出</td></tr><tr><td>:wq!</td><td align="center">强制保存退出</td></tr><tr><td>:set nu</td><td align="center">显示行数</td></tr><tr><td>:set nonu</td><td align="center">不显示行数</td></tr><tr><td>:整数</td><td align="center">跳到该行</td></tr><tr><td>:命令</td><td align="center">执行该命令</td></tr></tbody></table><p>计算机硬件由<strong>预算器、控制器、存储器、输入&#x2F;输出设备</strong>等设备组成。系统内核能让机箱各种设备各司其职。内核负责驱动硬件、管理活动和分配&#x2F;管理硬件资源，<strong>不让用户直接操作</strong>。</p><p>shell称为壳，充当人与内核（硬件）的翻译官。<strong>shell脚本是将各种命令通过逻辑语句组合而成的程序。</strong></p><p>shell工作形式分为两种：</p><p>交互式：输入一条命令，shell解释并执行一条。</p><p>批处理：用户事先编写一个shell脚本，包含诸多命令，shell会一次执行完所有命令。</p><p>shell脚本编写用到vim文本编译器。<strong>一个完整shell脚本应该包含脚本声明、注释信息、可执行语句</strong></p><p>根据实际情况来组合各种命令选择和命令参数：<strong>命令名称[命令参数]【命令对象】</strong></p><p>命令对象一般是指要处理的目标（普通文件&#x2F;目标文件&#x2F;用户等）</p><p>命令的参数可选用长格式也可用短格式分别以—与-做前缀</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h6 id="浏览文件硬盘"><a href="#浏览文件硬盘" class="headerlink" title="浏览文件硬盘"></a>浏览文件硬盘</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /         ##进入根目录</span><br><span class="line">$ ls           ##列出文件和目录</span><br><span class="line">$ cat animal.c ##查看animal.c</span><br></pre></td></tr></table></figure><p>在输入文件名时候，只用输入前面几个字符按下TAB，Shell会自动补全。如果不止一个，shell会以列表形式全部打印出来。</p><h6 id="查看目录和文件"><a href="#查看目录和文件" class="headerlink" title="查看目录和文件"></a>查看目录和文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pwd                     ##显示当前目录</span><br></pre></td></tr></table></figure><h6 id="改变目录"><a href="#改变目录" class="headerlink" title="改变目录"></a>改变目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ..##进入/usr子目录</span><br><span class="line">$ cd ../..##进入根目录即/目录</span><br><span class="line">$ cd ##回到用户主目录</span><br></pre></td></tr></table></figure><h6 id="列出目录"><a href="#列出目录" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -a##查看目录下的所有文件包含隐藏文件</span><br><span class="line">$ ls -1##查看文件的各种属性</span><br><span class="line">$ ls -F##区分目录下文件类型</span><br></pre></td></tr></table></figure><h6 id="列出目录-1"><a href="#列出目录-1" class="headerlink" title="列出目录"></a>列出目录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dir##和ls一样</span><br><span class="line">$ vdir##相当于ls-1</span><br></pre></td></tr></table></figure><h6 id="查看文本文件"><a href="#查看文本文件" class="headerlink" title="查看文本文件"></a>查看文本文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat bool。c##查看bool.c文件的内容</span><br><span class="line">$ cat bool.c data.c##查看bool.c data.c 文件内容，可以查看不只一个文件内容</span><br><span class="line">$ cat -n bool.c##可以问内容前显示行数</span><br></pre></td></tr></table></figure><h6 id="阅读的文件开头和结尾"><a href="#阅读的文件开头和结尾" class="headerlink" title="阅读的文件开头和结尾"></a>阅读的文件开头和结尾</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ head data.c##显示data。c的开头</span><br><span class="line">$ head -n 2 data.c##显示data.c文件的前两行</span><br></pre></td></tr></table></figure><h6 id="文本阅读less"><a href="#文本阅读less" class="headerlink" title="文本阅读less"></a>文本阅读less</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ less /c/data.c##打开C下的data.c文件</span><br><span class="line">之后向下翻页按空格向上翻页按B使用/内容，可以查询高亮显示查询下一个再输入/</span><br><span class="line">按下q可退出</span><br></pre></td></tr></table></figure><h6 id="查找文件内容"><a href="#查找文件内容" class="headerlink" title="查找文件内容"></a>查找文件内容</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep main data.c##查找data.c中包含main的行</span><br><span class="line">$ grep main data.c animal.c     ##可以在多个文件中查找，查关键词时候要加上‘’单引号</span><br></pre></td></tr></table></figure><h6 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [OPTION] [path..] [expression]</span><br><span class="line">$ find c/d/2.c##c/d/2.c</span><br><span class="line">$ find c/d -name 2.c##c/d2.c</span><br><span class="line">$ find c/d -name 2.c -printf ok ##ok</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/12/63469dc80cff2.png"><img src="https://cdn2.pandaimg.com/2022/10/12/63469dc80cff2.png" alt="屏幕截图 2022-10-12 185720.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find c/d -type f -mtime -7 ##7天内修改过的文件</span><br></pre></td></tr></table></figure><h6 id="快速定位文件"><a href="#快速定位文件" class="headerlink" title="快速定位文件"></a>快速定位文件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locate *.c</span><br></pre></td></tr></table></figure><h6 id="查找特定程序"><a href="#查找特定程序" class="headerlink" title="查找特定程序"></a>查找特定程序</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ whereis find##查找find</span><br><span class="line">$ whereis -b find##查找这个程序的二进制可执行文件</span><br></pre></td></tr></table></figure><h6 id="用户版本信息查看"><a href="#用户版本信息查看" class="headerlink" title="用户版本信息查看"></a>用户版本信息查看</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ who##看有哪些人登录</span><br><span class="line">$ whoami##我是谁</span><br></pre></td></tr></table></figure><h6 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a##显示系统版本信息</span><br><span class="line">$ uname -r##显示内核版本信息</span><br></pre></td></tr></table></figure><h6 id="寻求帮助指令"><a href="#寻求帮助指令" class="headerlink" title="寻求帮助指令"></a>寻求帮助指令</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man find##获取find指令的信息</span><br></pre></td></tr></table></figure><h6 id="获取命令简介"><a href="#获取命令简介" class="headerlink" title="获取命令简介"></a>获取命令简介</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whatis uame##-printf system information</span><br></pre></td></tr></table></figure><p><a href="https://cdn2.pandaimg.com/2022/10/12/6346a69a1707e.png"><img src="https://cdn2.pandaimg.com/2022/10/12/6346a69a1707e.png" alt="屏幕截图 2022-10-12 193508.png"></a></p><h6 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h6><p>ldd可以列出一个程序所需要的共享库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ldd animal##查询animal文件需要的animal文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32实战篇</title>
      <link href="/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/"/>
      <url>/2022/10/09/stm32%E5%AE%9E%E6%88%98%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实战第一篇跑马灯"><a href="#实战第一篇跑马灯" class="headerlink" title="实战第一篇跑马灯"></a>实战第一篇跑马灯</h2><p>第一篇没什么好说的，没什么新鲜的东西，就是使用cubemx进行建立工程，新建led.c和led.h文件，对引脚进行赋予高低电平，此次不一样的是在led.h文件中对相应的IO口用英文做了宏定义，防止以后进行重复混乱调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_PIN         GPIO_PIN_8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED1_GPIO_PORT   GPIOA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_PIN         GPIO_PIN_2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED2_GPIO_PORT   GPIOD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_RED_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_GRE_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="实战第二篇按键检测"><a href="#实战第二篇按键检测" class="headerlink" title="实战第二篇按键检测"></a>实战第二篇按键检测</h2><h4 id="硬件消抖"><a href="#硬件消抖" class="headerlink" title="硬件消抖"></a>硬件消抖</h4><p>首先是硬件的设计，按下按键不会立即响应，有波纹信号，不方便检测需要进行滤波消抖。可以利用电容的放电延迟达到消除抖动的目的，这样只需要检测引脚的电平。</p><p><a href="https://postimg.cc/62dPcFkc"><img src="https://i.postimg.cc/hjwqDBMk/2022-09-27-181925.png" alt="2022-09-27-181925.png"></a></p><h4 id="软件消抖"><a href="#软件消抖" class="headerlink" title="软件消抖"></a>软件消抖</h4><p>当检测到按键状态变化后，先等待一个10ms左右的延时时间，让抖动消失后再进行一次按键状态检测，如果与刚才的状态相同，就是稳定了，但是有局限性。</p><p>查询相关IO口在cubemx中进行设置为输入状态。由于引脚的默认电平受按键电路影响，所以设置成“浮空&#x2F;上拉&#x2F;下拉”模式均没有区别。</p><p>arm汇编指令集</p><p><a href="https://postimg.cc/v413R6K1"><img src="https://i.postimg.cc/zG7MgCSk/2022-09-27-202146.png" alt="2022-09-27-202146.png"></a></p><p>栈的作用是用于局部变量，函数调用，函数形参等的开销，栈的大小不能超过内部 SRAM 的大<br>小。如果编写的程序比较大，定义的局部变量很多，那么就需要修改栈的大小。如果某一天，你<br>写的程序出现了莫名奇怪的错误，并进入了硬 fault 的时候，这时你就要考虑下是不是栈不够大，<br>溢出了。堆主要用来动态内存的分配</p><h2 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h2><p>设置系统时钟 SYSCLK、设置 AHB 分频因子（决定 HCLK 等于多少）、设置 APB2 分频因子（决<br>定 PCLK2 等于多少）、设置 APB1 分频因子（决定 PCLK1 等于多少）、设置各个外设的分频因子；<br>控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。</p><p>一般是：PCLK2 &#x3D; HCLK &#x3D; SYSCLK&#x3D;PLLCLK &#x3D; 72M，<br>               PCLK1&#x3D;HCLK&#x2F;2 &#x3D; 36M</p><p>HSE 是高速的外部时钟信号，可以由有源晶振或者无源晶振提供，频率从 4-16MHZ 不等。当<br>使用有源晶振时，时钟从 OSC_IN 引脚进入，OSC_OUT 引脚悬空，当选用无源晶振时，时钟从<br>OSC_IN 和 OSC_OUT 进入，并且要配谐振电容。</p><p>系统时钟 SYSCLK 经过 AHB 预分频器分频之后得到时钟叫 APB 总线时钟，即 HCLK。</p><p>APB2 总线时钟 PCLK2 由 HCLK 经过高速 APB2 预分频器得到，HCLK2 属于高速的总线时钟，片上<br>高速的外设就挂载到这条总线上。APB1 总线时钟 PCLK1 由 HCLK 经过低速 APB 预分频器得到，PCLK1 属于低速的总线时钟，最高为 36M，片上低速的外设就挂载到这条总线上，比如 USART2&#x2F;3&#x2F;4&#x2F;5、SPI2&#x2F;3，I2C1&#x2F;2 等。</p><p>USB 时钟是由 PLLCLK 经过 USB 预分频器得到，USB 对时钟要求比较高，所以 PLLCLK 只能是由 HSE 倍频得到，不能使用 HSI 倍频。</p><p>ADC 时钟由 PCLK2 经过 ADC 预分频器得到。</p><p>RTC 时钟可由 HSE&#x2F;128 分频得到，也可由低速外部时钟信号 LSE 提供，频率为 32.768KHZ，也可由<br>低速内部时钟信号LSI提供。独立看门狗的时钟由 LSI 提供，且只能是由 LSI 提供，LSI 是低速的内部时钟信号，频率为 30~60KHZ 直接不等，一般取 40KHZ。</p><h2 id="中断应用"><a href="#中断应用" class="headerlink" title="中断应用"></a>中断应用</h2><p>在 NVIC 有一个专门的寄存器：中断优先级寄存器 NVIC_IPRx，用来配置外部中断的优先级，IPR宽度为 8bit，原则上每个外部中断可配置的优先级为 0~255，数值越小，优先级越高。如果有多个中断同时响应，抢占优先级高的就会抢占抢占优先级低的优先得到执行，如果抢占优先级相同，就比较子优先级。如果抢占优先级和子优先级都相同的话，就比较他们的硬件中断编号，编号越小，优先级越高。</p><p>IRQn：用来设置中断源</p><p>PreemptionPriority：抢占优先级</p><p>SubPriority：子优先级</p><h5 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h5><p>EXTI（External interrupt&#x2F;event controller）—外部中断&#x2F;事件控制器，管理了控制器的 20 个中断&#x2F;事件线。每个中断&#x2F;事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。</p><p>产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p><p>cubemx进行引脚配置，对相应的IO引脚选择GPIO_EXITx,xi表示挂载在中断线几，如GPIO_EXTI0就是挂在中断线0上。</p><p>开启下降沿触发中断：即在 <strong>按下按键时</strong> 电平由高变为低时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Falling edge trigger detection</code> </p><p>开启上升沿触发中断：即在 <strong>按下按键后松开时</strong> 电平由低变为高时触发，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising edge trigger detection</code> </p><p>开启下降沿上升沿都触发中断：即在 <strong>按下时触发，松开时再次触发</strong>，则在 <code>GPIO mode</code> 中选择 <code>External Interrupt Mode with Rising/Falling edge trigger detection</code></p><p>如果硬件上已外部上拉或下拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>No pull-up and no pull-down</code> 既不上拉也不下拉。</p><p>如果硬件外部没有上拉，则在<code>GPIO Pull-up/Pull-down</code> 中选择 <code>Pull-up</code> 内部上拉电阻。</p><p>如果不希望电平跳变事件触发中断，就配置为事件模式，反之，配置为中断模式。</p><p>中断执行流程为先中断初始化，使用中断可以避免使用论询来检测，发生电平变化触发外部中断，进入中断服务函数，中断服务函数中会调用中断处理公用函数（使用cubemx会在stm32f1xx_it.c中自动生成），中断处理公用函数中会检测标志位，并清零执行回调函数，终端中要执行的事情就放入中断回调函数中。</p><p>可以在stm32f1xx_it.c中看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 0 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 0 */</span></span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN EXTI4_IRQn 1 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END EXTI4_IRQn 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go to Defnition of HAL_GPIO_EXTI_IRQHandler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* EXTI line interrupt detected */</span></span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断并清除中断标志位，然后调用HAL_GPIO_EXTI_Callback(GPIO_Pin);处理中断，同样的方式找到HAL_GPIO_EXTI_Callback的定义，你可以看到这个函数的声明前面有一个__weak声明，这个声明表示这个函数一旦被重新声明，这里的函数就自动失效，其他函数调用的时候就会找到你新定义的同名函数。</p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。串口通讯有很多标准，以下是RS-232标准</p><p><a href="https://postimg.cc/zHmFByDH"><img src="https://i.postimg.cc/d33H5Cz6/2022-09-30-200343.png" alt="2022-09-30-200343.png"></a></p><p>由于 RS-232 电平标准的信号不能直接被控制器直接识别，所以这些信号会经过一个“电平转换芯片”转换成控制器能识别的“TTL 标准”的电平信号，才能实现通讯。电平标准不同分为TTL标准和RS232电平标准</p><p><a href="https://postimg.cc/LhHzyFYp"><img src="https://i.postimg.cc/2jW2SzCV/2022-09-30-201456.png" alt="2022-09-30-201456.png"></a></p><p><a href="https://postimg.cc/MXCz6q7k"><img src="https://i.postimg.cc/zXBvkf3f/2022-09-30-201723.png" alt="2022-09-30-201723.png"></a></p><p>通用同步异步收发器 (Universal Synchronous Asynchronous Receiver and Transmitter) 是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。有别于 USART 还有一个 UART(UniversalAsynchronous Receiver and Transmitter)，它是在 USART 基础上裁剪掉了同步通信功能，只有异步通信。简单区分同步和异步就是看通信时需不需要对外提供时钟输出，我们平时用的串口通信基本都是 UART。</p><p>串口通信有三种方式，分别为论询方式、中断方式、DMA方式。串口的通讯协议由开始位，数据位，校验位，结束位构成。一般以一个低电平作为一帧数据的起始，接着跟随 8 位或者 9 位数据位，之后为校验位，分为奇校验，偶校验和无校验，最后以一个先高后低的脉冲表示结束位，长度可以设置为 0.5，1，1.5 或 2 位长度。</p><p>当使用校验位时，串口传输的长度将是 8 位的数据帧加上 1 位的校验位总共 9 位，此时 USART_CR1 寄存器的 M 位需要设置为 1，即 9 数据位。将 USART_CR1 寄存器的 PCE 位置 1 就可以启动奇偶校验控制，奇偶校验由硬件自动完成。启动了奇偶校验控制之后，在发送数据帧时会自动添加校验位，接收数据时自动验证校验位。接收<br>数据时如果出现奇偶校验位验证失败，会见 USART_SR 寄存器的 PE 位置 1，并可以产生奇偶校验中断。使能了奇偶校验控制后，每个字符帧的格式将变成：起始位 + 数据帧 + 校验位 + 停止位</p><p>​      什么是硬件流控呢？流控的概念源于 RS232 这个标准，在 RS232 标准里面包含了串口、流控的定义。大家一定了解，RS232 中的“RS”是Recommend Standard 的缩写，即”推荐标准“之意，它并不像 IEEE-1284、IEEE-1394 等标准，是由“委员会定制”。因而，不同的厂商在做 RS232 时，多少会有不同，流控也都会存在差异。</p><p>为什么需要流控?</p><p>　　数据在两个串口之间进行通讯的时候常常会出现丢失数据的现象，比如两台计算机或者是一台计算机和一个单片机之间进行通讯，当接收端的数据缓冲区已经满了，这个时候如果还有数据发送过来，因为接收端没有时间进行处理，那这样的数据就有可能会丢失。在工业现场或者其他领域，经常会遇到这种问题，本质原因是速度不匹配、处理能力不匹配。比如单片机的主频只有20M或30M，ARM的处理能力可能是200M，PC机的处理能力是几个G，这种处理能力的不匹配造成了传输的时候数据容易丢失。</p><p>　　硬件流控就是来解决这个速度匹配的问题。它的基本含义非常简单，当接收端接收到的数据处理不过来时，就向发送端发送不再接收的信号，发送端接收到这个信号之后就会停止发送，直到收到可以继续发送的信号再继续发送。因此流控本身是可以控制数据传输的进度，进而防止数据丢失。</p><p>　　一般常用的流控方式有两种：硬件流控和软件流控。</p><p>​硬件流控和软件流控的区别</p><p>　　软件流控是以特殊的字符来代表从机已经不能再接收新的数据了，基本的流程就是从机在接收数据很多的时候或主动给发送端发送一个特殊字符，当发送端接收到这个特殊字符后就不能再发送数据了。</p><p>　　软件流控很方便，不需要增加新的硬件，还是以前的TX、RX，但是使用了软件流控，它本身的字符也是数据，这个数据只不过是说在软件里把它设置了一个特殊的含义。如果它是一个全双工的通讯，在给另一个串口发送数据的时候如果也包含了这样一个特殊字符，对方就会误以为我让它不要再发送数据了，会有一定的概率出现错误，而硬件流控就不需要考虑这方面，只需要使用 CTS 和 RTS，所有的数据都是由硬件来操作的。具体可以看<a href="https://www.cnblogs.com/923327iu/p/12159551.html#:~:text=STM32%20%E4%B8%8A%E6%9C%89%E4%B8%80%E4%B8%AA%20DE%20%E7%AE%A1%E8%84%9A%E5%92%8C%20RS485%20%E7%9A%84%E6%8E%A5%E6%94%B6%E5%99%A8%E8%8A%AF%E7%89%87%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%EF%BC%8C%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%94%B6%E5%8F%91%EF%BC%8C%E6%89%80%E4%BB%A5%E6%88%91%E4%BB%AC%E8%A6%81%E7%9F%A5%E9%81%93%E5%9C%A8,STM32%20%E7%9A%84%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E4%B8%AD%E5%85%B6%E5%AE%9E%E5%8C%85%E5%90%AB%E4%B8%A4%E6%96%B9%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%20RS232%20%E7%9A%84%20CTS%E3%80%81RTS%3B%E5%8F%A6%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AF%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%90%91%E7%9A%84%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%AE%83%E6%98%AF%E5%9F%BA%E4%BA%8E%20RS485%20%E7%9A%84%EF%BC%8C%E5%9C%A8%E8%BD%AF%E4%BB%B6">stm32串口USART 硬件流控 –学习笔记 - 国产零零柒 - 博客园 (cnblogs.com)</a></p><p><a href="https://postimg.cc/8F1VsbPM"><img src="https://i.postimg.cc/nLmVRdyR/2022-09-30-205236.png" alt="2022-09-30-205236.png"></a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、</span><br><span class="line">HAL_UART_Transmit();串口轮询模式发送，使用超时管理机制</span><br><span class="line">HAL_UART_Receive();串口轮询模式接收，使用超时管理机制</span><br><span class="line">HAL_UART_Transmit_IT();串口中断模式发送</span><br><span class="line">HAL_UART_Receive_IT();串口中断模式接收</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式发送</span><br><span class="line">HAL_UART_Transmit_DMA();串口DMA模式接收</span><br><span class="line"><span class="number">2</span>、阻塞传输是调用这个函数并在等待时间内一直等待操作完成。</span><br><span class="line">HAL_UART_Transmit</span><br><span class="line">HAL_UART_Receive</span><br><span class="line">查询的方式一般少用，这里不做过多介绍。</span><br><span class="line"><span class="number">3</span>、串口中断</span><br><span class="line">串口中断函数</span><br><span class="line">HAL_UART_TxHalfCpltCallback();一半数据发送完成时调用</span><br><span class="line">HAL_UART_TxCpltCallback();数据完全发送完成后调用</span><br><span class="line">HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用</span><br><span class="line">HAL_UART_RxCpltCallback();数据完全接受完成后调用</span><br><span class="line">HAL_UART_ErrorCallback();传输出现错误时调用</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Qxiaofei_/article/details/119029425">(具体配置) 【STM32】HAL库——串口中断通信(二)_Q大帅的博客-CSDN博客_hal 串口中断</a></p><p>当printf打印不好使时是因为工程中没有选Micro USB</p><p><a href="https://postimg.cc/Z9kXMvXH"><img src="https://i.postimg.cc/XvX3Xw8R/2022-10-04-193120.png" alt="2022-10-04-193120.png"></a></p><p><a href="https://blog.csdn.net/zxt510001/article/details/125892562">() STM32 HAL库串口串口通信基础知识+HAL库代码理解</a></p><h2 id="DMA-直接存储访问"><a href="#DMA-直接存储访问" class="headerlink" title="DMA-直接存储访问"></a>DMA-直接存储访问</h2><p>DMA是单片机外设，不占用CPU，传输数据时候CPU可以做别的。如果外设要想通过 DMA 来传输数据，必须先给 DMA 控制器发送 DMA 请求，DMA 收到请求信号之后，控制器会给外设一个应答信号，当外设应答后且 DMA 控制器收到应答信号之后，就会启动 DMA 的传输，直到传输完毕。DMA有12个可独立编程通道，每个通道对应不同的外设DMA请求，可以接受多个请求，但同时只能接受一个。仲裁器，处理响应顺序的问题，分为软件阶段和硬件阶段，可以在 DMA_CCRx 寄存器中设置，有 4 个等级：非常高、高、中和低四个优先级，如果两个或以上的 DMA 通道请求设置的优先级一样，则他们优先级取决于通道编号，编号越低优先权越高。</p><p>MA 传输数据的方向有三个：从外设到存储器，从存储器到外设，从存储器到存储器。具体的方向 DMA_CCR 位 4 DIR 配置：0 表示从外设到存储器，1 表示从存储器到外设。</p><p>更多原理可参看<a href="https://blog.csdn.net/as480133937/article/details/104927922"> DMA原理</a></p><p>在cubemx的配置只需要加上相应设备的DMA模式便可以生成代码进行使用。</p><p>I2C协议</p><p>首先分为物理层和协议层，两方面来看。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。</p><p>一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。</p><p> 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。</p><p>总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。</p><p>多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。</p><p>具有三种传输模式：标准模式传输速率为 100kbit&#x2F;s ，快速模式为 400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多 I2C 设备尚不支持高速模式</p><h4 id="协议层："><a href="#协议层：" class="headerlink" title="协议层："></a>协议层：</h4><p>I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。</p><p>S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。<br>起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号 (SLAVE_ADDRESS)。在I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7位或 10 位。在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收<br>到应答信号后，主机才能继续发送或接收数据。</p><p>若是传输为写数据方向，接收到应答信号后，主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位那么主机每发送完一个字节数据，都要等待从机的应答信号 (ACK)。</p><p>若配置的方向传输位为“读数据”方向，接收到应答信号后，从机开始向主机返回数据 (DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png"><img src="https://cdn2.pandaimg.com/2022/10/11/634564df3130c.png" alt="SDA.png"></a></p><h5 id="SCL处于1时-SDA由高变低↓—-gt-Start"><a href="#SCL处于1时-SDA由高变低↓—-gt-Start" class="headerlink" title="SCL处于1时, SDA由高变低↓—&gt;Start"></a>SCL处于1时, SDA由高变低↓—&gt;Start</h5><h5 id="图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高"><a href="#图中末尾P为结束信号-SCL-x3D-1-SDA-由低变高" class="headerlink" title="图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高"></a>图中末尾P为结束信号: SCL&#x3D;1, SDA 由低变高</h5><h5 id="数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化"><a href="#数据传送-每次数据传送都是8个字节-SCL-x3D-1时-SDA的数据不可以变化-只有SCL为低电平-数据线的数据才可以变化" class="headerlink" title="数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;"></a>数据传送: 每次数据传送都是8个字节; SCL&#x3D;1时, SDA的数据不可以变化, 只有SCL为低电平, 数据线的数据才可以变化;</h5><p><a href="%5B(88%E6%9D%A1%E6%B6%88%E6%81%AF"> IIchal相关函数分析</a> <a href="https://blog.csdn.net/kouxi1/article/details/123834448?ops_request_misc=&request_id=&biz_id=102&utm_term=stm32hal%E5%BA%93iic&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-123834448.142%5Ev52%5Econtrol,201%5Ev3%5Econtrol&spm=1018.2226.3001.4187">015] [STM32] IIC协议详解与HAL库相关函数分析_柯西的彷徨的博客-CSDN博客</a>)</p><h2 id="SPI协议"><a href="#SPI协议" class="headerlink" title="SPI协议"></a>SPI协议</h2><p>SPI是一种高速全双工的通信总线</p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>SPI 通讯使用 3 条总线及片选线，3 条总线分别为 SCK、MOSI、MISO，片选线</p><p>从设备选择信号线，常称为片选信号线，也称为 NSS、CS设备的其它信号线 SCK、MOSI 及 MIS O 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以 SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。</p><p>SCK ：时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样。<br> MOSI ：主设备输出&#x2F;从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。<br>MISO(Master Input,，Slave Output)：主设备输入&#x2F;从设备输出引脚。主机从这条信线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。</p><p><a href="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png"><img src="https://cdn2.pandaimg.com/2022/10/11/63457405a869b.png" alt="屏幕截图 2022-10-11 214647.png"></a></p><p>NSS 信号线由高变低，是 SPI 通讯的起始信号。NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处，NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。</p><p>观察图中的标号处，MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻，MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效，MOSI 及 MISO 为下一次表示数据做准备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(三)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p><u><strong>目录选项</strong></u></p><p>下列选项指定搜索路径，用于查头文件、库文件或编译器的某些成员。</p><p>(1)-Idir</p><p>在头文件的搜索路径列表中添加敌人目录。</p><p>(2)-I-</p><p>任何在“-I-” 前面用来指定的搜索路径只适用于“#include“file” ”这种情况，不适用于“#include&lt;stdio.h&gt;”</p><p>用-I-选项指定的搜索路径位于“-I-”选项后面，就可以搜索所有的#include指令</p><p>(3)-Ldir</p><p>在“-I”选项的搜索路径列表中添加dier目录。</p><p>(4)-Bprefix</p><p>这个选项指出在何处寻找可执行文件、库文件以及编译器自己的数据文件。编译器驱动程序需要使用某些工具，比如： cpp 、 ccl （或 C +＋的 cclplus )、 as 和 ld 。它把 prefix 当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。</p><p>对于要运行的工具，编译器驱动程序首先试着加上“- B ”前缀（如果存在），如果没有找到文件或没有指定“- B ”选项，编译器接着会试验两个标准前缀 usr &#x2F; lib &#x2F; gcc ／和&#x2F; usr &#x2F; local &#x2F; lib &#x2F; gcc - lib &#x2F;。如果仍然没能够找到所需文件，编译器就在“ PATH ”环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时（ run - time ）支持文件 libgcc . a 也在“- B ”前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找。如果上述方法没有找到这个文件，就不连接它了。多数情况的多数机器上， libgcc . a 并非必不可少。可以通过环境变量 GCCEXEC PREFIX 获得近似的效果：如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了“- B ”选项和 GCC EXEC _ PREFIX 变量，编译器首先使用“- B ”选项，然后才尝试环境变量值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(二)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>连接器选项</strong></p><p>（1）object-file-name</p><p>文件没有特别明确后缀，使用如下操作，obj文件可以变成连接器的输入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o  ,main.o和sub.o就是输入文件</span><br></pre></td></tr></table></figure><p>（2）-llibrary</p><p>连接名为library的库文件，这个方法找到的是库文件——即由OBJ文件组成的归档文件</p><p>（3）-nostartfiles</p><p>不连接系统标准启动文件，而标准库文件仍能正常启动</p><p>（4）-nostdlib</p><p>不连接系统标准启动文件和标准库文件，只把指定文件传递给连接器。仍以options程序作为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure><p>(5)-static</p><p>在支持动态连接的系统上阻止连接共享库</p><p>(6)-shared</p><p>生成一个共享OBJ文件，它可以和其他的OBJ文件连接产生可执行文件，只有部分系统支持，</p><p>不想用源代码发布程序时可以用它来生成库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line"></span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure><p>以后要使用sub.c 中的函数sub_fun时，连接程序时，将sub.a加入就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure><p>也可以多个文件作为一个库文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub .o sub2.o sub3.o</span><br></pre></td></tr></table></figure><p>(7)-Xlinker opion</p><p>把选项option传递给连接器。可以用来传递系统特定的连接选项，gcc无法识别这些选项。必须使用两次-Xlinker，一次传递选项，另一次传递其他参数。</p><p>(8)-Wl,option</p><p>把选项option传递给连接器。如果option中有逗号，就在逗号处分割成多个选项。</p><p>(9)-u symbol</p><p>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义可以使用多个-u选项各自跟上不同的符号，使得连接器调入附加的库模块。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux初学(一)</title>
      <link href="/2022/10/06/linux%E5%88%9D%E5%AD%A6/"/>
      <url>/2022/10/06/linux%E5%88%9D%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>一个C&#x2F;C++文件要经过预处理、编译、汇编、连接等四步才能变为可执行文件。</p><p>预处理就是要将包含（include）的文件插入到原文件中、宏定义展开、根据条件编译命令选择要使用的代码。</p><p>编译是把C&#x2F;C++代码翻译成汇编代码。</p><p>汇编是将输出的汇编代码翻译成一定格式的机器代码。</p><p>连接是将上部生成的OBJ和系统库的OBJ文件、库文件连接起来，最终生成可执行文件。</p><p>首先记录一些常用的linux指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~$ cd 目标文件夹名称                 导向目标文件夹所在终端</span><br><span class="line"></span><br><span class="line">~$ touch hel                               创建一个叫hel的文件</span><br><span class="line"></span><br><span class="line">~$ gedit hel.c                             创建一个叫hel.c的文件并用文本编辑器打开</span><br><span class="line"></span><br><span class="line">~$ gcc hel.c -o test                    编译hel.c为test可执行文件</span><br><span class="line"></span><br><span class="line">~$ ./test                                     执行test可执行文件</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多个.c文件使用命令将多个文件连接到一个可执行文件中，之后执行。</p><p>在C语言文件中调用math.h库报错只需要gcc将代码与链接库连接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc two.c -lm -o two</span><br></pre></td></tr></table></figure><p>编译C语言文件会有警告以及报错，但是警告是不显示的，需要用指令进行显示。</p><p>比如显示hello.c文件的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ gcc -Wll -c hello.c</span><br></pre></td></tr></table></figure><p>如果文件里有没定义的变量就会出现如下现象</p><p><a href="https://postimg.cc/KK9hg8zb"><img src="https://i.postimg.cc/XJWjmZ6r/yi.png" alt="yi.png"></a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>stm32系统学习</title>
      <link href="/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/09/24/stm32%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>stm32主系统由四个去驱动单元和四个被动单元构成。</strong></p><p>四个驱动是内核DCode总线；系统总线；通用DMA1；通用DMA2</p><p>四被动单元是AHB到APB的桥：连接所有APB的设备；内存FLASH；内部SRAM；FSMC</p><p>① ICode 总线：该总线将 M3 内核指令总线和闪存指令接口相连，指令的预取在该总线上<br>面完成。<br>② DCode 总线：该总线将 M3 内核的 DCode 总线与闪存存储器的数据接口相连接，常量<br>加载和调试访问在该总线上面完成。<br>③ 系统总线：该总线连接 M3 内核的系统总线到总线矩阵，总线矩阵协调内核和 DMA 间<br>访问。<br>④ DMA 总线：该总线将 DMA 的 AHB 主控接口与总线矩阵相连，总线矩阵协调 CPU 的<br>DCode 和 DMA 到 SRAM,闪存和外设的访问。<br>⑤ 总线矩阵：总线矩阵协调内核系统总线和 DMA 主控总线之间的访问仲裁，仲裁利用<br>轮换算法。<br>⑥ AHB&#x2F;APB 桥:这两个桥在 AHB 和 2 个 APB 总线间提供同步连接，APB1 操作速度限于<br>36MHz,APB2 操作速度全速。</p><p><strong>stm32的5个时钟源</strong></p><p>用来配置时钟树</p><p>①HSI 是高速内部时钟，RC 振荡器，频率为 8MHz。<br>②HSE 是高速外部时钟，可接石英&#x2F;陶瓷谐振器，或者接外部时钟源，频率范围为 4MHz到16MHz。<br>③LSI 是低速内部时钟，RC 振荡器，频率为 40kHz。独立看门狗的时钟源只能是 LSI，同<br>时 LSI 还可以作为 RTC 的时钟源。<br>④LSE 是低速外部时钟，使用频率为 32.768kHz 的石英晶体。这个主要是 RTC 的时钟源。<br>⑤PLL 为锁相环倍频输出，其时钟输入源可选择为 HSI&#x2F;2、HSE 或者 HSE&#x2F;2。倍频可选择为2到16 倍，但是其输出频率最大不得超过 72MHz。</p><p>程序执行顺序</p><p><a href="https://postimg.cc/68vJqYZh"><img src="https://i.postimg.cc/2SHzHt8g/liucheng.png" alt="liucheng.png"></a></p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32最小系统板制作</title>
      <link href="/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/"/>
      <url>/2022/09/21/stm32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9D%BF%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>此次制作使用的为立创EDA，主要是快速上手制板，没有选择AD。</p><p>首先了解<strong>stm32最小系统电路</strong>构成如下：</p><p>复位电路、电源电路、SWD&#x2F;JTAG下载接口、晶振电路（时钟电路）、启动选择电路、stm32构成。</p><p>关于启动选择电路可以查看以下链接来了解。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">Boot模式选择</a> STM32中BOOT模式配置的作用_qq_22010549的博客-CSDN博客_stm32f103boot设置](<a href="https://blog.csdn.net/qq_22010549/article/details/123425814">https://blog.csdn.net/qq_22010549/article/details/123425814</a>))</p><p>可以将boot0和boot1的两个分别设计单刀双制开关接3.3V和GND</p><p>主闪存模式是用ｆｌａｓｈ，使用串口下载，或者可以选择使用SWD</p><p>本款设计芯片选择stm32f103RCT６芯片。</p><p>晶振电路分别使用两种晶振８MＨｚ晶振提供外部时钟和３２．７６８ＫＨｚ内部晶振为RTC提供时钟信号。</p><p>复位电路由电容、电阻、开关组成，电路采用手动复位的方式，当开关闭合时电路导通，RSET为芯片的复位引脚信号，此时芯片复位引脚接通GND，芯片将会复位重启。其中的电容的功能则是储能，当开发板上电瞬间，电容开始充电，复位引脚为低电平，所以上电瞬间开发板也会复位重启，但随着电容充电完成，引脚变为高电平，则不会再进行复位重启。</p><p>为了方便下载程序设计JTAG电路</p><p>电源电路把电源电压稳压在3.3V给单片机供电。</p><p><a href="%5B(82%E6%9D%A1%E6%B6%88%E6%81%AF">稳压电路选择</a> 5V降压转3.3V，5V转3V电路图芯片_usb type的博客-CSDN博客_5v转3.3v稳压芯片](<a href="https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142%5Ev49%5Econtrol,201%5Ev3%5Econtrol_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/quke1/article/details/114530112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166381207416800182735752%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166381207416800182735752&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-114530112-null-null.142^v49^control,201^v3^control_2&amp;utm_term=5v%E8%BD%AC3.3v%E7%94%B5%E8%B7%AF&amp;spm=1018.2226.3001.4187</a>))</p><p>大多数选择为LDO电路，使用的一般为LM1117或者AMS117芯片。</p><p>stm32的MCU接口VDD接正极3.3V，VSS接地，VBAT使用电池或者其他电源，</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arm-linux -ld、-objcopy和obdump</title>
      <link href="/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/"/>
      <url>/2022/07/08/arm-linux-ld%E5%92%8Carm-linux-objcopy/</url>
      
        <content type="html"><![CDATA[<p><strong>arm-linux-ld用于将多个目标文件、库文件连接成可执行文件。</strong></p><p>-T 直接指定代码段、数据段、bss段的起始地址,只用于连接Bootloader、内核等没有底层软件支持的软件</p><p>连接操作系统应用程序时候，无需-T，默认连接。</p><p>1.直接指定代码段、数据段、bss段的起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure><p>startaddr分别代表代码段、数据段、bss段的起始地址</p><p>eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttext 0x000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure><p>代表代码段运行地址为0x000000，没有定义数据段、bss段起始地址所以被放入代码段的后面</p><p>2.使用连接脚本设置地址</p><p><strong>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可用不同于源文件的格式来输出目的文件，即可以进行格式转换。</strong></p><p>1、input-file、outfile分别是输入目标文件和输出目标文件，如果没有明确指定outfile，将创建一个临时文件来存放结果，用input-file的名字来命名。</p><p>2、 -l bfname或–input-target&#x3D;bfdname</p><p>用来指明源文件的格式，bfdname是BFD库描述的标准格式名，如果不指明格式，会自己分析源文件格式，去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</p><p>3、-O bfdname或–output-target&#x3D;bfdname</p><p>使用指定格式来输出文件，bdfname是BFD库中的标准格式名。</p><p><strong>arm-linux-objdump用于显示二进制文件信息</strong></p><p>未完待续。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32hal库</title>
      <link href="/2022/07/01/stm32hal%E5%BA%93/"/>
      <url>/2022/07/01/stm32hal%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>为方便使用，用typedef来给变量起名将以下放入main.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span>  s32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int16_t</span> s16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int8_t</span>  s8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int32_t</span> sc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int16_t</span> sc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int8_t</span> sc8;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int32_t</span>  vs32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int16_t</span>  vs16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">int8_t</span>   vs8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int32_t</span> vsc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int16_t</span> vsc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">int8_t</span> vsc8;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span>  u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint8_t</span>  u8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint32_t</span> uc32;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint16_t</span> uc16;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">uint8_t</span> uc8; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint32_t</span>  vu32;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint16_t</span> vu16;</span><br><span class="line"><span class="keyword">typedef</span> __IO <span class="type">uint8_t</span>  vu8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint32_t</span> vuc32;  </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint16_t</span> vuc16; </span><br><span class="line"><span class="keyword">typedef</span> __I <span class="type">uint8_t</span> vuc8;  </span><br></pre></td></tr></table></figure><p>点亮led</p><p>GPIO用IO口的输出模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);<span class="comment">//控制电平</span></span><br><span class="line">HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);<span class="comment">//翻转电平</span></span><br><span class="line">HAL_GPIO_ReadPin(GPIOA, GPIO_Pin_8);<span class="comment">//读取电平</span></span><br></pre></td></tr></table></figure><p>点亮led就需要按键了，按键首先要看按键的引脚设置IO口为输入模式，写一个案件处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">static</span> u8 key_up=<span class="number">1</span>; <span class="comment">//按键松开标志</span></span><br><span class="line"> <span class="keyword">if</span>(mode==<span class="number">1</span>)key_up=<span class="number">1</span>; <span class="comment">//支持连按</span></span><br><span class="line"> <span class="keyword">if</span>(key_up&amp;&amp;(KEY0==<span class="number">0</span>||KEY1==<span class="number">0</span>||WK_UP==<span class="number">1</span>))</span><br><span class="line"> &#123;</span><br><span class="line"> delay_ms(<span class="number">10</span>);</span><br><span class="line"> key_up=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(KEY0==<span class="number">0</span>) <span class="keyword">return</span> KEY0_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">0</span>) <span class="keyword">return</span> KEY1_PRES;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(WK_UP==<span class="number">1</span>) <span class="keyword">return</span> WKUP_PRES; </span><br><span class="line">ALIENTEK MiniSTM32 V3<span class="number">.0</span> 开发板教程</span><br><span class="line"><span class="number">137</span></span><br><span class="line">STM32 不完全手册(HAL 库版)</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(KEY0==<span class="number">1</span>&amp;&amp;KEY1==<span class="number">1</span>&amp;&amp;WK_UP==<span class="number">0</span>)key_up=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//无按键按下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在头文件中进行添加宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0 HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_5) <span class="comment">//KEY0 按键 PC5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1 HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_15) <span class="comment">//KEY1 按键 PA15</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WK_UP HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) <span class="comment">//WKUP 按键 PA0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0_PRES 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WKUP_PRES 3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">u8 <span class="title function_">KEY_Scan</span><span class="params">(u8 mode)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>串口通信</p><p>usart和uart区别为 usart比uart多了同步时钟频率通信，都有异步时钟通信。</p><p>串口设置的一般步骤可以总结为如下几个步骤：</p><ol><li>串口时钟使能，GPIO 时钟使能。</li><li>设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。</li><li>GPIO 初始化设置：要设置模式为复用功能。</li><li>串口参数初始化：设置波特率，字长，奇偶校验等参数。</li><li>开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。</li><li>使能串口。</li><li>编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。</li></ol><p>串口通信的结构体如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> uint32_t BaudRate; //波特率</span><br><span class="line"> uint32_t WordLength; //字长</span><br><span class="line"> uint32_t StopBits; //停止位</span><br><span class="line"> uint32_t Parity; //奇偶校验</span><br><span class="line"> uint32_t Mode; //收/发模式设置</span><br><span class="line"> uint32_t HwFlowCtl; //硬件流设置</span><br><span class="line"> uint32_t OverSampling; //过采样设置</span><br><span class="line">&#125;UART_InitTypeDef</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile的学习</title>
      <link href="/2022/06/30/makefile/"/>
      <url>/2022/06/30/makefile/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tieba.baidu.com/p/591519800">Makefile详解（超级好）【mingw吧】_百度贴吧 (baidu.com)</a></p><p>上面挂一个较好的makefile的教程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/03/hello-world/"/>
      <url>/2022/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
